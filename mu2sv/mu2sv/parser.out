Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> prog
Rule 1     prog -> decls procdecls rules
Rule 2     decls -> decls decl
Rule 3     decls -> empty
Rule 4     decl -> CONST constdecls
Rule 5     decl -> TYPE typedecls
Rule 6     decl -> VAR vardecls
Rule 7     constdecls -> constdecls constdecl ;
Rule 8     constdecls -> empty
Rule 9     constdecl -> ID : expr
Rule 10    typedecls -> typedecls typedecl ;
Rule 11    typedecls -> empty
Rule 12    typedecl -> ID : typeexpr
Rule 13    typeexpr -> typeid
Rule 14    typeexpr -> enumtype
Rule 15    typeexpr -> subrangetype
Rule 16    typeexpr -> recordtype
Rule 17    typeexpr -> arraytype
Rule 18    typeid -> ID
Rule 19    enumtype -> ENUM { enums }
Rule 20    enums -> enums , ID
Rule 21    enums -> ID
Rule 22    subrangetype -> expr DOTDOT expr
Rule 23    recordtype -> RECORD fields END
Rule 24    fields -> fields ; field
Rule 25    fields -> fields ;
Rule 26    fields -> field
Rule 27    field -> ID fieldtail
Rule 28    fieldtail -> , ID fieldtail
Rule 29    fieldtail -> : typeexpr
Rule 30    arraytype -> ARRAY [ typeexpr ] OF typeexpr
Rule 31    vardecls -> vardecls vardecl ;
Rule 32    vardecls -> empty
Rule 33    vardecl -> ID vardecltail
Rule 34    vardecltail -> , ID vardecltail
Rule 35    vardecltail -> : typeexpr
Rule 36    procdecls -> procdecls procdecl
Rule 37    procdecls -> procdecls funcdecl
Rule 38    procdecls -> empty
Rule 39    procdecl -> PROCEDURE ID ( optformals ) ; optdecls optstmts END ;
Rule 40    funcdecl -> FUNCTION ID ( optformals ) : typeexpr ; optdecls optstmts END ;
Rule 41    optformals -> formals
Rule 42    optformals -> empty
Rule 43    formals -> formals ; formal
Rule 44    formals -> formals ;
Rule 45    formals -> formal
Rule 46    formal -> VAR formalrest
Rule 47    formal -> formalrest
Rule 48    formalrest -> ID formaltail
Rule 49    formaltail -> , ID formaltail
Rule 50    formaltail -> : typeexpr
Rule 51    optdecls -> decls BEGIN
Rule 52    optdecls -> empty
Rule 53    designator -> ID
Rule 54    designator -> designator [ expr ]
Rule 55    designator -> designator . ID
Rule 56    expr -> expr ? expr : expr
Rule 57    expr -> expr IMPLIES expr
Rule 58    expr -> expr | expr
Rule 59    expr -> expr & expr
Rule 60    expr -> expr < expr
Rule 61    expr -> expr LEQ expr
Rule 62    expr -> expr > expr
Rule 63    expr -> expr GEQ expr
Rule 64    expr -> expr = expr
Rule 65    expr -> expr NEQ expr
Rule 66    expr -> expr + expr
Rule 67    expr -> expr - expr
Rule 68    expr -> expr * expr
Rule 69    expr -> expr / expr
Rule 70    expr -> expr % expr
Rule 71    expr -> ! expr
Rule 72    expr -> + expr
Rule 73    expr -> - expr
Rule 74    expr -> INTCONST
Rule 75    expr -> designator
Rule 76    expr -> ID actuals
Rule 77    expr -> ISUNDEFINED ( designator )
Rule 78    expr -> ( expr )
Rule 79    expr -> FORALL quantifiers DO expr END
Rule 80    expr -> EXISTS quantifiers DO expr END
Rule 81    actuals -> ( exprlist )
Rule 82    actuals -> ( )
Rule 83    exprlist -> exprlist , expr
Rule 84    exprlist -> expr
Rule 85    quantifier -> ID : typeexpr
Rule 86    quantifiers -> quantifier ; quantifiers
Rule 87    quantifiers -> quantifier
Rule 88    optstmts -> stmts
Rule 89    optstmts -> empty
Rule 90    stmts -> stmts ; stmt
Rule 91    stmts -> stmts ;
Rule 92    stmts -> stmt
Rule 93    stmt -> assignment
Rule 94    stmt -> ifstmt
Rule 95    stmt -> whilestmt
Rule 96    stmt -> switchstmt
Rule 97    stmt -> forstmt
Rule 98    stmt -> proccall
Rule 99    stmt -> clearstmt
Rule 100   stmt -> errorstmt
Rule 101   stmt -> assertstmt
Rule 102   stmt -> aliasstmt
Rule 103   stmt -> returnstmt
Rule 104   stmt -> undefinestmt
Rule 105   assignment -> designator ASSIGN expr
Rule 106   ifstmt -> IF expr THEN optstmts optelses END
Rule 107   optelses -> elsif optelses
Rule 108   optelses -> optelse
Rule 109   elsif -> ELSIF expr THEN optstmts
Rule 110   optelse -> ELSE optstmts
Rule 111   optelse -> empty
Rule 112   whilestmt -> WHILE expr DO optstmts END
Rule 113   switchstmt -> SWITCH expr optcases optelse END
Rule 114   optcases -> optcases case
Rule 115   optcases -> empty
Rule 116   case -> CASE exprlist : optstmts
Rule 117   forstmt -> FOR quantifiers DO optstmts END
Rule 118   proccall -> ID actuals
Rule 119   clearstmt -> CLEAR designator
Rule 120   undefinestmt -> UNDEFINE designator
Rule 121   errorstmt -> ERROR STRING
Rule 122   assertstmt -> ASSERT expr optstring
Rule 123   aliasstmt -> ALIAS aliases DO optstmts END
Rule 124   aliases -> aliases ; alias
Rule 125   aliases -> aliases ;
Rule 126   aliases -> alias
Rule 127   alias -> ID : expr
Rule 128   returnstmt -> RETURN optretexpr
Rule 129   optretexpr -> expr
Rule 130   optretexpr -> empty
Rule 131   rules -> rule ; rules
Rule 132   rules -> rule ;
Rule 133   rules -> rule
Rule 134   rule -> simplerule
Rule 135   rule -> aliasrule
Rule 136   rule -> ruleset
Rule 137   rule -> startstate
Rule 138   rule -> invariant
Rule 139   simplerule -> RULE optstring optcondition optdecls optstmts END
Rule 140   optcondition -> expr LONGARROW
Rule 141   optcondition -> empty
Rule 142   optstring -> STRING
Rule 143   optstring -> empty
Rule 144   aliasrule -> ALIAS aliases DO rules END
Rule 145   ruleset -> RULESET quantifiers DO rules END
Rule 146   startstate -> STARTSTATE optstring optdecls optstmts END
Rule 147   invariant -> INVARIANT optstring expr
Rule 148   empty -> <empty>

Terminals, with rules where they appear

!                    : 71
%                    : 70
&                    : 59
(                    : 39 40 77 78 81 82
)                    : 39 40 77 78 81 82
*                    : 68
+                    : 66 72
,                    : 20 28 34 49 83
-                    : 67 73
.                    : 55
/                    : 69
:                    : 9 12 29 35 40 50 56 85 116 127
;                    : 7 10 24 25 31 39 39 40 40 43 44 86 90 91 124 125 131 132
<                    : 60
=                    : 64
>                    : 62
?                    : 56
ALIAS                : 123 144
ARRAY                : 30
ASSERT               : 122
ASSIGN               : 105
BEGIN                : 51
CASE                 : 116
CLEAR                : 119
CONST                : 4
DO                   : 79 80 112 117 123 144 145
DOTDOT               : 22
ELSE                 : 110
ELSIF                : 109
END                  : 23 39 40 79 80 106 112 113 117 123 139 144 145 146
ENUM                 : 19
ERROR                : 121
EXISTS               : 80
FOR                  : 117
FORALL               : 79
FUNCTION             : 40
GEQ                  : 63
ID                   : 9 12 18 20 21 27 28 33 34 39 40 48 49 53 55 76 85 118 127
IF                   : 106
IMPLIES              : 57
INTCONST             : 74
INVARIANT            : 147
ISUNDEFINED          : 77
LEQ                  : 61
LONGARROW            : 140
NEQ                  : 65
OF                   : 30
PROCEDURE            : 39
RECORD               : 23
RETURN               : 128
RULE                 : 139
RULESET              : 145
STARTSTATE           : 146
STRING               : 121 142
SWITCH               : 113
THEN                 : 106 109
TYPE                 : 5
UNDEFINE             : 120
VAR                  : 6 46
WHILE                : 112
[                    : 30 54
]                    : 30 54
error                : 
{                    : 19
|                    : 58
}                    : 19

Nonterminals, with rules where they appear

actuals              : 76 118
alias                : 124 126
aliases              : 123 124 125 144
aliasrule            : 135
aliasstmt            : 102
arraytype            : 17
assertstmt           : 101
assignment           : 93
case                 : 114
clearstmt            : 99
constdecl            : 7
constdecls           : 4 7
decl                 : 2
decls                : 1 2 51
designator           : 54 55 75 77 105 119 120
elsif                : 107
empty                : 3 8 11 32 38 42 52 89 111 115 130 141 143
enums                : 19 20
enumtype             : 14
errorstmt            : 100
expr                 : 9 22 22 54 56 56 56 57 57 58 58 59 59 60 60 61 61 62 62 63 63 64 64 65 65 66 66 67 67 68 68 69 69 70 70 71 72 73 78 79 80 83 84 105 106 109 112 113 122 127 129 140 147
exprlist             : 81 83 116
field                : 24 26
fields               : 23 24 25
fieldtail            : 27 28
formal               : 43 45
formalrest           : 46 47
formals              : 41 43 44
formaltail           : 48 49
forstmt              : 97
funcdecl             : 37
ifstmt               : 94
invariant            : 138
optcases             : 113 114
optcondition         : 139
optdecls             : 39 40 139 146
optelse              : 108 113
optelses             : 106 107
optformals           : 39 40
optretexpr           : 128
optstmts             : 39 40 106 109 110 112 116 117 123 139 146
optstring            : 122 139 146 147
proccall             : 98
procdecl             : 36
procdecls            : 1 36 37
prog                 : 0
quantifier           : 86 87
quantifiers          : 79 80 86 117 145
recordtype           : 16
returnstmt           : 103
rule                 : 131 132 133
rules                : 1 131 144 145
ruleset              : 136
simplerule           : 134
startstate           : 137
stmt                 : 90 92
stmts                : 88 90 91
subrangetype         : 15
switchstmt           : 96
typedecl             : 10
typedecls            : 5 10
typeexpr             : 12 29 30 30 35 40 50 85
typeid               : 13
undefinestmt         : 104
vardecl              : 31
vardecls             : 6 31
vardecltail          : 33 34
whilestmt            : 95

Parsing method: LALR

state 0

    (0) S' -> . prog
    (1) prog -> . decls procdecls rules
    (2) decls -> . decls decl
    (3) decls -> . empty
    (148) empty -> .

    CONST           reduce using rule 148 (empty -> .)
    TYPE            reduce using rule 148 (empty -> .)
    VAR             reduce using rule 148 (empty -> .)
    PROCEDURE       reduce using rule 148 (empty -> .)
    FUNCTION        reduce using rule 148 (empty -> .)
    RULE            reduce using rule 148 (empty -> .)
    ALIAS           reduce using rule 148 (empty -> .)
    RULESET         reduce using rule 148 (empty -> .)
    STARTSTATE      reduce using rule 148 (empty -> .)
    INVARIANT       reduce using rule 148 (empty -> .)

    prog                           shift and go to state 1
    decls                          shift and go to state 2
    empty                          shift and go to state 3

state 1

    (0) S' -> prog .



state 2

    (1) prog -> decls . procdecls rules
    (2) decls -> decls . decl
    (36) procdecls -> . procdecls procdecl
    (37) procdecls -> . procdecls funcdecl
    (38) procdecls -> . empty
    (4) decl -> . CONST constdecls
    (5) decl -> . TYPE typedecls
    (6) decl -> . VAR vardecls
    (148) empty -> .

    CONST           shift and go to state 7
    TYPE            shift and go to state 8
    VAR             shift and go to state 9
    PROCEDURE       reduce using rule 148 (empty -> .)
    FUNCTION        reduce using rule 148 (empty -> .)
    RULE            reduce using rule 148 (empty -> .)
    ALIAS           reduce using rule 148 (empty -> .)
    RULESET         reduce using rule 148 (empty -> .)
    STARTSTATE      reduce using rule 148 (empty -> .)
    INVARIANT       reduce using rule 148 (empty -> .)

    procdecls                      shift and go to state 4
    decl                           shift and go to state 5
    empty                          shift and go to state 6

state 3

    (3) decls -> empty .

    CONST           reduce using rule 3 (decls -> empty .)
    TYPE            reduce using rule 3 (decls -> empty .)
    VAR             reduce using rule 3 (decls -> empty .)
    PROCEDURE       reduce using rule 3 (decls -> empty .)
    FUNCTION        reduce using rule 3 (decls -> empty .)
    RULE            reduce using rule 3 (decls -> empty .)
    ALIAS           reduce using rule 3 (decls -> empty .)
    RULESET         reduce using rule 3 (decls -> empty .)
    STARTSTATE      reduce using rule 3 (decls -> empty .)
    INVARIANT       reduce using rule 3 (decls -> empty .)


state 4

    (1) prog -> decls procdecls . rules
    (36) procdecls -> procdecls . procdecl
    (37) procdecls -> procdecls . funcdecl
    (131) rules -> . rule ; rules
    (132) rules -> . rule ;
    (133) rules -> . rule
    (39) procdecl -> . PROCEDURE ID ( optformals ) ; optdecls optstmts END ;
    (40) funcdecl -> . FUNCTION ID ( optformals ) : typeexpr ; optdecls optstmts END ;
    (134) rule -> . simplerule
    (135) rule -> . aliasrule
    (136) rule -> . ruleset
    (137) rule -> . startstate
    (138) rule -> . invariant
    (139) simplerule -> . RULE optstring optcondition optdecls optstmts END
    (144) aliasrule -> . ALIAS aliases DO rules END
    (145) ruleset -> . RULESET quantifiers DO rules END
    (146) startstate -> . STARTSTATE optstring optdecls optstmts END
    (147) invariant -> . INVARIANT optstring expr

    PROCEDURE       shift and go to state 14
    FUNCTION        shift and go to state 15
    RULE            shift and go to state 21
    ALIAS           shift and go to state 22
    RULESET         shift and go to state 23
    STARTSTATE      shift and go to state 24
    INVARIANT       shift and go to state 25

    rules                          shift and go to state 10
    procdecl                       shift and go to state 11
    funcdecl                       shift and go to state 12
    rule                           shift and go to state 13
    simplerule                     shift and go to state 16
    aliasrule                      shift and go to state 17
    ruleset                        shift and go to state 18
    startstate                     shift and go to state 19
    invariant                      shift and go to state 20

state 5

    (2) decls -> decls decl .

    CONST           reduce using rule 2 (decls -> decls decl .)
    TYPE            reduce using rule 2 (decls -> decls decl .)
    VAR             reduce using rule 2 (decls -> decls decl .)
    PROCEDURE       reduce using rule 2 (decls -> decls decl .)
    FUNCTION        reduce using rule 2 (decls -> decls decl .)
    RULE            reduce using rule 2 (decls -> decls decl .)
    ALIAS           reduce using rule 2 (decls -> decls decl .)
    RULESET         reduce using rule 2 (decls -> decls decl .)
    STARTSTATE      reduce using rule 2 (decls -> decls decl .)
    INVARIANT       reduce using rule 2 (decls -> decls decl .)
    BEGIN           reduce using rule 2 (decls -> decls decl .)


state 6

    (38) procdecls -> empty .

    PROCEDURE       reduce using rule 38 (procdecls -> empty .)
    FUNCTION        reduce using rule 38 (procdecls -> empty .)
    RULE            reduce using rule 38 (procdecls -> empty .)
    ALIAS           reduce using rule 38 (procdecls -> empty .)
    RULESET         reduce using rule 38 (procdecls -> empty .)
    STARTSTATE      reduce using rule 38 (procdecls -> empty .)
    INVARIANT       reduce using rule 38 (procdecls -> empty .)


state 7

    (4) decl -> CONST . constdecls
    (7) constdecls -> . constdecls constdecl ;
    (8) constdecls -> . empty
    (148) empty -> .

    ID              reduce using rule 148 (empty -> .)
    CONST           reduce using rule 148 (empty -> .)
    TYPE            reduce using rule 148 (empty -> .)
    VAR             reduce using rule 148 (empty -> .)
    PROCEDURE       reduce using rule 148 (empty -> .)
    FUNCTION        reduce using rule 148 (empty -> .)
    RULE            reduce using rule 148 (empty -> .)
    ALIAS           reduce using rule 148 (empty -> .)
    RULESET         reduce using rule 148 (empty -> .)
    STARTSTATE      reduce using rule 148 (empty -> .)
    INVARIANT       reduce using rule 148 (empty -> .)
    BEGIN           reduce using rule 148 (empty -> .)

    constdecls                     shift and go to state 26
    empty                          shift and go to state 27

state 8

    (5) decl -> TYPE . typedecls
    (10) typedecls -> . typedecls typedecl ;
    (11) typedecls -> . empty
    (148) empty -> .

    ID              reduce using rule 148 (empty -> .)
    CONST           reduce using rule 148 (empty -> .)
    TYPE            reduce using rule 148 (empty -> .)
    VAR             reduce using rule 148 (empty -> .)
    PROCEDURE       reduce using rule 148 (empty -> .)
    FUNCTION        reduce using rule 148 (empty -> .)
    RULE            reduce using rule 148 (empty -> .)
    ALIAS           reduce using rule 148 (empty -> .)
    RULESET         reduce using rule 148 (empty -> .)
    STARTSTATE      reduce using rule 148 (empty -> .)
    INVARIANT       reduce using rule 148 (empty -> .)
    BEGIN           reduce using rule 148 (empty -> .)

    typedecls                      shift and go to state 28
    empty                          shift and go to state 29

state 9

    (6) decl -> VAR . vardecls
    (31) vardecls -> . vardecls vardecl ;
    (32) vardecls -> . empty
    (148) empty -> .

    ID              reduce using rule 148 (empty -> .)
    CONST           reduce using rule 148 (empty -> .)
    TYPE            reduce using rule 148 (empty -> .)
    VAR             reduce using rule 148 (empty -> .)
    PROCEDURE       reduce using rule 148 (empty -> .)
    FUNCTION        reduce using rule 148 (empty -> .)
    RULE            reduce using rule 148 (empty -> .)
    ALIAS           reduce using rule 148 (empty -> .)
    RULESET         reduce using rule 148 (empty -> .)
    STARTSTATE      reduce using rule 148 (empty -> .)
    INVARIANT       reduce using rule 148 (empty -> .)
    BEGIN           reduce using rule 148 (empty -> .)

    vardecls                       shift and go to state 30
    empty                          shift and go to state 31

state 10

    (1) prog -> decls procdecls rules .

    $end            reduce using rule 1 (prog -> decls procdecls rules .)


state 11

    (36) procdecls -> procdecls procdecl .

    PROCEDURE       reduce using rule 36 (procdecls -> procdecls procdecl .)
    FUNCTION        reduce using rule 36 (procdecls -> procdecls procdecl .)
    RULE            reduce using rule 36 (procdecls -> procdecls procdecl .)
    ALIAS           reduce using rule 36 (procdecls -> procdecls procdecl .)
    RULESET         reduce using rule 36 (procdecls -> procdecls procdecl .)
    STARTSTATE      reduce using rule 36 (procdecls -> procdecls procdecl .)
    INVARIANT       reduce using rule 36 (procdecls -> procdecls procdecl .)


state 12

    (37) procdecls -> procdecls funcdecl .

    PROCEDURE       reduce using rule 37 (procdecls -> procdecls funcdecl .)
    FUNCTION        reduce using rule 37 (procdecls -> procdecls funcdecl .)
    RULE            reduce using rule 37 (procdecls -> procdecls funcdecl .)
    ALIAS           reduce using rule 37 (procdecls -> procdecls funcdecl .)
    RULESET         reduce using rule 37 (procdecls -> procdecls funcdecl .)
    STARTSTATE      reduce using rule 37 (procdecls -> procdecls funcdecl .)
    INVARIANT       reduce using rule 37 (procdecls -> procdecls funcdecl .)


state 13

    (131) rules -> rule . ; rules
    (132) rules -> rule . ;
    (133) rules -> rule .

    ;               shift and go to state 32
    $end            reduce using rule 133 (rules -> rule .)
    END             reduce using rule 133 (rules -> rule .)


state 14

    (39) procdecl -> PROCEDURE . ID ( optformals ) ; optdecls optstmts END ;

    ID              shift and go to state 33


state 15

    (40) funcdecl -> FUNCTION . ID ( optformals ) : typeexpr ; optdecls optstmts END ;

    ID              shift and go to state 34


state 16

    (134) rule -> simplerule .

    ;               reduce using rule 134 (rule -> simplerule .)
    $end            reduce using rule 134 (rule -> simplerule .)
    END             reduce using rule 134 (rule -> simplerule .)


state 17

    (135) rule -> aliasrule .

    ;               reduce using rule 135 (rule -> aliasrule .)
    $end            reduce using rule 135 (rule -> aliasrule .)
    END             reduce using rule 135 (rule -> aliasrule .)


state 18

    (136) rule -> ruleset .

    ;               reduce using rule 136 (rule -> ruleset .)
    $end            reduce using rule 136 (rule -> ruleset .)
    END             reduce using rule 136 (rule -> ruleset .)


state 19

    (137) rule -> startstate .

    ;               reduce using rule 137 (rule -> startstate .)
    $end            reduce using rule 137 (rule -> startstate .)
    END             reduce using rule 137 (rule -> startstate .)


state 20

    (138) rule -> invariant .

    ;               reduce using rule 138 (rule -> invariant .)
    $end            reduce using rule 138 (rule -> invariant .)
    END             reduce using rule 138 (rule -> invariant .)


state 21

    (139) simplerule -> RULE . optstring optcondition optdecls optstmts END
    (142) optstring -> . STRING
    (143) optstring -> . empty
    (148) empty -> .

    STRING          shift and go to state 36
    !               reduce using rule 148 (empty -> .)
    +               reduce using rule 148 (empty -> .)
    -               reduce using rule 148 (empty -> .)
    INTCONST        reduce using rule 148 (empty -> .)
    ID              reduce using rule 148 (empty -> .)
    ISUNDEFINED     reduce using rule 148 (empty -> .)
    (               reduce using rule 148 (empty -> .)
    FORALL          reduce using rule 148 (empty -> .)
    EXISTS          reduce using rule 148 (empty -> .)
    IF              reduce using rule 148 (empty -> .)
    WHILE           reduce using rule 148 (empty -> .)
    SWITCH          reduce using rule 148 (empty -> .)
    FOR             reduce using rule 148 (empty -> .)
    CLEAR           reduce using rule 148 (empty -> .)
    ERROR           reduce using rule 148 (empty -> .)
    ASSERT          reduce using rule 148 (empty -> .)
    ALIAS           reduce using rule 148 (empty -> .)
    RETURN          reduce using rule 148 (empty -> .)
    UNDEFINE        reduce using rule 148 (empty -> .)
    END             reduce using rule 148 (empty -> .)
    BEGIN           reduce using rule 148 (empty -> .)
    CONST           reduce using rule 148 (empty -> .)
    TYPE            reduce using rule 148 (empty -> .)
    VAR             reduce using rule 148 (empty -> .)

    optstring                      shift and go to state 35
    empty                          shift and go to state 37

state 22

    (144) aliasrule -> ALIAS . aliases DO rules END
    (124) aliases -> . aliases ; alias
    (125) aliases -> . aliases ;
    (126) aliases -> . alias
    (127) alias -> . ID : expr

    ID              shift and go to state 40

    aliases                        shift and go to state 38
    alias                          shift and go to state 39

state 23

    (145) ruleset -> RULESET . quantifiers DO rules END
    (86) quantifiers -> . quantifier ; quantifiers
    (87) quantifiers -> . quantifier
    (85) quantifier -> . ID : typeexpr

    ID              shift and go to state 43

    quantifiers                    shift and go to state 41
    quantifier                     shift and go to state 42

state 24

    (146) startstate -> STARTSTATE . optstring optdecls optstmts END
    (142) optstring -> . STRING
    (143) optstring -> . empty
    (148) empty -> .

    STRING          shift and go to state 36
    IF              reduce using rule 148 (empty -> .)
    WHILE           reduce using rule 148 (empty -> .)
    SWITCH          reduce using rule 148 (empty -> .)
    FOR             reduce using rule 148 (empty -> .)
    ID              reduce using rule 148 (empty -> .)
    CLEAR           reduce using rule 148 (empty -> .)
    ERROR           reduce using rule 148 (empty -> .)
    ASSERT          reduce using rule 148 (empty -> .)
    ALIAS           reduce using rule 148 (empty -> .)
    RETURN          reduce using rule 148 (empty -> .)
    UNDEFINE        reduce using rule 148 (empty -> .)
    END             reduce using rule 148 (empty -> .)
    BEGIN           reduce using rule 148 (empty -> .)
    CONST           reduce using rule 148 (empty -> .)
    TYPE            reduce using rule 148 (empty -> .)
    VAR             reduce using rule 148 (empty -> .)

    optstring                      shift and go to state 44
    empty                          shift and go to state 37

state 25

    (147) invariant -> INVARIANT . optstring expr
    (142) optstring -> . STRING
    (143) optstring -> . empty
    (148) empty -> .

    STRING          shift and go to state 36
    !               reduce using rule 148 (empty -> .)
    +               reduce using rule 148 (empty -> .)
    -               reduce using rule 148 (empty -> .)
    INTCONST        reduce using rule 148 (empty -> .)
    ID              reduce using rule 148 (empty -> .)
    ISUNDEFINED     reduce using rule 148 (empty -> .)
    (               reduce using rule 148 (empty -> .)
    FORALL          reduce using rule 148 (empty -> .)
    EXISTS          reduce using rule 148 (empty -> .)

    optstring                      shift and go to state 45
    empty                          shift and go to state 37

state 26

    (4) decl -> CONST constdecls .
    (7) constdecls -> constdecls . constdecl ;
    (9) constdecl -> . ID : expr

    CONST           reduce using rule 4 (decl -> CONST constdecls .)
    TYPE            reduce using rule 4 (decl -> CONST constdecls .)
    VAR             reduce using rule 4 (decl -> CONST constdecls .)
    PROCEDURE       reduce using rule 4 (decl -> CONST constdecls .)
    FUNCTION        reduce using rule 4 (decl -> CONST constdecls .)
    RULE            reduce using rule 4 (decl -> CONST constdecls .)
    ALIAS           reduce using rule 4 (decl -> CONST constdecls .)
    RULESET         reduce using rule 4 (decl -> CONST constdecls .)
    STARTSTATE      reduce using rule 4 (decl -> CONST constdecls .)
    INVARIANT       reduce using rule 4 (decl -> CONST constdecls .)
    BEGIN           reduce using rule 4 (decl -> CONST constdecls .)
    ID              shift and go to state 47

    constdecl                      shift and go to state 46

state 27

    (8) constdecls -> empty .

    ID              reduce using rule 8 (constdecls -> empty .)
    CONST           reduce using rule 8 (constdecls -> empty .)
    TYPE            reduce using rule 8 (constdecls -> empty .)
    VAR             reduce using rule 8 (constdecls -> empty .)
    PROCEDURE       reduce using rule 8 (constdecls -> empty .)
    FUNCTION        reduce using rule 8 (constdecls -> empty .)
    RULE            reduce using rule 8 (constdecls -> empty .)
    ALIAS           reduce using rule 8 (constdecls -> empty .)
    RULESET         reduce using rule 8 (constdecls -> empty .)
    STARTSTATE      reduce using rule 8 (constdecls -> empty .)
    INVARIANT       reduce using rule 8 (constdecls -> empty .)
    BEGIN           reduce using rule 8 (constdecls -> empty .)


state 28

    (5) decl -> TYPE typedecls .
    (10) typedecls -> typedecls . typedecl ;
    (12) typedecl -> . ID : typeexpr

    CONST           reduce using rule 5 (decl -> TYPE typedecls .)
    TYPE            reduce using rule 5 (decl -> TYPE typedecls .)
    VAR             reduce using rule 5 (decl -> TYPE typedecls .)
    PROCEDURE       reduce using rule 5 (decl -> TYPE typedecls .)
    FUNCTION        reduce using rule 5 (decl -> TYPE typedecls .)
    RULE            reduce using rule 5 (decl -> TYPE typedecls .)
    ALIAS           reduce using rule 5 (decl -> TYPE typedecls .)
    RULESET         reduce using rule 5 (decl -> TYPE typedecls .)
    STARTSTATE      reduce using rule 5 (decl -> TYPE typedecls .)
    INVARIANT       reduce using rule 5 (decl -> TYPE typedecls .)
    BEGIN           reduce using rule 5 (decl -> TYPE typedecls .)
    ID              shift and go to state 49

    typedecl                       shift and go to state 48

state 29

    (11) typedecls -> empty .

    ID              reduce using rule 11 (typedecls -> empty .)
    CONST           reduce using rule 11 (typedecls -> empty .)
    TYPE            reduce using rule 11 (typedecls -> empty .)
    VAR             reduce using rule 11 (typedecls -> empty .)
    PROCEDURE       reduce using rule 11 (typedecls -> empty .)
    FUNCTION        reduce using rule 11 (typedecls -> empty .)
    RULE            reduce using rule 11 (typedecls -> empty .)
    ALIAS           reduce using rule 11 (typedecls -> empty .)
    RULESET         reduce using rule 11 (typedecls -> empty .)
    STARTSTATE      reduce using rule 11 (typedecls -> empty .)
    INVARIANT       reduce using rule 11 (typedecls -> empty .)
    BEGIN           reduce using rule 11 (typedecls -> empty .)


state 30

    (6) decl -> VAR vardecls .
    (31) vardecls -> vardecls . vardecl ;
    (33) vardecl -> . ID vardecltail

    CONST           reduce using rule 6 (decl -> VAR vardecls .)
    TYPE            reduce using rule 6 (decl -> VAR vardecls .)
    VAR             reduce using rule 6 (decl -> VAR vardecls .)
    PROCEDURE       reduce using rule 6 (decl -> VAR vardecls .)
    FUNCTION        reduce using rule 6 (decl -> VAR vardecls .)
    RULE            reduce using rule 6 (decl -> VAR vardecls .)
    ALIAS           reduce using rule 6 (decl -> VAR vardecls .)
    RULESET         reduce using rule 6 (decl -> VAR vardecls .)
    STARTSTATE      reduce using rule 6 (decl -> VAR vardecls .)
    INVARIANT       reduce using rule 6 (decl -> VAR vardecls .)
    BEGIN           reduce using rule 6 (decl -> VAR vardecls .)
    ID              shift and go to state 51

    vardecl                        shift and go to state 50

state 31

    (32) vardecls -> empty .

    ID              reduce using rule 32 (vardecls -> empty .)
    CONST           reduce using rule 32 (vardecls -> empty .)
    TYPE            reduce using rule 32 (vardecls -> empty .)
    VAR             reduce using rule 32 (vardecls -> empty .)
    PROCEDURE       reduce using rule 32 (vardecls -> empty .)
    FUNCTION        reduce using rule 32 (vardecls -> empty .)
    RULE            reduce using rule 32 (vardecls -> empty .)
    ALIAS           reduce using rule 32 (vardecls -> empty .)
    RULESET         reduce using rule 32 (vardecls -> empty .)
    STARTSTATE      reduce using rule 32 (vardecls -> empty .)
    INVARIANT       reduce using rule 32 (vardecls -> empty .)
    BEGIN           reduce using rule 32 (vardecls -> empty .)


state 32

    (131) rules -> rule ; . rules
    (132) rules -> rule ; .
    (131) rules -> . rule ; rules
    (132) rules -> . rule ;
    (133) rules -> . rule
    (134) rule -> . simplerule
    (135) rule -> . aliasrule
    (136) rule -> . ruleset
    (137) rule -> . startstate
    (138) rule -> . invariant
    (139) simplerule -> . RULE optstring optcondition optdecls optstmts END
    (144) aliasrule -> . ALIAS aliases DO rules END
    (145) ruleset -> . RULESET quantifiers DO rules END
    (146) startstate -> . STARTSTATE optstring optdecls optstmts END
    (147) invariant -> . INVARIANT optstring expr

    $end            reduce using rule 132 (rules -> rule ; .)
    END             reduce using rule 132 (rules -> rule ; .)
    RULE            shift and go to state 21
    ALIAS           shift and go to state 22
    RULESET         shift and go to state 23
    STARTSTATE      shift and go to state 24
    INVARIANT       shift and go to state 25

    rule                           shift and go to state 13
    rules                          shift and go to state 52
    simplerule                     shift and go to state 16
    aliasrule                      shift and go to state 17
    ruleset                        shift and go to state 18
    startstate                     shift and go to state 19
    invariant                      shift and go to state 20

state 33

    (39) procdecl -> PROCEDURE ID . ( optformals ) ; optdecls optstmts END ;

    (               shift and go to state 53


state 34

    (40) funcdecl -> FUNCTION ID . ( optformals ) : typeexpr ; optdecls optstmts END ;

    (               shift and go to state 54


state 35

    (139) simplerule -> RULE optstring . optcondition optdecls optstmts END
    (140) optcondition -> . expr LONGARROW
    (141) optcondition -> . empty
    (56) expr -> . expr ? expr : expr
    (57) expr -> . expr IMPLIES expr
    (58) expr -> . expr | expr
    (59) expr -> . expr & expr
    (60) expr -> . expr < expr
    (61) expr -> . expr LEQ expr
    (62) expr -> . expr > expr
    (63) expr -> . expr GEQ expr
    (64) expr -> . expr = expr
    (65) expr -> . expr NEQ expr
    (66) expr -> . expr + expr
    (67) expr -> . expr - expr
    (68) expr -> . expr * expr
    (69) expr -> . expr / expr
    (70) expr -> . expr % expr
    (71) expr -> . ! expr
    (72) expr -> . + expr
    (73) expr -> . - expr
    (74) expr -> . INTCONST
    (75) expr -> . designator
    (76) expr -> . ID actuals
    (77) expr -> . ISUNDEFINED ( designator )
    (78) expr -> . ( expr )
    (79) expr -> . FORALL quantifiers DO expr END
    (80) expr -> . EXISTS quantifiers DO expr END
    (148) empty -> .
    (53) designator -> . ID
    (54) designator -> . designator [ expr ]
    (55) designator -> . designator . ID

  ! shift/reduce conflict for ID resolved as shift
    !               shift and go to state 60
    +               shift and go to state 58
    -               shift and go to state 59
    INTCONST        shift and go to state 61
    ID              shift and go to state 63
    ISUNDEFINED     shift and go to state 64
    (               shift and go to state 65
    FORALL          shift and go to state 66
    EXISTS          shift and go to state 67
    IF              reduce using rule 148 (empty -> .)
    WHILE           reduce using rule 148 (empty -> .)
    SWITCH          reduce using rule 148 (empty -> .)
    FOR             reduce using rule 148 (empty -> .)
    CLEAR           reduce using rule 148 (empty -> .)
    ERROR           reduce using rule 148 (empty -> .)
    ASSERT          reduce using rule 148 (empty -> .)
    ALIAS           reduce using rule 148 (empty -> .)
    RETURN          reduce using rule 148 (empty -> .)
    UNDEFINE        reduce using rule 148 (empty -> .)
    END             reduce using rule 148 (empty -> .)
    BEGIN           reduce using rule 148 (empty -> .)
    CONST           reduce using rule 148 (empty -> .)
    TYPE            reduce using rule 148 (empty -> .)
    VAR             reduce using rule 148 (empty -> .)

  ! ID              [ reduce using rule 148 (empty -> .) ]

    optcondition                   shift and go to state 55
    expr                           shift and go to state 56
    empty                          shift and go to state 57
    designator                     shift and go to state 62

state 36

    (142) optstring -> STRING .

    !               reduce using rule 142 (optstring -> STRING .)
    +               reduce using rule 142 (optstring -> STRING .)
    -               reduce using rule 142 (optstring -> STRING .)
    INTCONST        reduce using rule 142 (optstring -> STRING .)
    ID              reduce using rule 142 (optstring -> STRING .)
    ISUNDEFINED     reduce using rule 142 (optstring -> STRING .)
    (               reduce using rule 142 (optstring -> STRING .)
    FORALL          reduce using rule 142 (optstring -> STRING .)
    EXISTS          reduce using rule 142 (optstring -> STRING .)
    IF              reduce using rule 142 (optstring -> STRING .)
    WHILE           reduce using rule 142 (optstring -> STRING .)
    SWITCH          reduce using rule 142 (optstring -> STRING .)
    FOR             reduce using rule 142 (optstring -> STRING .)
    CLEAR           reduce using rule 142 (optstring -> STRING .)
    ERROR           reduce using rule 142 (optstring -> STRING .)
    ASSERT          reduce using rule 142 (optstring -> STRING .)
    ALIAS           reduce using rule 142 (optstring -> STRING .)
    RETURN          reduce using rule 142 (optstring -> STRING .)
    UNDEFINE        reduce using rule 142 (optstring -> STRING .)
    END             reduce using rule 142 (optstring -> STRING .)
    BEGIN           reduce using rule 142 (optstring -> STRING .)
    CONST           reduce using rule 142 (optstring -> STRING .)
    TYPE            reduce using rule 142 (optstring -> STRING .)
    VAR             reduce using rule 142 (optstring -> STRING .)
    ;               reduce using rule 142 (optstring -> STRING .)
    ELSIF           reduce using rule 142 (optstring -> STRING .)
    ELSE            reduce using rule 142 (optstring -> STRING .)
    CASE            reduce using rule 142 (optstring -> STRING .)


state 37

    (143) optstring -> empty .

    !               reduce using rule 143 (optstring -> empty .)
    +               reduce using rule 143 (optstring -> empty .)
    -               reduce using rule 143 (optstring -> empty .)
    INTCONST        reduce using rule 143 (optstring -> empty .)
    ID              reduce using rule 143 (optstring -> empty .)
    ISUNDEFINED     reduce using rule 143 (optstring -> empty .)
    (               reduce using rule 143 (optstring -> empty .)
    FORALL          reduce using rule 143 (optstring -> empty .)
    EXISTS          reduce using rule 143 (optstring -> empty .)
    IF              reduce using rule 143 (optstring -> empty .)
    WHILE           reduce using rule 143 (optstring -> empty .)
    SWITCH          reduce using rule 143 (optstring -> empty .)
    FOR             reduce using rule 143 (optstring -> empty .)
    CLEAR           reduce using rule 143 (optstring -> empty .)
    ERROR           reduce using rule 143 (optstring -> empty .)
    ASSERT          reduce using rule 143 (optstring -> empty .)
    ALIAS           reduce using rule 143 (optstring -> empty .)
    RETURN          reduce using rule 143 (optstring -> empty .)
    UNDEFINE        reduce using rule 143 (optstring -> empty .)
    END             reduce using rule 143 (optstring -> empty .)
    BEGIN           reduce using rule 143 (optstring -> empty .)
    CONST           reduce using rule 143 (optstring -> empty .)
    TYPE            reduce using rule 143 (optstring -> empty .)
    VAR             reduce using rule 143 (optstring -> empty .)
    ;               reduce using rule 143 (optstring -> empty .)
    ELSIF           reduce using rule 143 (optstring -> empty .)
    ELSE            reduce using rule 143 (optstring -> empty .)
    CASE            reduce using rule 143 (optstring -> empty .)


state 38

    (144) aliasrule -> ALIAS aliases . DO rules END
    (124) aliases -> aliases . ; alias
    (125) aliases -> aliases . ;

    DO              shift and go to state 68
    ;               shift and go to state 69


state 39

    (126) aliases -> alias .

    DO              reduce using rule 126 (aliases -> alias .)
    ;               reduce using rule 126 (aliases -> alias .)


state 40

    (127) alias -> ID . : expr

    :               shift and go to state 70


state 41

    (145) ruleset -> RULESET quantifiers . DO rules END

    DO              shift and go to state 71


state 42

    (86) quantifiers -> quantifier . ; quantifiers
    (87) quantifiers -> quantifier .

    ;               shift and go to state 72
    DO              reduce using rule 87 (quantifiers -> quantifier .)


state 43

    (85) quantifier -> ID . : typeexpr

    :               shift and go to state 73


state 44

    (146) startstate -> STARTSTATE optstring . optdecls optstmts END
    (51) optdecls -> . decls BEGIN
    (52) optdecls -> . empty
    (2) decls -> . decls decl
    (3) decls -> . empty
    (148) empty -> .

    IF              reduce using rule 148 (empty -> .)
    WHILE           reduce using rule 148 (empty -> .)
    SWITCH          reduce using rule 148 (empty -> .)
    FOR             reduce using rule 148 (empty -> .)
    ID              reduce using rule 148 (empty -> .)
    CLEAR           reduce using rule 148 (empty -> .)
    ERROR           reduce using rule 148 (empty -> .)
    ASSERT          reduce using rule 148 (empty -> .)
    ALIAS           reduce using rule 148 (empty -> .)
    RETURN          reduce using rule 148 (empty -> .)
    UNDEFINE        reduce using rule 148 (empty -> .)
    END             reduce using rule 148 (empty -> .)
    BEGIN           reduce using rule 148 (empty -> .)
    CONST           reduce using rule 148 (empty -> .)
    TYPE            reduce using rule 148 (empty -> .)
    VAR             reduce using rule 148 (empty -> .)

    optdecls                       shift and go to state 74
    decls                          shift and go to state 75
    empty                          shift and go to state 76

state 45

    (147) invariant -> INVARIANT optstring . expr
    (56) expr -> . expr ? expr : expr
    (57) expr -> . expr IMPLIES expr
    (58) expr -> . expr | expr
    (59) expr -> . expr & expr
    (60) expr -> . expr < expr
    (61) expr -> . expr LEQ expr
    (62) expr -> . expr > expr
    (63) expr -> . expr GEQ expr
    (64) expr -> . expr = expr
    (65) expr -> . expr NEQ expr
    (66) expr -> . expr + expr
    (67) expr -> . expr - expr
    (68) expr -> . expr * expr
    (69) expr -> . expr / expr
    (70) expr -> . expr % expr
    (71) expr -> . ! expr
    (72) expr -> . + expr
    (73) expr -> . - expr
    (74) expr -> . INTCONST
    (75) expr -> . designator
    (76) expr -> . ID actuals
    (77) expr -> . ISUNDEFINED ( designator )
    (78) expr -> . ( expr )
    (79) expr -> . FORALL quantifiers DO expr END
    (80) expr -> . EXISTS quantifiers DO expr END
    (53) designator -> . ID
    (54) designator -> . designator [ expr ]
    (55) designator -> . designator . ID

    !               shift and go to state 60
    +               shift and go to state 58
    -               shift and go to state 59
    INTCONST        shift and go to state 61
    ID              shift and go to state 63
    ISUNDEFINED     shift and go to state 64
    (               shift and go to state 65
    FORALL          shift and go to state 66
    EXISTS          shift and go to state 67

    expr                           shift and go to state 77
    designator                     shift and go to state 62

state 46

    (7) constdecls -> constdecls constdecl . ;

    ;               shift and go to state 78


state 47

    (9) constdecl -> ID . : expr

    :               shift and go to state 79


state 48

    (10) typedecls -> typedecls typedecl . ;

    ;               shift and go to state 80


state 49

    (12) typedecl -> ID . : typeexpr

    :               shift and go to state 81


state 50

    (31) vardecls -> vardecls vardecl . ;

    ;               shift and go to state 82


state 51

    (33) vardecl -> ID . vardecltail
    (34) vardecltail -> . , ID vardecltail
    (35) vardecltail -> . : typeexpr

    ,               shift and go to state 84
    :               shift and go to state 85

    vardecltail                    shift and go to state 83

state 52

    (131) rules -> rule ; rules .

    $end            reduce using rule 131 (rules -> rule ; rules .)
    END             reduce using rule 131 (rules -> rule ; rules .)


state 53

    (39) procdecl -> PROCEDURE ID ( . optformals ) ; optdecls optstmts END ;
    (41) optformals -> . formals
    (42) optformals -> . empty
    (43) formals -> . formals ; formal
    (44) formals -> . formals ;
    (45) formals -> . formal
    (148) empty -> .
    (46) formal -> . VAR formalrest
    (47) formal -> . formalrest
    (48) formalrest -> . ID formaltail

    )               reduce using rule 148 (empty -> .)
    VAR             shift and go to state 91
    ID              shift and go to state 86

    optformals                     shift and go to state 87
    formals                        shift and go to state 88
    empty                          shift and go to state 89
    formal                         shift and go to state 90
    formalrest                     shift and go to state 92

state 54

    (40) funcdecl -> FUNCTION ID ( . optformals ) : typeexpr ; optdecls optstmts END ;
    (41) optformals -> . formals
    (42) optformals -> . empty
    (43) formals -> . formals ; formal
    (44) formals -> . formals ;
    (45) formals -> . formal
    (148) empty -> .
    (46) formal -> . VAR formalrest
    (47) formal -> . formalrest
    (48) formalrest -> . ID formaltail

    )               reduce using rule 148 (empty -> .)
    VAR             shift and go to state 91
    ID              shift and go to state 86

    optformals                     shift and go to state 93
    formals                        shift and go to state 88
    empty                          shift and go to state 89
    formal                         shift and go to state 90
    formalrest                     shift and go to state 92

state 55

    (139) simplerule -> RULE optstring optcondition . optdecls optstmts END
    (51) optdecls -> . decls BEGIN
    (52) optdecls -> . empty
    (2) decls -> . decls decl
    (3) decls -> . empty
    (148) empty -> .

    IF              reduce using rule 148 (empty -> .)
    WHILE           reduce using rule 148 (empty -> .)
    SWITCH          reduce using rule 148 (empty -> .)
    FOR             reduce using rule 148 (empty -> .)
    ID              reduce using rule 148 (empty -> .)
    CLEAR           reduce using rule 148 (empty -> .)
    ERROR           reduce using rule 148 (empty -> .)
    ASSERT          reduce using rule 148 (empty -> .)
    ALIAS           reduce using rule 148 (empty -> .)
    RETURN          reduce using rule 148 (empty -> .)
    UNDEFINE        reduce using rule 148 (empty -> .)
    END             reduce using rule 148 (empty -> .)
    BEGIN           reduce using rule 148 (empty -> .)
    CONST           reduce using rule 148 (empty -> .)
    TYPE            reduce using rule 148 (empty -> .)
    VAR             reduce using rule 148 (empty -> .)

    optdecls                       shift and go to state 94
    decls                          shift and go to state 75
    empty                          shift and go to state 76

state 56

    (140) optcondition -> expr . LONGARROW
    (56) expr -> expr . ? expr : expr
    (57) expr -> expr . IMPLIES expr
    (58) expr -> expr . | expr
    (59) expr -> expr . & expr
    (60) expr -> expr . < expr
    (61) expr -> expr . LEQ expr
    (62) expr -> expr . > expr
    (63) expr -> expr . GEQ expr
    (64) expr -> expr . = expr
    (65) expr -> expr . NEQ expr
    (66) expr -> expr . + expr
    (67) expr -> expr . - expr
    (68) expr -> expr . * expr
    (69) expr -> expr . / expr
    (70) expr -> expr . % expr

    LONGARROW       shift and go to state 95
    ?               shift and go to state 96
    IMPLIES         shift and go to state 97
    |               shift and go to state 98
    &               shift and go to state 99
    <               shift and go to state 100
    LEQ             shift and go to state 101
    >               shift and go to state 102
    GEQ             shift and go to state 103
    =               shift and go to state 104
    NEQ             shift and go to state 105
    +               shift and go to state 106
    -               shift and go to state 107
    *               shift and go to state 108
    /               shift and go to state 109
    %               shift and go to state 110


state 57

    (141) optcondition -> empty .

    IF              reduce using rule 141 (optcondition -> empty .)
    WHILE           reduce using rule 141 (optcondition -> empty .)
    SWITCH          reduce using rule 141 (optcondition -> empty .)
    FOR             reduce using rule 141 (optcondition -> empty .)
    ID              reduce using rule 141 (optcondition -> empty .)
    CLEAR           reduce using rule 141 (optcondition -> empty .)
    ERROR           reduce using rule 141 (optcondition -> empty .)
    ASSERT          reduce using rule 141 (optcondition -> empty .)
    ALIAS           reduce using rule 141 (optcondition -> empty .)
    RETURN          reduce using rule 141 (optcondition -> empty .)
    UNDEFINE        reduce using rule 141 (optcondition -> empty .)
    END             reduce using rule 141 (optcondition -> empty .)
    BEGIN           reduce using rule 141 (optcondition -> empty .)
    CONST           reduce using rule 141 (optcondition -> empty .)
    TYPE            reduce using rule 141 (optcondition -> empty .)
    VAR             reduce using rule 141 (optcondition -> empty .)


state 58

    (72) expr -> + . expr
    (56) expr -> . expr ? expr : expr
    (57) expr -> . expr IMPLIES expr
    (58) expr -> . expr | expr
    (59) expr -> . expr & expr
    (60) expr -> . expr < expr
    (61) expr -> . expr LEQ expr
    (62) expr -> . expr > expr
    (63) expr -> . expr GEQ expr
    (64) expr -> . expr = expr
    (65) expr -> . expr NEQ expr
    (66) expr -> . expr + expr
    (67) expr -> . expr - expr
    (68) expr -> . expr * expr
    (69) expr -> . expr / expr
    (70) expr -> . expr % expr
    (71) expr -> . ! expr
    (72) expr -> . + expr
    (73) expr -> . - expr
    (74) expr -> . INTCONST
    (75) expr -> . designator
    (76) expr -> . ID actuals
    (77) expr -> . ISUNDEFINED ( designator )
    (78) expr -> . ( expr )
    (79) expr -> . FORALL quantifiers DO expr END
    (80) expr -> . EXISTS quantifiers DO expr END
    (53) designator -> . ID
    (54) designator -> . designator [ expr ]
    (55) designator -> . designator . ID

    !               shift and go to state 60
    +               shift and go to state 58
    -               shift and go to state 59
    INTCONST        shift and go to state 61
    ID              shift and go to state 63
    ISUNDEFINED     shift and go to state 64
    (               shift and go to state 65
    FORALL          shift and go to state 66
    EXISTS          shift and go to state 67

    expr                           shift and go to state 111
    designator                     shift and go to state 62

state 59

    (73) expr -> - . expr
    (56) expr -> . expr ? expr : expr
    (57) expr -> . expr IMPLIES expr
    (58) expr -> . expr | expr
    (59) expr -> . expr & expr
    (60) expr -> . expr < expr
    (61) expr -> . expr LEQ expr
    (62) expr -> . expr > expr
    (63) expr -> . expr GEQ expr
    (64) expr -> . expr = expr
    (65) expr -> . expr NEQ expr
    (66) expr -> . expr + expr
    (67) expr -> . expr - expr
    (68) expr -> . expr * expr
    (69) expr -> . expr / expr
    (70) expr -> . expr % expr
    (71) expr -> . ! expr
    (72) expr -> . + expr
    (73) expr -> . - expr
    (74) expr -> . INTCONST
    (75) expr -> . designator
    (76) expr -> . ID actuals
    (77) expr -> . ISUNDEFINED ( designator )
    (78) expr -> . ( expr )
    (79) expr -> . FORALL quantifiers DO expr END
    (80) expr -> . EXISTS quantifiers DO expr END
    (53) designator -> . ID
    (54) designator -> . designator [ expr ]
    (55) designator -> . designator . ID

    !               shift and go to state 60
    +               shift and go to state 58
    -               shift and go to state 59
    INTCONST        shift and go to state 61
    ID              shift and go to state 63
    ISUNDEFINED     shift and go to state 64
    (               shift and go to state 65
    FORALL          shift and go to state 66
    EXISTS          shift and go to state 67

    expr                           shift and go to state 112
    designator                     shift and go to state 62

state 60

    (71) expr -> ! . expr
    (56) expr -> . expr ? expr : expr
    (57) expr -> . expr IMPLIES expr
    (58) expr -> . expr | expr
    (59) expr -> . expr & expr
    (60) expr -> . expr < expr
    (61) expr -> . expr LEQ expr
    (62) expr -> . expr > expr
    (63) expr -> . expr GEQ expr
    (64) expr -> . expr = expr
    (65) expr -> . expr NEQ expr
    (66) expr -> . expr + expr
    (67) expr -> . expr - expr
    (68) expr -> . expr * expr
    (69) expr -> . expr / expr
    (70) expr -> . expr % expr
    (71) expr -> . ! expr
    (72) expr -> . + expr
    (73) expr -> . - expr
    (74) expr -> . INTCONST
    (75) expr -> . designator
    (76) expr -> . ID actuals
    (77) expr -> . ISUNDEFINED ( designator )
    (78) expr -> . ( expr )
    (79) expr -> . FORALL quantifiers DO expr END
    (80) expr -> . EXISTS quantifiers DO expr END
    (53) designator -> . ID
    (54) designator -> . designator [ expr ]
    (55) designator -> . designator . ID

    !               shift and go to state 60
    +               shift and go to state 58
    -               shift and go to state 59
    INTCONST        shift and go to state 61
    ID              shift and go to state 63
    ISUNDEFINED     shift and go to state 64
    (               shift and go to state 65
    FORALL          shift and go to state 66
    EXISTS          shift and go to state 67

    expr                           shift and go to state 113
    designator                     shift and go to state 62

state 61

    (74) expr -> INTCONST .

    LONGARROW       reduce using rule 74 (expr -> INTCONST .)
    ?               reduce using rule 74 (expr -> INTCONST .)
    IMPLIES         reduce using rule 74 (expr -> INTCONST .)
    |               reduce using rule 74 (expr -> INTCONST .)
    &               reduce using rule 74 (expr -> INTCONST .)
    <               reduce using rule 74 (expr -> INTCONST .)
    LEQ             reduce using rule 74 (expr -> INTCONST .)
    >               reduce using rule 74 (expr -> INTCONST .)
    GEQ             reduce using rule 74 (expr -> INTCONST .)
    =               reduce using rule 74 (expr -> INTCONST .)
    NEQ             reduce using rule 74 (expr -> INTCONST .)
    +               reduce using rule 74 (expr -> INTCONST .)
    -               reduce using rule 74 (expr -> INTCONST .)
    *               reduce using rule 74 (expr -> INTCONST .)
    /               reduce using rule 74 (expr -> INTCONST .)
    %               reduce using rule 74 (expr -> INTCONST .)
    ;               reduce using rule 74 (expr -> INTCONST .)
    $end            reduce using rule 74 (expr -> INTCONST .)
    END             reduce using rule 74 (expr -> INTCONST .)
    )               reduce using rule 74 (expr -> INTCONST .)
    DO              reduce using rule 74 (expr -> INTCONST .)
    DOTDOT          reduce using rule 74 (expr -> INTCONST .)
    :               reduce using rule 74 (expr -> INTCONST .)
    ]               reduce using rule 74 (expr -> INTCONST .)
    ,               reduce using rule 74 (expr -> INTCONST .)
    THEN            reduce using rule 74 (expr -> INTCONST .)
    ELSE            reduce using rule 74 (expr -> INTCONST .)
    CASE            reduce using rule 74 (expr -> INTCONST .)
    STRING          reduce using rule 74 (expr -> INTCONST .)
    ELSIF           reduce using rule 74 (expr -> INTCONST .)


state 62

    (75) expr -> designator .
    (54) designator -> designator . [ expr ]
    (55) designator -> designator . . ID

    LONGARROW       reduce using rule 75 (expr -> designator .)
    ?               reduce using rule 75 (expr -> designator .)
    IMPLIES         reduce using rule 75 (expr -> designator .)
    |               reduce using rule 75 (expr -> designator .)
    &               reduce using rule 75 (expr -> designator .)
    <               reduce using rule 75 (expr -> designator .)
    LEQ             reduce using rule 75 (expr -> designator .)
    >               reduce using rule 75 (expr -> designator .)
    GEQ             reduce using rule 75 (expr -> designator .)
    =               reduce using rule 75 (expr -> designator .)
    NEQ             reduce using rule 75 (expr -> designator .)
    +               reduce using rule 75 (expr -> designator .)
    -               reduce using rule 75 (expr -> designator .)
    *               reduce using rule 75 (expr -> designator .)
    /               reduce using rule 75 (expr -> designator .)
    %               reduce using rule 75 (expr -> designator .)
    ;               reduce using rule 75 (expr -> designator .)
    $end            reduce using rule 75 (expr -> designator .)
    END             reduce using rule 75 (expr -> designator .)
    )               reduce using rule 75 (expr -> designator .)
    DO              reduce using rule 75 (expr -> designator .)
    DOTDOT          reduce using rule 75 (expr -> designator .)
    :               reduce using rule 75 (expr -> designator .)
    ]               reduce using rule 75 (expr -> designator .)
    ,               reduce using rule 75 (expr -> designator .)
    THEN            reduce using rule 75 (expr -> designator .)
    ELSE            reduce using rule 75 (expr -> designator .)
    CASE            reduce using rule 75 (expr -> designator .)
    STRING          reduce using rule 75 (expr -> designator .)
    ELSIF           reduce using rule 75 (expr -> designator .)
    [               shift and go to state 114
    .               shift and go to state 115


state 63

    (76) expr -> ID . actuals
    (53) designator -> ID .
    (81) actuals -> . ( exprlist )
    (82) actuals -> . ( )

    [               reduce using rule 53 (designator -> ID .)
    .               reduce using rule 53 (designator -> ID .)
    LONGARROW       reduce using rule 53 (designator -> ID .)
    ?               reduce using rule 53 (designator -> ID .)
    IMPLIES         reduce using rule 53 (designator -> ID .)
    |               reduce using rule 53 (designator -> ID .)
    &               reduce using rule 53 (designator -> ID .)
    <               reduce using rule 53 (designator -> ID .)
    LEQ             reduce using rule 53 (designator -> ID .)
    >               reduce using rule 53 (designator -> ID .)
    GEQ             reduce using rule 53 (designator -> ID .)
    =               reduce using rule 53 (designator -> ID .)
    NEQ             reduce using rule 53 (designator -> ID .)
    +               reduce using rule 53 (designator -> ID .)
    -               reduce using rule 53 (designator -> ID .)
    *               reduce using rule 53 (designator -> ID .)
    /               reduce using rule 53 (designator -> ID .)
    %               reduce using rule 53 (designator -> ID .)
    ;               reduce using rule 53 (designator -> ID .)
    $end            reduce using rule 53 (designator -> ID .)
    END             reduce using rule 53 (designator -> ID .)
    )               reduce using rule 53 (designator -> ID .)
    DO              reduce using rule 53 (designator -> ID .)
    DOTDOT          reduce using rule 53 (designator -> ID .)
    :               reduce using rule 53 (designator -> ID .)
    ]               reduce using rule 53 (designator -> ID .)
    ,               reduce using rule 53 (designator -> ID .)
    THEN            reduce using rule 53 (designator -> ID .)
    ELSE            reduce using rule 53 (designator -> ID .)
    CASE            reduce using rule 53 (designator -> ID .)
    STRING          reduce using rule 53 (designator -> ID .)
    ELSIF           reduce using rule 53 (designator -> ID .)
    (               shift and go to state 117

    actuals                        shift and go to state 116

state 64

    (77) expr -> ISUNDEFINED . ( designator )

    (               shift and go to state 118


state 65

    (78) expr -> ( . expr )
    (56) expr -> . expr ? expr : expr
    (57) expr -> . expr IMPLIES expr
    (58) expr -> . expr | expr
    (59) expr -> . expr & expr
    (60) expr -> . expr < expr
    (61) expr -> . expr LEQ expr
    (62) expr -> . expr > expr
    (63) expr -> . expr GEQ expr
    (64) expr -> . expr = expr
    (65) expr -> . expr NEQ expr
    (66) expr -> . expr + expr
    (67) expr -> . expr - expr
    (68) expr -> . expr * expr
    (69) expr -> . expr / expr
    (70) expr -> . expr % expr
    (71) expr -> . ! expr
    (72) expr -> . + expr
    (73) expr -> . - expr
    (74) expr -> . INTCONST
    (75) expr -> . designator
    (76) expr -> . ID actuals
    (77) expr -> . ISUNDEFINED ( designator )
    (78) expr -> . ( expr )
    (79) expr -> . FORALL quantifiers DO expr END
    (80) expr -> . EXISTS quantifiers DO expr END
    (53) designator -> . ID
    (54) designator -> . designator [ expr ]
    (55) designator -> . designator . ID

    !               shift and go to state 60
    +               shift and go to state 58
    -               shift and go to state 59
    INTCONST        shift and go to state 61
    ID              shift and go to state 63
    ISUNDEFINED     shift and go to state 64
    (               shift and go to state 65
    FORALL          shift and go to state 66
    EXISTS          shift and go to state 67

    expr                           shift and go to state 119
    designator                     shift and go to state 62

state 66

    (79) expr -> FORALL . quantifiers DO expr END
    (86) quantifiers -> . quantifier ; quantifiers
    (87) quantifiers -> . quantifier
    (85) quantifier -> . ID : typeexpr

    ID              shift and go to state 43

    quantifiers                    shift and go to state 120
    quantifier                     shift and go to state 42

state 67

    (80) expr -> EXISTS . quantifiers DO expr END
    (86) quantifiers -> . quantifier ; quantifiers
    (87) quantifiers -> . quantifier
    (85) quantifier -> . ID : typeexpr

    ID              shift and go to state 43

    quantifiers                    shift and go to state 121
    quantifier                     shift and go to state 42

state 68

    (144) aliasrule -> ALIAS aliases DO . rules END
    (131) rules -> . rule ; rules
    (132) rules -> . rule ;
    (133) rules -> . rule
    (134) rule -> . simplerule
    (135) rule -> . aliasrule
    (136) rule -> . ruleset
    (137) rule -> . startstate
    (138) rule -> . invariant
    (139) simplerule -> . RULE optstring optcondition optdecls optstmts END
    (144) aliasrule -> . ALIAS aliases DO rules END
    (145) ruleset -> . RULESET quantifiers DO rules END
    (146) startstate -> . STARTSTATE optstring optdecls optstmts END
    (147) invariant -> . INVARIANT optstring expr

    RULE            shift and go to state 21
    ALIAS           shift and go to state 22
    RULESET         shift and go to state 23
    STARTSTATE      shift and go to state 24
    INVARIANT       shift and go to state 25

    rules                          shift and go to state 122
    rule                           shift and go to state 13
    simplerule                     shift and go to state 16
    aliasrule                      shift and go to state 17
    ruleset                        shift and go to state 18
    startstate                     shift and go to state 19
    invariant                      shift and go to state 20

state 69

    (124) aliases -> aliases ; . alias
    (125) aliases -> aliases ; .
    (127) alias -> . ID : expr

    DO              reduce using rule 125 (aliases -> aliases ; .)
    ;               reduce using rule 125 (aliases -> aliases ; .)
    ID              shift and go to state 40

    alias                          shift and go to state 123

state 70

    (127) alias -> ID : . expr
    (56) expr -> . expr ? expr : expr
    (57) expr -> . expr IMPLIES expr
    (58) expr -> . expr | expr
    (59) expr -> . expr & expr
    (60) expr -> . expr < expr
    (61) expr -> . expr LEQ expr
    (62) expr -> . expr > expr
    (63) expr -> . expr GEQ expr
    (64) expr -> . expr = expr
    (65) expr -> . expr NEQ expr
    (66) expr -> . expr + expr
    (67) expr -> . expr - expr
    (68) expr -> . expr * expr
    (69) expr -> . expr / expr
    (70) expr -> . expr % expr
    (71) expr -> . ! expr
    (72) expr -> . + expr
    (73) expr -> . - expr
    (74) expr -> . INTCONST
    (75) expr -> . designator
    (76) expr -> . ID actuals
    (77) expr -> . ISUNDEFINED ( designator )
    (78) expr -> . ( expr )
    (79) expr -> . FORALL quantifiers DO expr END
    (80) expr -> . EXISTS quantifiers DO expr END
    (53) designator -> . ID
    (54) designator -> . designator [ expr ]
    (55) designator -> . designator . ID

    !               shift and go to state 60
    +               shift and go to state 58
    -               shift and go to state 59
    INTCONST        shift and go to state 61
    ID              shift and go to state 63
    ISUNDEFINED     shift and go to state 64
    (               shift and go to state 65
    FORALL          shift and go to state 66
    EXISTS          shift and go to state 67

    expr                           shift and go to state 124
    designator                     shift and go to state 62

state 71

    (145) ruleset -> RULESET quantifiers DO . rules END
    (131) rules -> . rule ; rules
    (132) rules -> . rule ;
    (133) rules -> . rule
    (134) rule -> . simplerule
    (135) rule -> . aliasrule
    (136) rule -> . ruleset
    (137) rule -> . startstate
    (138) rule -> . invariant
    (139) simplerule -> . RULE optstring optcondition optdecls optstmts END
    (144) aliasrule -> . ALIAS aliases DO rules END
    (145) ruleset -> . RULESET quantifiers DO rules END
    (146) startstate -> . STARTSTATE optstring optdecls optstmts END
    (147) invariant -> . INVARIANT optstring expr

    RULE            shift and go to state 21
    ALIAS           shift and go to state 22
    RULESET         shift and go to state 23
    STARTSTATE      shift and go to state 24
    INVARIANT       shift and go to state 25

    rules                          shift and go to state 125
    rule                           shift and go to state 13
    simplerule                     shift and go to state 16
    aliasrule                      shift and go to state 17
    ruleset                        shift and go to state 18
    startstate                     shift and go to state 19
    invariant                      shift and go to state 20

state 72

    (86) quantifiers -> quantifier ; . quantifiers
    (86) quantifiers -> . quantifier ; quantifiers
    (87) quantifiers -> . quantifier
    (85) quantifier -> . ID : typeexpr

    ID              shift and go to state 43

    quantifier                     shift and go to state 42
    quantifiers                    shift and go to state 126

state 73

    (85) quantifier -> ID : . typeexpr
    (13) typeexpr -> . typeid
    (14) typeexpr -> . enumtype
    (15) typeexpr -> . subrangetype
    (16) typeexpr -> . recordtype
    (17) typeexpr -> . arraytype
    (18) typeid -> . ID
    (19) enumtype -> . ENUM { enums }
    (22) subrangetype -> . expr DOTDOT expr
    (23) recordtype -> . RECORD fields END
    (30) arraytype -> . ARRAY [ typeexpr ] OF typeexpr
    (56) expr -> . expr ? expr : expr
    (57) expr -> . expr IMPLIES expr
    (58) expr -> . expr | expr
    (59) expr -> . expr & expr
    (60) expr -> . expr < expr
    (61) expr -> . expr LEQ expr
    (62) expr -> . expr > expr
    (63) expr -> . expr GEQ expr
    (64) expr -> . expr = expr
    (65) expr -> . expr NEQ expr
    (66) expr -> . expr + expr
    (67) expr -> . expr - expr
    (68) expr -> . expr * expr
    (69) expr -> . expr / expr
    (70) expr -> . expr % expr
    (71) expr -> . ! expr
    (72) expr -> . + expr
    (73) expr -> . - expr
    (74) expr -> . INTCONST
    (75) expr -> . designator
    (76) expr -> . ID actuals
    (77) expr -> . ISUNDEFINED ( designator )
    (78) expr -> . ( expr )
    (79) expr -> . FORALL quantifiers DO expr END
    (80) expr -> . EXISTS quantifiers DO expr END
    (53) designator -> . ID
    (54) designator -> . designator [ expr ]
    (55) designator -> . designator . ID

    ID              shift and go to state 127
    ENUM            shift and go to state 134
    RECORD          shift and go to state 136
    ARRAY           shift and go to state 137
    !               shift and go to state 60
    +               shift and go to state 58
    -               shift and go to state 59
    INTCONST        shift and go to state 61
    ISUNDEFINED     shift and go to state 64
    (               shift and go to state 65
    FORALL          shift and go to state 66
    EXISTS          shift and go to state 67

    typeexpr                       shift and go to state 128
    typeid                         shift and go to state 129
    enumtype                       shift and go to state 130
    subrangetype                   shift and go to state 131
    recordtype                     shift and go to state 132
    arraytype                      shift and go to state 133
    expr                           shift and go to state 135
    designator                     shift and go to state 62

state 74

    (146) startstate -> STARTSTATE optstring optdecls . optstmts END
    (88) optstmts -> . stmts
    (89) optstmts -> . empty
    (90) stmts -> . stmts ; stmt
    (91) stmts -> . stmts ;
    (92) stmts -> . stmt
    (148) empty -> .
    (93) stmt -> . assignment
    (94) stmt -> . ifstmt
    (95) stmt -> . whilestmt
    (96) stmt -> . switchstmt
    (97) stmt -> . forstmt
    (98) stmt -> . proccall
    (99) stmt -> . clearstmt
    (100) stmt -> . errorstmt
    (101) stmt -> . assertstmt
    (102) stmt -> . aliasstmt
    (103) stmt -> . returnstmt
    (104) stmt -> . undefinestmt
    (105) assignment -> . designator ASSIGN expr
    (106) ifstmt -> . IF expr THEN optstmts optelses END
    (112) whilestmt -> . WHILE expr DO optstmts END
    (113) switchstmt -> . SWITCH expr optcases optelse END
    (117) forstmt -> . FOR quantifiers DO optstmts END
    (118) proccall -> . ID actuals
    (119) clearstmt -> . CLEAR designator
    (121) errorstmt -> . ERROR STRING
    (122) assertstmt -> . ASSERT expr optstring
    (123) aliasstmt -> . ALIAS aliases DO optstmts END
    (128) returnstmt -> . RETURN optretexpr
    (120) undefinestmt -> . UNDEFINE designator
    (53) designator -> . ID
    (54) designator -> . designator [ expr ]
    (55) designator -> . designator . ID

    END             reduce using rule 148 (empty -> .)
    IF              shift and go to state 155
    WHILE           shift and go to state 156
    SWITCH          shift and go to state 157
    FOR             shift and go to state 158
    ID              shift and go to state 159
    CLEAR           shift and go to state 160
    ERROR           shift and go to state 161
    ASSERT          shift and go to state 162
    ALIAS           shift and go to state 163
    RETURN          shift and go to state 164
    UNDEFINE        shift and go to state 165

    optstmts                       shift and go to state 138
    stmts                          shift and go to state 139
    empty                          shift and go to state 140
    stmt                           shift and go to state 141
    assignment                     shift and go to state 142
    ifstmt                         shift and go to state 143
    whilestmt                      shift and go to state 144
    switchstmt                     shift and go to state 145
    forstmt                        shift and go to state 146
    proccall                       shift and go to state 147
    clearstmt                      shift and go to state 148
    errorstmt                      shift and go to state 149
    assertstmt                     shift and go to state 150
    aliasstmt                      shift and go to state 151
    returnstmt                     shift and go to state 152
    undefinestmt                   shift and go to state 153
    designator                     shift and go to state 154

state 75

    (51) optdecls -> decls . BEGIN
    (2) decls -> decls . decl
    (4) decl -> . CONST constdecls
    (5) decl -> . TYPE typedecls
    (6) decl -> . VAR vardecls

    BEGIN           shift and go to state 166
    CONST           shift and go to state 7
    TYPE            shift and go to state 8
    VAR             shift and go to state 9

    decl                           shift and go to state 5

state 76

    (52) optdecls -> empty .
    (3) decls -> empty .

    IF              reduce using rule 52 (optdecls -> empty .)
    WHILE           reduce using rule 52 (optdecls -> empty .)
    SWITCH          reduce using rule 52 (optdecls -> empty .)
    FOR             reduce using rule 52 (optdecls -> empty .)
    ID              reduce using rule 52 (optdecls -> empty .)
    CLEAR           reduce using rule 52 (optdecls -> empty .)
    ERROR           reduce using rule 52 (optdecls -> empty .)
    ASSERT          reduce using rule 52 (optdecls -> empty .)
    ALIAS           reduce using rule 52 (optdecls -> empty .)
    RETURN          reduce using rule 52 (optdecls -> empty .)
    UNDEFINE        reduce using rule 52 (optdecls -> empty .)
    END             reduce using rule 52 (optdecls -> empty .)
    BEGIN           reduce using rule 3 (decls -> empty .)
    CONST           reduce using rule 3 (decls -> empty .)
    TYPE            reduce using rule 3 (decls -> empty .)
    VAR             reduce using rule 3 (decls -> empty .)


state 77

    (147) invariant -> INVARIANT optstring expr .
    (56) expr -> expr . ? expr : expr
    (57) expr -> expr . IMPLIES expr
    (58) expr -> expr . | expr
    (59) expr -> expr . & expr
    (60) expr -> expr . < expr
    (61) expr -> expr . LEQ expr
    (62) expr -> expr . > expr
    (63) expr -> expr . GEQ expr
    (64) expr -> expr . = expr
    (65) expr -> expr . NEQ expr
    (66) expr -> expr . + expr
    (67) expr -> expr . - expr
    (68) expr -> expr . * expr
    (69) expr -> expr . / expr
    (70) expr -> expr . % expr

    ;               reduce using rule 147 (invariant -> INVARIANT optstring expr .)
    $end            reduce using rule 147 (invariant -> INVARIANT optstring expr .)
    END             reduce using rule 147 (invariant -> INVARIANT optstring expr .)
    ?               shift and go to state 96
    IMPLIES         shift and go to state 97
    |               shift and go to state 98
    &               shift and go to state 99
    <               shift and go to state 100
    LEQ             shift and go to state 101
    >               shift and go to state 102
    GEQ             shift and go to state 103
    =               shift and go to state 104
    NEQ             shift and go to state 105
    +               shift and go to state 106
    -               shift and go to state 107
    *               shift and go to state 108
    /               shift and go to state 109
    %               shift and go to state 110


state 78

    (7) constdecls -> constdecls constdecl ; .

    ID              reduce using rule 7 (constdecls -> constdecls constdecl ; .)
    CONST           reduce using rule 7 (constdecls -> constdecls constdecl ; .)
    TYPE            reduce using rule 7 (constdecls -> constdecls constdecl ; .)
    VAR             reduce using rule 7 (constdecls -> constdecls constdecl ; .)
    PROCEDURE       reduce using rule 7 (constdecls -> constdecls constdecl ; .)
    FUNCTION        reduce using rule 7 (constdecls -> constdecls constdecl ; .)
    RULE            reduce using rule 7 (constdecls -> constdecls constdecl ; .)
    ALIAS           reduce using rule 7 (constdecls -> constdecls constdecl ; .)
    RULESET         reduce using rule 7 (constdecls -> constdecls constdecl ; .)
    STARTSTATE      reduce using rule 7 (constdecls -> constdecls constdecl ; .)
    INVARIANT       reduce using rule 7 (constdecls -> constdecls constdecl ; .)
    BEGIN           reduce using rule 7 (constdecls -> constdecls constdecl ; .)


state 79

    (9) constdecl -> ID : . expr
    (56) expr -> . expr ? expr : expr
    (57) expr -> . expr IMPLIES expr
    (58) expr -> . expr | expr
    (59) expr -> . expr & expr
    (60) expr -> . expr < expr
    (61) expr -> . expr LEQ expr
    (62) expr -> . expr > expr
    (63) expr -> . expr GEQ expr
    (64) expr -> . expr = expr
    (65) expr -> . expr NEQ expr
    (66) expr -> . expr + expr
    (67) expr -> . expr - expr
    (68) expr -> . expr * expr
    (69) expr -> . expr / expr
    (70) expr -> . expr % expr
    (71) expr -> . ! expr
    (72) expr -> . + expr
    (73) expr -> . - expr
    (74) expr -> . INTCONST
    (75) expr -> . designator
    (76) expr -> . ID actuals
    (77) expr -> . ISUNDEFINED ( designator )
    (78) expr -> . ( expr )
    (79) expr -> . FORALL quantifiers DO expr END
    (80) expr -> . EXISTS quantifiers DO expr END
    (53) designator -> . ID
    (54) designator -> . designator [ expr ]
    (55) designator -> . designator . ID

    !               shift and go to state 60
    +               shift and go to state 58
    -               shift and go to state 59
    INTCONST        shift and go to state 61
    ID              shift and go to state 63
    ISUNDEFINED     shift and go to state 64
    (               shift and go to state 65
    FORALL          shift and go to state 66
    EXISTS          shift and go to state 67

    expr                           shift and go to state 167
    designator                     shift and go to state 62

state 80

    (10) typedecls -> typedecls typedecl ; .

    ID              reduce using rule 10 (typedecls -> typedecls typedecl ; .)
    CONST           reduce using rule 10 (typedecls -> typedecls typedecl ; .)
    TYPE            reduce using rule 10 (typedecls -> typedecls typedecl ; .)
    VAR             reduce using rule 10 (typedecls -> typedecls typedecl ; .)
    PROCEDURE       reduce using rule 10 (typedecls -> typedecls typedecl ; .)
    FUNCTION        reduce using rule 10 (typedecls -> typedecls typedecl ; .)
    RULE            reduce using rule 10 (typedecls -> typedecls typedecl ; .)
    ALIAS           reduce using rule 10 (typedecls -> typedecls typedecl ; .)
    RULESET         reduce using rule 10 (typedecls -> typedecls typedecl ; .)
    STARTSTATE      reduce using rule 10 (typedecls -> typedecls typedecl ; .)
    INVARIANT       reduce using rule 10 (typedecls -> typedecls typedecl ; .)
    BEGIN           reduce using rule 10 (typedecls -> typedecls typedecl ; .)


state 81

    (12) typedecl -> ID : . typeexpr
    (13) typeexpr -> . typeid
    (14) typeexpr -> . enumtype
    (15) typeexpr -> . subrangetype
    (16) typeexpr -> . recordtype
    (17) typeexpr -> . arraytype
    (18) typeid -> . ID
    (19) enumtype -> . ENUM { enums }
    (22) subrangetype -> . expr DOTDOT expr
    (23) recordtype -> . RECORD fields END
    (30) arraytype -> . ARRAY [ typeexpr ] OF typeexpr
    (56) expr -> . expr ? expr : expr
    (57) expr -> . expr IMPLIES expr
    (58) expr -> . expr | expr
    (59) expr -> . expr & expr
    (60) expr -> . expr < expr
    (61) expr -> . expr LEQ expr
    (62) expr -> . expr > expr
    (63) expr -> . expr GEQ expr
    (64) expr -> . expr = expr
    (65) expr -> . expr NEQ expr
    (66) expr -> . expr + expr
    (67) expr -> . expr - expr
    (68) expr -> . expr * expr
    (69) expr -> . expr / expr
    (70) expr -> . expr % expr
    (71) expr -> . ! expr
    (72) expr -> . + expr
    (73) expr -> . - expr
    (74) expr -> . INTCONST
    (75) expr -> . designator
    (76) expr -> . ID actuals
    (77) expr -> . ISUNDEFINED ( designator )
    (78) expr -> . ( expr )
    (79) expr -> . FORALL quantifiers DO expr END
    (80) expr -> . EXISTS quantifiers DO expr END
    (53) designator -> . ID
    (54) designator -> . designator [ expr ]
    (55) designator -> . designator . ID

    ID              shift and go to state 127
    ENUM            shift and go to state 134
    RECORD          shift and go to state 136
    ARRAY           shift and go to state 137
    !               shift and go to state 60
    +               shift and go to state 58
    -               shift and go to state 59
    INTCONST        shift and go to state 61
    ISUNDEFINED     shift and go to state 64
    (               shift and go to state 65
    FORALL          shift and go to state 66
    EXISTS          shift and go to state 67

    typeexpr                       shift and go to state 168
    typeid                         shift and go to state 129
    enumtype                       shift and go to state 130
    subrangetype                   shift and go to state 131
    recordtype                     shift and go to state 132
    arraytype                      shift and go to state 133
    expr                           shift and go to state 135
    designator                     shift and go to state 62

state 82

    (31) vardecls -> vardecls vardecl ; .

    ID              reduce using rule 31 (vardecls -> vardecls vardecl ; .)
    CONST           reduce using rule 31 (vardecls -> vardecls vardecl ; .)
    TYPE            reduce using rule 31 (vardecls -> vardecls vardecl ; .)
    VAR             reduce using rule 31 (vardecls -> vardecls vardecl ; .)
    PROCEDURE       reduce using rule 31 (vardecls -> vardecls vardecl ; .)
    FUNCTION        reduce using rule 31 (vardecls -> vardecls vardecl ; .)
    RULE            reduce using rule 31 (vardecls -> vardecls vardecl ; .)
    ALIAS           reduce using rule 31 (vardecls -> vardecls vardecl ; .)
    RULESET         reduce using rule 31 (vardecls -> vardecls vardecl ; .)
    STARTSTATE      reduce using rule 31 (vardecls -> vardecls vardecl ; .)
    INVARIANT       reduce using rule 31 (vardecls -> vardecls vardecl ; .)
    BEGIN           reduce using rule 31 (vardecls -> vardecls vardecl ; .)


state 83

    (33) vardecl -> ID vardecltail .

    ;               reduce using rule 33 (vardecl -> ID vardecltail .)


state 84

    (34) vardecltail -> , . ID vardecltail

    ID              shift and go to state 169


state 85

    (35) vardecltail -> : . typeexpr
    (13) typeexpr -> . typeid
    (14) typeexpr -> . enumtype
    (15) typeexpr -> . subrangetype
    (16) typeexpr -> . recordtype
    (17) typeexpr -> . arraytype
    (18) typeid -> . ID
    (19) enumtype -> . ENUM { enums }
    (22) subrangetype -> . expr DOTDOT expr
    (23) recordtype -> . RECORD fields END
    (30) arraytype -> . ARRAY [ typeexpr ] OF typeexpr
    (56) expr -> . expr ? expr : expr
    (57) expr -> . expr IMPLIES expr
    (58) expr -> . expr | expr
    (59) expr -> . expr & expr
    (60) expr -> . expr < expr
    (61) expr -> . expr LEQ expr
    (62) expr -> . expr > expr
    (63) expr -> . expr GEQ expr
    (64) expr -> . expr = expr
    (65) expr -> . expr NEQ expr
    (66) expr -> . expr + expr
    (67) expr -> . expr - expr
    (68) expr -> . expr * expr
    (69) expr -> . expr / expr
    (70) expr -> . expr % expr
    (71) expr -> . ! expr
    (72) expr -> . + expr
    (73) expr -> . - expr
    (74) expr -> . INTCONST
    (75) expr -> . designator
    (76) expr -> . ID actuals
    (77) expr -> . ISUNDEFINED ( designator )
    (78) expr -> . ( expr )
    (79) expr -> . FORALL quantifiers DO expr END
    (80) expr -> . EXISTS quantifiers DO expr END
    (53) designator -> . ID
    (54) designator -> . designator [ expr ]
    (55) designator -> . designator . ID

    ID              shift and go to state 127
    ENUM            shift and go to state 134
    RECORD          shift and go to state 136
    ARRAY           shift and go to state 137
    !               shift and go to state 60
    +               shift and go to state 58
    -               shift and go to state 59
    INTCONST        shift and go to state 61
    ISUNDEFINED     shift and go to state 64
    (               shift and go to state 65
    FORALL          shift and go to state 66
    EXISTS          shift and go to state 67

    typeexpr                       shift and go to state 170
    typeid                         shift and go to state 129
    enumtype                       shift and go to state 130
    subrangetype                   shift and go to state 131
    recordtype                     shift and go to state 132
    arraytype                      shift and go to state 133
    expr                           shift and go to state 135
    designator                     shift and go to state 62

state 86

    (48) formalrest -> ID . formaltail
    (49) formaltail -> . , ID formaltail
    (50) formaltail -> . : typeexpr

    ,               shift and go to state 172
    :               shift and go to state 173

    formaltail                     shift and go to state 171

state 87

    (39) procdecl -> PROCEDURE ID ( optformals . ) ; optdecls optstmts END ;

    )               shift and go to state 174


state 88

    (41) optformals -> formals .
    (43) formals -> formals . ; formal
    (44) formals -> formals . ;

    )               reduce using rule 41 (optformals -> formals .)
    ;               shift and go to state 175


state 89

    (42) optformals -> empty .

    )               reduce using rule 42 (optformals -> empty .)


state 90

    (45) formals -> formal .

    ;               reduce using rule 45 (formals -> formal .)
    )               reduce using rule 45 (formals -> formal .)


state 91

    (46) formal -> VAR . formalrest
    (48) formalrest -> . ID formaltail

    ID              shift and go to state 86

    formalrest                     shift and go to state 176

state 92

    (47) formal -> formalrest .

    ;               reduce using rule 47 (formal -> formalrest .)
    )               reduce using rule 47 (formal -> formalrest .)


state 93

    (40) funcdecl -> FUNCTION ID ( optformals . ) : typeexpr ; optdecls optstmts END ;

    )               shift and go to state 177


state 94

    (139) simplerule -> RULE optstring optcondition optdecls . optstmts END
    (88) optstmts -> . stmts
    (89) optstmts -> . empty
    (90) stmts -> . stmts ; stmt
    (91) stmts -> . stmts ;
    (92) stmts -> . stmt
    (148) empty -> .
    (93) stmt -> . assignment
    (94) stmt -> . ifstmt
    (95) stmt -> . whilestmt
    (96) stmt -> . switchstmt
    (97) stmt -> . forstmt
    (98) stmt -> . proccall
    (99) stmt -> . clearstmt
    (100) stmt -> . errorstmt
    (101) stmt -> . assertstmt
    (102) stmt -> . aliasstmt
    (103) stmt -> . returnstmt
    (104) stmt -> . undefinestmt
    (105) assignment -> . designator ASSIGN expr
    (106) ifstmt -> . IF expr THEN optstmts optelses END
    (112) whilestmt -> . WHILE expr DO optstmts END
    (113) switchstmt -> . SWITCH expr optcases optelse END
    (117) forstmt -> . FOR quantifiers DO optstmts END
    (118) proccall -> . ID actuals
    (119) clearstmt -> . CLEAR designator
    (121) errorstmt -> . ERROR STRING
    (122) assertstmt -> . ASSERT expr optstring
    (123) aliasstmt -> . ALIAS aliases DO optstmts END
    (128) returnstmt -> . RETURN optretexpr
    (120) undefinestmt -> . UNDEFINE designator
    (53) designator -> . ID
    (54) designator -> . designator [ expr ]
    (55) designator -> . designator . ID

    END             reduce using rule 148 (empty -> .)
    IF              shift and go to state 155
    WHILE           shift and go to state 156
    SWITCH          shift and go to state 157
    FOR             shift and go to state 158
    ID              shift and go to state 159
    CLEAR           shift and go to state 160
    ERROR           shift and go to state 161
    ASSERT          shift and go to state 162
    ALIAS           shift and go to state 163
    RETURN          shift and go to state 164
    UNDEFINE        shift and go to state 165

    optstmts                       shift and go to state 178
    stmts                          shift and go to state 139
    empty                          shift and go to state 140
    stmt                           shift and go to state 141
    assignment                     shift and go to state 142
    ifstmt                         shift and go to state 143
    whilestmt                      shift and go to state 144
    switchstmt                     shift and go to state 145
    forstmt                        shift and go to state 146
    proccall                       shift and go to state 147
    clearstmt                      shift and go to state 148
    errorstmt                      shift and go to state 149
    assertstmt                     shift and go to state 150
    aliasstmt                      shift and go to state 151
    returnstmt                     shift and go to state 152
    undefinestmt                   shift and go to state 153
    designator                     shift and go to state 154

state 95

    (140) optcondition -> expr LONGARROW .

    IF              reduce using rule 140 (optcondition -> expr LONGARROW .)
    WHILE           reduce using rule 140 (optcondition -> expr LONGARROW .)
    SWITCH          reduce using rule 140 (optcondition -> expr LONGARROW .)
    FOR             reduce using rule 140 (optcondition -> expr LONGARROW .)
    ID              reduce using rule 140 (optcondition -> expr LONGARROW .)
    CLEAR           reduce using rule 140 (optcondition -> expr LONGARROW .)
    ERROR           reduce using rule 140 (optcondition -> expr LONGARROW .)
    ASSERT          reduce using rule 140 (optcondition -> expr LONGARROW .)
    ALIAS           reduce using rule 140 (optcondition -> expr LONGARROW .)
    RETURN          reduce using rule 140 (optcondition -> expr LONGARROW .)
    UNDEFINE        reduce using rule 140 (optcondition -> expr LONGARROW .)
    END             reduce using rule 140 (optcondition -> expr LONGARROW .)
    BEGIN           reduce using rule 140 (optcondition -> expr LONGARROW .)
    CONST           reduce using rule 140 (optcondition -> expr LONGARROW .)
    TYPE            reduce using rule 140 (optcondition -> expr LONGARROW .)
    VAR             reduce using rule 140 (optcondition -> expr LONGARROW .)


state 96

    (56) expr -> expr ? . expr : expr
    (56) expr -> . expr ? expr : expr
    (57) expr -> . expr IMPLIES expr
    (58) expr -> . expr | expr
    (59) expr -> . expr & expr
    (60) expr -> . expr < expr
    (61) expr -> . expr LEQ expr
    (62) expr -> . expr > expr
    (63) expr -> . expr GEQ expr
    (64) expr -> . expr = expr
    (65) expr -> . expr NEQ expr
    (66) expr -> . expr + expr
    (67) expr -> . expr - expr
    (68) expr -> . expr * expr
    (69) expr -> . expr / expr
    (70) expr -> . expr % expr
    (71) expr -> . ! expr
    (72) expr -> . + expr
    (73) expr -> . - expr
    (74) expr -> . INTCONST
    (75) expr -> . designator
    (76) expr -> . ID actuals
    (77) expr -> . ISUNDEFINED ( designator )
    (78) expr -> . ( expr )
    (79) expr -> . FORALL quantifiers DO expr END
    (80) expr -> . EXISTS quantifiers DO expr END
    (53) designator -> . ID
    (54) designator -> . designator [ expr ]
    (55) designator -> . designator . ID

    !               shift and go to state 60
    +               shift and go to state 58
    -               shift and go to state 59
    INTCONST        shift and go to state 61
    ID              shift and go to state 63
    ISUNDEFINED     shift and go to state 64
    (               shift and go to state 65
    FORALL          shift and go to state 66
    EXISTS          shift and go to state 67

    expr                           shift and go to state 179
    designator                     shift and go to state 62

state 97

    (57) expr -> expr IMPLIES . expr
    (56) expr -> . expr ? expr : expr
    (57) expr -> . expr IMPLIES expr
    (58) expr -> . expr | expr
    (59) expr -> . expr & expr
    (60) expr -> . expr < expr
    (61) expr -> . expr LEQ expr
    (62) expr -> . expr > expr
    (63) expr -> . expr GEQ expr
    (64) expr -> . expr = expr
    (65) expr -> . expr NEQ expr
    (66) expr -> . expr + expr
    (67) expr -> . expr - expr
    (68) expr -> . expr * expr
    (69) expr -> . expr / expr
    (70) expr -> . expr % expr
    (71) expr -> . ! expr
    (72) expr -> . + expr
    (73) expr -> . - expr
    (74) expr -> . INTCONST
    (75) expr -> . designator
    (76) expr -> . ID actuals
    (77) expr -> . ISUNDEFINED ( designator )
    (78) expr -> . ( expr )
    (79) expr -> . FORALL quantifiers DO expr END
    (80) expr -> . EXISTS quantifiers DO expr END
    (53) designator -> . ID
    (54) designator -> . designator [ expr ]
    (55) designator -> . designator . ID

    !               shift and go to state 60
    +               shift and go to state 58
    -               shift and go to state 59
    INTCONST        shift and go to state 61
    ID              shift and go to state 63
    ISUNDEFINED     shift and go to state 64
    (               shift and go to state 65
    FORALL          shift and go to state 66
    EXISTS          shift and go to state 67

    expr                           shift and go to state 180
    designator                     shift and go to state 62

state 98

    (58) expr -> expr | . expr
    (56) expr -> . expr ? expr : expr
    (57) expr -> . expr IMPLIES expr
    (58) expr -> . expr | expr
    (59) expr -> . expr & expr
    (60) expr -> . expr < expr
    (61) expr -> . expr LEQ expr
    (62) expr -> . expr > expr
    (63) expr -> . expr GEQ expr
    (64) expr -> . expr = expr
    (65) expr -> . expr NEQ expr
    (66) expr -> . expr + expr
    (67) expr -> . expr - expr
    (68) expr -> . expr * expr
    (69) expr -> . expr / expr
    (70) expr -> . expr % expr
    (71) expr -> . ! expr
    (72) expr -> . + expr
    (73) expr -> . - expr
    (74) expr -> . INTCONST
    (75) expr -> . designator
    (76) expr -> . ID actuals
    (77) expr -> . ISUNDEFINED ( designator )
    (78) expr -> . ( expr )
    (79) expr -> . FORALL quantifiers DO expr END
    (80) expr -> . EXISTS quantifiers DO expr END
    (53) designator -> . ID
    (54) designator -> . designator [ expr ]
    (55) designator -> . designator . ID

    !               shift and go to state 60
    +               shift and go to state 58
    -               shift and go to state 59
    INTCONST        shift and go to state 61
    ID              shift and go to state 63
    ISUNDEFINED     shift and go to state 64
    (               shift and go to state 65
    FORALL          shift and go to state 66
    EXISTS          shift and go to state 67

    expr                           shift and go to state 181
    designator                     shift and go to state 62

state 99

    (59) expr -> expr & . expr
    (56) expr -> . expr ? expr : expr
    (57) expr -> . expr IMPLIES expr
    (58) expr -> . expr | expr
    (59) expr -> . expr & expr
    (60) expr -> . expr < expr
    (61) expr -> . expr LEQ expr
    (62) expr -> . expr > expr
    (63) expr -> . expr GEQ expr
    (64) expr -> . expr = expr
    (65) expr -> . expr NEQ expr
    (66) expr -> . expr + expr
    (67) expr -> . expr - expr
    (68) expr -> . expr * expr
    (69) expr -> . expr / expr
    (70) expr -> . expr % expr
    (71) expr -> . ! expr
    (72) expr -> . + expr
    (73) expr -> . - expr
    (74) expr -> . INTCONST
    (75) expr -> . designator
    (76) expr -> . ID actuals
    (77) expr -> . ISUNDEFINED ( designator )
    (78) expr -> . ( expr )
    (79) expr -> . FORALL quantifiers DO expr END
    (80) expr -> . EXISTS quantifiers DO expr END
    (53) designator -> . ID
    (54) designator -> . designator [ expr ]
    (55) designator -> . designator . ID

    !               shift and go to state 60
    +               shift and go to state 58
    -               shift and go to state 59
    INTCONST        shift and go to state 61
    ID              shift and go to state 63
    ISUNDEFINED     shift and go to state 64
    (               shift and go to state 65
    FORALL          shift and go to state 66
    EXISTS          shift and go to state 67

    expr                           shift and go to state 182
    designator                     shift and go to state 62

state 100

    (60) expr -> expr < . expr
    (56) expr -> . expr ? expr : expr
    (57) expr -> . expr IMPLIES expr
    (58) expr -> . expr | expr
    (59) expr -> . expr & expr
    (60) expr -> . expr < expr
    (61) expr -> . expr LEQ expr
    (62) expr -> . expr > expr
    (63) expr -> . expr GEQ expr
    (64) expr -> . expr = expr
    (65) expr -> . expr NEQ expr
    (66) expr -> . expr + expr
    (67) expr -> . expr - expr
    (68) expr -> . expr * expr
    (69) expr -> . expr / expr
    (70) expr -> . expr % expr
    (71) expr -> . ! expr
    (72) expr -> . + expr
    (73) expr -> . - expr
    (74) expr -> . INTCONST
    (75) expr -> . designator
    (76) expr -> . ID actuals
    (77) expr -> . ISUNDEFINED ( designator )
    (78) expr -> . ( expr )
    (79) expr -> . FORALL quantifiers DO expr END
    (80) expr -> . EXISTS quantifiers DO expr END
    (53) designator -> . ID
    (54) designator -> . designator [ expr ]
    (55) designator -> . designator . ID

    !               shift and go to state 60
    +               shift and go to state 58
    -               shift and go to state 59
    INTCONST        shift and go to state 61
    ID              shift and go to state 63
    ISUNDEFINED     shift and go to state 64
    (               shift and go to state 65
    FORALL          shift and go to state 66
    EXISTS          shift and go to state 67

    expr                           shift and go to state 183
    designator                     shift and go to state 62

state 101

    (61) expr -> expr LEQ . expr
    (56) expr -> . expr ? expr : expr
    (57) expr -> . expr IMPLIES expr
    (58) expr -> . expr | expr
    (59) expr -> . expr & expr
    (60) expr -> . expr < expr
    (61) expr -> . expr LEQ expr
    (62) expr -> . expr > expr
    (63) expr -> . expr GEQ expr
    (64) expr -> . expr = expr
    (65) expr -> . expr NEQ expr
    (66) expr -> . expr + expr
    (67) expr -> . expr - expr
    (68) expr -> . expr * expr
    (69) expr -> . expr / expr
    (70) expr -> . expr % expr
    (71) expr -> . ! expr
    (72) expr -> . + expr
    (73) expr -> . - expr
    (74) expr -> . INTCONST
    (75) expr -> . designator
    (76) expr -> . ID actuals
    (77) expr -> . ISUNDEFINED ( designator )
    (78) expr -> . ( expr )
    (79) expr -> . FORALL quantifiers DO expr END
    (80) expr -> . EXISTS quantifiers DO expr END
    (53) designator -> . ID
    (54) designator -> . designator [ expr ]
    (55) designator -> . designator . ID

    !               shift and go to state 60
    +               shift and go to state 58
    -               shift and go to state 59
    INTCONST        shift and go to state 61
    ID              shift and go to state 63
    ISUNDEFINED     shift and go to state 64
    (               shift and go to state 65
    FORALL          shift and go to state 66
    EXISTS          shift and go to state 67

    expr                           shift and go to state 184
    designator                     shift and go to state 62

state 102

    (62) expr -> expr > . expr
    (56) expr -> . expr ? expr : expr
    (57) expr -> . expr IMPLIES expr
    (58) expr -> . expr | expr
    (59) expr -> . expr & expr
    (60) expr -> . expr < expr
    (61) expr -> . expr LEQ expr
    (62) expr -> . expr > expr
    (63) expr -> . expr GEQ expr
    (64) expr -> . expr = expr
    (65) expr -> . expr NEQ expr
    (66) expr -> . expr + expr
    (67) expr -> . expr - expr
    (68) expr -> . expr * expr
    (69) expr -> . expr / expr
    (70) expr -> . expr % expr
    (71) expr -> . ! expr
    (72) expr -> . + expr
    (73) expr -> . - expr
    (74) expr -> . INTCONST
    (75) expr -> . designator
    (76) expr -> . ID actuals
    (77) expr -> . ISUNDEFINED ( designator )
    (78) expr -> . ( expr )
    (79) expr -> . FORALL quantifiers DO expr END
    (80) expr -> . EXISTS quantifiers DO expr END
    (53) designator -> . ID
    (54) designator -> . designator [ expr ]
    (55) designator -> . designator . ID

    !               shift and go to state 60
    +               shift and go to state 58
    -               shift and go to state 59
    INTCONST        shift and go to state 61
    ID              shift and go to state 63
    ISUNDEFINED     shift and go to state 64
    (               shift and go to state 65
    FORALL          shift and go to state 66
    EXISTS          shift and go to state 67

    expr                           shift and go to state 185
    designator                     shift and go to state 62

state 103

    (63) expr -> expr GEQ . expr
    (56) expr -> . expr ? expr : expr
    (57) expr -> . expr IMPLIES expr
    (58) expr -> . expr | expr
    (59) expr -> . expr & expr
    (60) expr -> . expr < expr
    (61) expr -> . expr LEQ expr
    (62) expr -> . expr > expr
    (63) expr -> . expr GEQ expr
    (64) expr -> . expr = expr
    (65) expr -> . expr NEQ expr
    (66) expr -> . expr + expr
    (67) expr -> . expr - expr
    (68) expr -> . expr * expr
    (69) expr -> . expr / expr
    (70) expr -> . expr % expr
    (71) expr -> . ! expr
    (72) expr -> . + expr
    (73) expr -> . - expr
    (74) expr -> . INTCONST
    (75) expr -> . designator
    (76) expr -> . ID actuals
    (77) expr -> . ISUNDEFINED ( designator )
    (78) expr -> . ( expr )
    (79) expr -> . FORALL quantifiers DO expr END
    (80) expr -> . EXISTS quantifiers DO expr END
    (53) designator -> . ID
    (54) designator -> . designator [ expr ]
    (55) designator -> . designator . ID

    !               shift and go to state 60
    +               shift and go to state 58
    -               shift and go to state 59
    INTCONST        shift and go to state 61
    ID              shift and go to state 63
    ISUNDEFINED     shift and go to state 64
    (               shift and go to state 65
    FORALL          shift and go to state 66
    EXISTS          shift and go to state 67

    expr                           shift and go to state 186
    designator                     shift and go to state 62

state 104

    (64) expr -> expr = . expr
    (56) expr -> . expr ? expr : expr
    (57) expr -> . expr IMPLIES expr
    (58) expr -> . expr | expr
    (59) expr -> . expr & expr
    (60) expr -> . expr < expr
    (61) expr -> . expr LEQ expr
    (62) expr -> . expr > expr
    (63) expr -> . expr GEQ expr
    (64) expr -> . expr = expr
    (65) expr -> . expr NEQ expr
    (66) expr -> . expr + expr
    (67) expr -> . expr - expr
    (68) expr -> . expr * expr
    (69) expr -> . expr / expr
    (70) expr -> . expr % expr
    (71) expr -> . ! expr
    (72) expr -> . + expr
    (73) expr -> . - expr
    (74) expr -> . INTCONST
    (75) expr -> . designator
    (76) expr -> . ID actuals
    (77) expr -> . ISUNDEFINED ( designator )
    (78) expr -> . ( expr )
    (79) expr -> . FORALL quantifiers DO expr END
    (80) expr -> . EXISTS quantifiers DO expr END
    (53) designator -> . ID
    (54) designator -> . designator [ expr ]
    (55) designator -> . designator . ID

    !               shift and go to state 60
    +               shift and go to state 58
    -               shift and go to state 59
    INTCONST        shift and go to state 61
    ID              shift and go to state 63
    ISUNDEFINED     shift and go to state 64
    (               shift and go to state 65
    FORALL          shift and go to state 66
    EXISTS          shift and go to state 67

    expr                           shift and go to state 187
    designator                     shift and go to state 62

state 105

    (65) expr -> expr NEQ . expr
    (56) expr -> . expr ? expr : expr
    (57) expr -> . expr IMPLIES expr
    (58) expr -> . expr | expr
    (59) expr -> . expr & expr
    (60) expr -> . expr < expr
    (61) expr -> . expr LEQ expr
    (62) expr -> . expr > expr
    (63) expr -> . expr GEQ expr
    (64) expr -> . expr = expr
    (65) expr -> . expr NEQ expr
    (66) expr -> . expr + expr
    (67) expr -> . expr - expr
    (68) expr -> . expr * expr
    (69) expr -> . expr / expr
    (70) expr -> . expr % expr
    (71) expr -> . ! expr
    (72) expr -> . + expr
    (73) expr -> . - expr
    (74) expr -> . INTCONST
    (75) expr -> . designator
    (76) expr -> . ID actuals
    (77) expr -> . ISUNDEFINED ( designator )
    (78) expr -> . ( expr )
    (79) expr -> . FORALL quantifiers DO expr END
    (80) expr -> . EXISTS quantifiers DO expr END
    (53) designator -> . ID
    (54) designator -> . designator [ expr ]
    (55) designator -> . designator . ID

    !               shift and go to state 60
    +               shift and go to state 58
    -               shift and go to state 59
    INTCONST        shift and go to state 61
    ID              shift and go to state 63
    ISUNDEFINED     shift and go to state 64
    (               shift and go to state 65
    FORALL          shift and go to state 66
    EXISTS          shift and go to state 67

    expr                           shift and go to state 188
    designator                     shift and go to state 62

state 106

    (66) expr -> expr + . expr
    (56) expr -> . expr ? expr : expr
    (57) expr -> . expr IMPLIES expr
    (58) expr -> . expr | expr
    (59) expr -> . expr & expr
    (60) expr -> . expr < expr
    (61) expr -> . expr LEQ expr
    (62) expr -> . expr > expr
    (63) expr -> . expr GEQ expr
    (64) expr -> . expr = expr
    (65) expr -> . expr NEQ expr
    (66) expr -> . expr + expr
    (67) expr -> . expr - expr
    (68) expr -> . expr * expr
    (69) expr -> . expr / expr
    (70) expr -> . expr % expr
    (71) expr -> . ! expr
    (72) expr -> . + expr
    (73) expr -> . - expr
    (74) expr -> . INTCONST
    (75) expr -> . designator
    (76) expr -> . ID actuals
    (77) expr -> . ISUNDEFINED ( designator )
    (78) expr -> . ( expr )
    (79) expr -> . FORALL quantifiers DO expr END
    (80) expr -> . EXISTS quantifiers DO expr END
    (53) designator -> . ID
    (54) designator -> . designator [ expr ]
    (55) designator -> . designator . ID

    !               shift and go to state 60
    +               shift and go to state 58
    -               shift and go to state 59
    INTCONST        shift and go to state 61
    ID              shift and go to state 63
    ISUNDEFINED     shift and go to state 64
    (               shift and go to state 65
    FORALL          shift and go to state 66
    EXISTS          shift and go to state 67

    expr                           shift and go to state 189
    designator                     shift and go to state 62

state 107

    (67) expr -> expr - . expr
    (56) expr -> . expr ? expr : expr
    (57) expr -> . expr IMPLIES expr
    (58) expr -> . expr | expr
    (59) expr -> . expr & expr
    (60) expr -> . expr < expr
    (61) expr -> . expr LEQ expr
    (62) expr -> . expr > expr
    (63) expr -> . expr GEQ expr
    (64) expr -> . expr = expr
    (65) expr -> . expr NEQ expr
    (66) expr -> . expr + expr
    (67) expr -> . expr - expr
    (68) expr -> . expr * expr
    (69) expr -> . expr / expr
    (70) expr -> . expr % expr
    (71) expr -> . ! expr
    (72) expr -> . + expr
    (73) expr -> . - expr
    (74) expr -> . INTCONST
    (75) expr -> . designator
    (76) expr -> . ID actuals
    (77) expr -> . ISUNDEFINED ( designator )
    (78) expr -> . ( expr )
    (79) expr -> . FORALL quantifiers DO expr END
    (80) expr -> . EXISTS quantifiers DO expr END
    (53) designator -> . ID
    (54) designator -> . designator [ expr ]
    (55) designator -> . designator . ID

    !               shift and go to state 60
    +               shift and go to state 58
    -               shift and go to state 59
    INTCONST        shift and go to state 61
    ID              shift and go to state 63
    ISUNDEFINED     shift and go to state 64
    (               shift and go to state 65
    FORALL          shift and go to state 66
    EXISTS          shift and go to state 67

    expr                           shift and go to state 190
    designator                     shift and go to state 62

state 108

    (68) expr -> expr * . expr
    (56) expr -> . expr ? expr : expr
    (57) expr -> . expr IMPLIES expr
    (58) expr -> . expr | expr
    (59) expr -> . expr & expr
    (60) expr -> . expr < expr
    (61) expr -> . expr LEQ expr
    (62) expr -> . expr > expr
    (63) expr -> . expr GEQ expr
    (64) expr -> . expr = expr
    (65) expr -> . expr NEQ expr
    (66) expr -> . expr + expr
    (67) expr -> . expr - expr
    (68) expr -> . expr * expr
    (69) expr -> . expr / expr
    (70) expr -> . expr % expr
    (71) expr -> . ! expr
    (72) expr -> . + expr
    (73) expr -> . - expr
    (74) expr -> . INTCONST
    (75) expr -> . designator
    (76) expr -> . ID actuals
    (77) expr -> . ISUNDEFINED ( designator )
    (78) expr -> . ( expr )
    (79) expr -> . FORALL quantifiers DO expr END
    (80) expr -> . EXISTS quantifiers DO expr END
    (53) designator -> . ID
    (54) designator -> . designator [ expr ]
    (55) designator -> . designator . ID

    !               shift and go to state 60
    +               shift and go to state 58
    -               shift and go to state 59
    INTCONST        shift and go to state 61
    ID              shift and go to state 63
    ISUNDEFINED     shift and go to state 64
    (               shift and go to state 65
    FORALL          shift and go to state 66
    EXISTS          shift and go to state 67

    expr                           shift and go to state 191
    designator                     shift and go to state 62

state 109

    (69) expr -> expr / . expr
    (56) expr -> . expr ? expr : expr
    (57) expr -> . expr IMPLIES expr
    (58) expr -> . expr | expr
    (59) expr -> . expr & expr
    (60) expr -> . expr < expr
    (61) expr -> . expr LEQ expr
    (62) expr -> . expr > expr
    (63) expr -> . expr GEQ expr
    (64) expr -> . expr = expr
    (65) expr -> . expr NEQ expr
    (66) expr -> . expr + expr
    (67) expr -> . expr - expr
    (68) expr -> . expr * expr
    (69) expr -> . expr / expr
    (70) expr -> . expr % expr
    (71) expr -> . ! expr
    (72) expr -> . + expr
    (73) expr -> . - expr
    (74) expr -> . INTCONST
    (75) expr -> . designator
    (76) expr -> . ID actuals
    (77) expr -> . ISUNDEFINED ( designator )
    (78) expr -> . ( expr )
    (79) expr -> . FORALL quantifiers DO expr END
    (80) expr -> . EXISTS quantifiers DO expr END
    (53) designator -> . ID
    (54) designator -> . designator [ expr ]
    (55) designator -> . designator . ID

    !               shift and go to state 60
    +               shift and go to state 58
    -               shift and go to state 59
    INTCONST        shift and go to state 61
    ID              shift and go to state 63
    ISUNDEFINED     shift and go to state 64
    (               shift and go to state 65
    FORALL          shift and go to state 66
    EXISTS          shift and go to state 67

    expr                           shift and go to state 192
    designator                     shift and go to state 62

state 110

    (70) expr -> expr % . expr
    (56) expr -> . expr ? expr : expr
    (57) expr -> . expr IMPLIES expr
    (58) expr -> . expr | expr
    (59) expr -> . expr & expr
    (60) expr -> . expr < expr
    (61) expr -> . expr LEQ expr
    (62) expr -> . expr > expr
    (63) expr -> . expr GEQ expr
    (64) expr -> . expr = expr
    (65) expr -> . expr NEQ expr
    (66) expr -> . expr + expr
    (67) expr -> . expr - expr
    (68) expr -> . expr * expr
    (69) expr -> . expr / expr
    (70) expr -> . expr % expr
    (71) expr -> . ! expr
    (72) expr -> . + expr
    (73) expr -> . - expr
    (74) expr -> . INTCONST
    (75) expr -> . designator
    (76) expr -> . ID actuals
    (77) expr -> . ISUNDEFINED ( designator )
    (78) expr -> . ( expr )
    (79) expr -> . FORALL quantifiers DO expr END
    (80) expr -> . EXISTS quantifiers DO expr END
    (53) designator -> . ID
    (54) designator -> . designator [ expr ]
    (55) designator -> . designator . ID

    !               shift and go to state 60
    +               shift and go to state 58
    -               shift and go to state 59
    INTCONST        shift and go to state 61
    ID              shift and go to state 63
    ISUNDEFINED     shift and go to state 64
    (               shift and go to state 65
    FORALL          shift and go to state 66
    EXISTS          shift and go to state 67

    expr                           shift and go to state 193
    designator                     shift and go to state 62

state 111

    (72) expr -> + expr .
    (56) expr -> expr . ? expr : expr
    (57) expr -> expr . IMPLIES expr
    (58) expr -> expr . | expr
    (59) expr -> expr . & expr
    (60) expr -> expr . < expr
    (61) expr -> expr . LEQ expr
    (62) expr -> expr . > expr
    (63) expr -> expr . GEQ expr
    (64) expr -> expr . = expr
    (65) expr -> expr . NEQ expr
    (66) expr -> expr . + expr
    (67) expr -> expr . - expr
    (68) expr -> expr . * expr
    (69) expr -> expr . / expr
    (70) expr -> expr . % expr

    LONGARROW       reduce using rule 72 (expr -> + expr .)
    ?               reduce using rule 72 (expr -> + expr .)
    IMPLIES         reduce using rule 72 (expr -> + expr .)
    |               reduce using rule 72 (expr -> + expr .)
    &               reduce using rule 72 (expr -> + expr .)
    <               reduce using rule 72 (expr -> + expr .)
    LEQ             reduce using rule 72 (expr -> + expr .)
    >               reduce using rule 72 (expr -> + expr .)
    GEQ             reduce using rule 72 (expr -> + expr .)
    =               reduce using rule 72 (expr -> + expr .)
    NEQ             reduce using rule 72 (expr -> + expr .)
    +               reduce using rule 72 (expr -> + expr .)
    -               reduce using rule 72 (expr -> + expr .)
    *               reduce using rule 72 (expr -> + expr .)
    /               reduce using rule 72 (expr -> + expr .)
    %               reduce using rule 72 (expr -> + expr .)
    ;               reduce using rule 72 (expr -> + expr .)
    $end            reduce using rule 72 (expr -> + expr .)
    END             reduce using rule 72 (expr -> + expr .)
    )               reduce using rule 72 (expr -> + expr .)
    DO              reduce using rule 72 (expr -> + expr .)
    DOTDOT          reduce using rule 72 (expr -> + expr .)
    :               reduce using rule 72 (expr -> + expr .)
    ]               reduce using rule 72 (expr -> + expr .)
    ,               reduce using rule 72 (expr -> + expr .)
    THEN            reduce using rule 72 (expr -> + expr .)
    ELSE            reduce using rule 72 (expr -> + expr .)
    CASE            reduce using rule 72 (expr -> + expr .)
    STRING          reduce using rule 72 (expr -> + expr .)
    ELSIF           reduce using rule 72 (expr -> + expr .)

  ! ?               [ shift and go to state 96 ]
  ! IMPLIES         [ shift and go to state 97 ]
  ! |               [ shift and go to state 98 ]
  ! &               [ shift and go to state 99 ]
  ! <               [ shift and go to state 100 ]
  ! LEQ             [ shift and go to state 101 ]
  ! >               [ shift and go to state 102 ]
  ! GEQ             [ shift and go to state 103 ]
  ! =               [ shift and go to state 104 ]
  ! NEQ             [ shift and go to state 105 ]
  ! +               [ shift and go to state 106 ]
  ! -               [ shift and go to state 107 ]
  ! *               [ shift and go to state 108 ]
  ! /               [ shift and go to state 109 ]
  ! %               [ shift and go to state 110 ]


state 112

    (73) expr -> - expr .
    (56) expr -> expr . ? expr : expr
    (57) expr -> expr . IMPLIES expr
    (58) expr -> expr . | expr
    (59) expr -> expr . & expr
    (60) expr -> expr . < expr
    (61) expr -> expr . LEQ expr
    (62) expr -> expr . > expr
    (63) expr -> expr . GEQ expr
    (64) expr -> expr . = expr
    (65) expr -> expr . NEQ expr
    (66) expr -> expr . + expr
    (67) expr -> expr . - expr
    (68) expr -> expr . * expr
    (69) expr -> expr . / expr
    (70) expr -> expr . % expr

    LONGARROW       reduce using rule 73 (expr -> - expr .)
    ?               reduce using rule 73 (expr -> - expr .)
    IMPLIES         reduce using rule 73 (expr -> - expr .)
    |               reduce using rule 73 (expr -> - expr .)
    &               reduce using rule 73 (expr -> - expr .)
    <               reduce using rule 73 (expr -> - expr .)
    LEQ             reduce using rule 73 (expr -> - expr .)
    >               reduce using rule 73 (expr -> - expr .)
    GEQ             reduce using rule 73 (expr -> - expr .)
    =               reduce using rule 73 (expr -> - expr .)
    NEQ             reduce using rule 73 (expr -> - expr .)
    +               reduce using rule 73 (expr -> - expr .)
    -               reduce using rule 73 (expr -> - expr .)
    *               reduce using rule 73 (expr -> - expr .)
    /               reduce using rule 73 (expr -> - expr .)
    %               reduce using rule 73 (expr -> - expr .)
    ;               reduce using rule 73 (expr -> - expr .)
    $end            reduce using rule 73 (expr -> - expr .)
    END             reduce using rule 73 (expr -> - expr .)
    )               reduce using rule 73 (expr -> - expr .)
    DO              reduce using rule 73 (expr -> - expr .)
    DOTDOT          reduce using rule 73 (expr -> - expr .)
    :               reduce using rule 73 (expr -> - expr .)
    ]               reduce using rule 73 (expr -> - expr .)
    ,               reduce using rule 73 (expr -> - expr .)
    THEN            reduce using rule 73 (expr -> - expr .)
    ELSE            reduce using rule 73 (expr -> - expr .)
    CASE            reduce using rule 73 (expr -> - expr .)
    STRING          reduce using rule 73 (expr -> - expr .)
    ELSIF           reduce using rule 73 (expr -> - expr .)

  ! ?               [ shift and go to state 96 ]
  ! IMPLIES         [ shift and go to state 97 ]
  ! |               [ shift and go to state 98 ]
  ! &               [ shift and go to state 99 ]
  ! <               [ shift and go to state 100 ]
  ! LEQ             [ shift and go to state 101 ]
  ! >               [ shift and go to state 102 ]
  ! GEQ             [ shift and go to state 103 ]
  ! =               [ shift and go to state 104 ]
  ! NEQ             [ shift and go to state 105 ]
  ! +               [ shift and go to state 106 ]
  ! -               [ shift and go to state 107 ]
  ! *               [ shift and go to state 108 ]
  ! /               [ shift and go to state 109 ]
  ! %               [ shift and go to state 110 ]


state 113

    (71) expr -> ! expr .
    (56) expr -> expr . ? expr : expr
    (57) expr -> expr . IMPLIES expr
    (58) expr -> expr . | expr
    (59) expr -> expr . & expr
    (60) expr -> expr . < expr
    (61) expr -> expr . LEQ expr
    (62) expr -> expr . > expr
    (63) expr -> expr . GEQ expr
    (64) expr -> expr . = expr
    (65) expr -> expr . NEQ expr
    (66) expr -> expr . + expr
    (67) expr -> expr . - expr
    (68) expr -> expr . * expr
    (69) expr -> expr . / expr
    (70) expr -> expr . % expr

    LONGARROW       reduce using rule 71 (expr -> ! expr .)
    ?               reduce using rule 71 (expr -> ! expr .)
    IMPLIES         reduce using rule 71 (expr -> ! expr .)
    |               reduce using rule 71 (expr -> ! expr .)
    &               reduce using rule 71 (expr -> ! expr .)
    ;               reduce using rule 71 (expr -> ! expr .)
    $end            reduce using rule 71 (expr -> ! expr .)
    END             reduce using rule 71 (expr -> ! expr .)
    )               reduce using rule 71 (expr -> ! expr .)
    DO              reduce using rule 71 (expr -> ! expr .)
    DOTDOT          reduce using rule 71 (expr -> ! expr .)
    :               reduce using rule 71 (expr -> ! expr .)
    ]               reduce using rule 71 (expr -> ! expr .)
    ,               reduce using rule 71 (expr -> ! expr .)
    THEN            reduce using rule 71 (expr -> ! expr .)
    ELSE            reduce using rule 71 (expr -> ! expr .)
    CASE            reduce using rule 71 (expr -> ! expr .)
    STRING          reduce using rule 71 (expr -> ! expr .)
    ELSIF           reduce using rule 71 (expr -> ! expr .)
    <               shift and go to state 100
    LEQ             shift and go to state 101
    >               shift and go to state 102
    GEQ             shift and go to state 103
    =               shift and go to state 104
    NEQ             shift and go to state 105
    +               shift and go to state 106
    -               shift and go to state 107
    *               shift and go to state 108
    /               shift and go to state 109
    %               shift and go to state 110

  ! <               [ reduce using rule 71 (expr -> ! expr .) ]
  ! LEQ             [ reduce using rule 71 (expr -> ! expr .) ]
  ! >               [ reduce using rule 71 (expr -> ! expr .) ]
  ! GEQ             [ reduce using rule 71 (expr -> ! expr .) ]
  ! =               [ reduce using rule 71 (expr -> ! expr .) ]
  ! NEQ             [ reduce using rule 71 (expr -> ! expr .) ]
  ! +               [ reduce using rule 71 (expr -> ! expr .) ]
  ! -               [ reduce using rule 71 (expr -> ! expr .) ]
  ! *               [ reduce using rule 71 (expr -> ! expr .) ]
  ! /               [ reduce using rule 71 (expr -> ! expr .) ]
  ! %               [ reduce using rule 71 (expr -> ! expr .) ]
  ! ?               [ shift and go to state 96 ]
  ! IMPLIES         [ shift and go to state 97 ]
  ! |               [ shift and go to state 98 ]
  ! &               [ shift and go to state 99 ]


state 114

    (54) designator -> designator [ . expr ]
    (56) expr -> . expr ? expr : expr
    (57) expr -> . expr IMPLIES expr
    (58) expr -> . expr | expr
    (59) expr -> . expr & expr
    (60) expr -> . expr < expr
    (61) expr -> . expr LEQ expr
    (62) expr -> . expr > expr
    (63) expr -> . expr GEQ expr
    (64) expr -> . expr = expr
    (65) expr -> . expr NEQ expr
    (66) expr -> . expr + expr
    (67) expr -> . expr - expr
    (68) expr -> . expr * expr
    (69) expr -> . expr / expr
    (70) expr -> . expr % expr
    (71) expr -> . ! expr
    (72) expr -> . + expr
    (73) expr -> . - expr
    (74) expr -> . INTCONST
    (75) expr -> . designator
    (76) expr -> . ID actuals
    (77) expr -> . ISUNDEFINED ( designator )
    (78) expr -> . ( expr )
    (79) expr -> . FORALL quantifiers DO expr END
    (80) expr -> . EXISTS quantifiers DO expr END
    (53) designator -> . ID
    (54) designator -> . designator [ expr ]
    (55) designator -> . designator . ID

    !               shift and go to state 60
    +               shift and go to state 58
    -               shift and go to state 59
    INTCONST        shift and go to state 61
    ID              shift and go to state 63
    ISUNDEFINED     shift and go to state 64
    (               shift and go to state 65
    FORALL          shift and go to state 66
    EXISTS          shift and go to state 67

    designator                     shift and go to state 62
    expr                           shift and go to state 194

state 115

    (55) designator -> designator . . ID

    ID              shift and go to state 195


state 116

    (76) expr -> ID actuals .

    LONGARROW       reduce using rule 76 (expr -> ID actuals .)
    ?               reduce using rule 76 (expr -> ID actuals .)
    IMPLIES         reduce using rule 76 (expr -> ID actuals .)
    |               reduce using rule 76 (expr -> ID actuals .)
    &               reduce using rule 76 (expr -> ID actuals .)
    <               reduce using rule 76 (expr -> ID actuals .)
    LEQ             reduce using rule 76 (expr -> ID actuals .)
    >               reduce using rule 76 (expr -> ID actuals .)
    GEQ             reduce using rule 76 (expr -> ID actuals .)
    =               reduce using rule 76 (expr -> ID actuals .)
    NEQ             reduce using rule 76 (expr -> ID actuals .)
    +               reduce using rule 76 (expr -> ID actuals .)
    -               reduce using rule 76 (expr -> ID actuals .)
    *               reduce using rule 76 (expr -> ID actuals .)
    /               reduce using rule 76 (expr -> ID actuals .)
    %               reduce using rule 76 (expr -> ID actuals .)
    ;               reduce using rule 76 (expr -> ID actuals .)
    $end            reduce using rule 76 (expr -> ID actuals .)
    END             reduce using rule 76 (expr -> ID actuals .)
    )               reduce using rule 76 (expr -> ID actuals .)
    DO              reduce using rule 76 (expr -> ID actuals .)
    DOTDOT          reduce using rule 76 (expr -> ID actuals .)
    :               reduce using rule 76 (expr -> ID actuals .)
    ]               reduce using rule 76 (expr -> ID actuals .)
    ,               reduce using rule 76 (expr -> ID actuals .)
    THEN            reduce using rule 76 (expr -> ID actuals .)
    ELSE            reduce using rule 76 (expr -> ID actuals .)
    CASE            reduce using rule 76 (expr -> ID actuals .)
    STRING          reduce using rule 76 (expr -> ID actuals .)
    ELSIF           reduce using rule 76 (expr -> ID actuals .)


state 117

    (81) actuals -> ( . exprlist )
    (82) actuals -> ( . )
    (83) exprlist -> . exprlist , expr
    (84) exprlist -> . expr
    (56) expr -> . expr ? expr : expr
    (57) expr -> . expr IMPLIES expr
    (58) expr -> . expr | expr
    (59) expr -> . expr & expr
    (60) expr -> . expr < expr
    (61) expr -> . expr LEQ expr
    (62) expr -> . expr > expr
    (63) expr -> . expr GEQ expr
    (64) expr -> . expr = expr
    (65) expr -> . expr NEQ expr
    (66) expr -> . expr + expr
    (67) expr -> . expr - expr
    (68) expr -> . expr * expr
    (69) expr -> . expr / expr
    (70) expr -> . expr % expr
    (71) expr -> . ! expr
    (72) expr -> . + expr
    (73) expr -> . - expr
    (74) expr -> . INTCONST
    (75) expr -> . designator
    (76) expr -> . ID actuals
    (77) expr -> . ISUNDEFINED ( designator )
    (78) expr -> . ( expr )
    (79) expr -> . FORALL quantifiers DO expr END
    (80) expr -> . EXISTS quantifiers DO expr END
    (53) designator -> . ID
    (54) designator -> . designator [ expr ]
    (55) designator -> . designator . ID

    )               shift and go to state 197
    !               shift and go to state 60
    +               shift and go to state 58
    -               shift and go to state 59
    INTCONST        shift and go to state 61
    ID              shift and go to state 63
    ISUNDEFINED     shift and go to state 64
    (               shift and go to state 65
    FORALL          shift and go to state 66
    EXISTS          shift and go to state 67

    exprlist                       shift and go to state 196
    expr                           shift and go to state 198
    designator                     shift and go to state 62

state 118

    (77) expr -> ISUNDEFINED ( . designator )
    (53) designator -> . ID
    (54) designator -> . designator [ expr ]
    (55) designator -> . designator . ID

    ID              shift and go to state 200

    designator                     shift and go to state 199

state 119

    (78) expr -> ( expr . )
    (56) expr -> expr . ? expr : expr
    (57) expr -> expr . IMPLIES expr
    (58) expr -> expr . | expr
    (59) expr -> expr . & expr
    (60) expr -> expr . < expr
    (61) expr -> expr . LEQ expr
    (62) expr -> expr . > expr
    (63) expr -> expr . GEQ expr
    (64) expr -> expr . = expr
    (65) expr -> expr . NEQ expr
    (66) expr -> expr . + expr
    (67) expr -> expr . - expr
    (68) expr -> expr . * expr
    (69) expr -> expr . / expr
    (70) expr -> expr . % expr

    )               shift and go to state 201
    ?               shift and go to state 96
    IMPLIES         shift and go to state 97
    |               shift and go to state 98
    &               shift and go to state 99
    <               shift and go to state 100
    LEQ             shift and go to state 101
    >               shift and go to state 102
    GEQ             shift and go to state 103
    =               shift and go to state 104
    NEQ             shift and go to state 105
    +               shift and go to state 106
    -               shift and go to state 107
    *               shift and go to state 108
    /               shift and go to state 109
    %               shift and go to state 110


state 120

    (79) expr -> FORALL quantifiers . DO expr END

    DO              shift and go to state 202


state 121

    (80) expr -> EXISTS quantifiers . DO expr END

    DO              shift and go to state 203


state 122

    (144) aliasrule -> ALIAS aliases DO rules . END

    END             shift and go to state 204


state 123

    (124) aliases -> aliases ; alias .

    DO              reduce using rule 124 (aliases -> aliases ; alias .)
    ;               reduce using rule 124 (aliases -> aliases ; alias .)


state 124

    (127) alias -> ID : expr .
    (56) expr -> expr . ? expr : expr
    (57) expr -> expr . IMPLIES expr
    (58) expr -> expr . | expr
    (59) expr -> expr . & expr
    (60) expr -> expr . < expr
    (61) expr -> expr . LEQ expr
    (62) expr -> expr . > expr
    (63) expr -> expr . GEQ expr
    (64) expr -> expr . = expr
    (65) expr -> expr . NEQ expr
    (66) expr -> expr . + expr
    (67) expr -> expr . - expr
    (68) expr -> expr . * expr
    (69) expr -> expr . / expr
    (70) expr -> expr . % expr

    DO              reduce using rule 127 (alias -> ID : expr .)
    ;               reduce using rule 127 (alias -> ID : expr .)
    ?               shift and go to state 96
    IMPLIES         shift and go to state 97
    |               shift and go to state 98
    &               shift and go to state 99
    <               shift and go to state 100
    LEQ             shift and go to state 101
    >               shift and go to state 102
    GEQ             shift and go to state 103
    =               shift and go to state 104
    NEQ             shift and go to state 105
    +               shift and go to state 106
    -               shift and go to state 107
    *               shift and go to state 108
    /               shift and go to state 109
    %               shift and go to state 110


state 125

    (145) ruleset -> RULESET quantifiers DO rules . END

    END             shift and go to state 205


state 126

    (86) quantifiers -> quantifier ; quantifiers .

    DO              reduce using rule 86 (quantifiers -> quantifier ; quantifiers .)


state 127

    (18) typeid -> ID .
    (76) expr -> ID . actuals
    (53) designator -> ID .
    (81) actuals -> . ( exprlist )
    (82) actuals -> . ( )

    ;               reduce using rule 18 (typeid -> ID .)
    DO              reduce using rule 18 (typeid -> ID .)
    )               reduce using rule 18 (typeid -> ID .)
    ]               reduce using rule 18 (typeid -> ID .)
    END             reduce using rule 18 (typeid -> ID .)
    [               reduce using rule 53 (designator -> ID .)
    .               reduce using rule 53 (designator -> ID .)
    DOTDOT          reduce using rule 53 (designator -> ID .)
    ?               reduce using rule 53 (designator -> ID .)
    IMPLIES         reduce using rule 53 (designator -> ID .)
    |               reduce using rule 53 (designator -> ID .)
    &               reduce using rule 53 (designator -> ID .)
    <               reduce using rule 53 (designator -> ID .)
    LEQ             reduce using rule 53 (designator -> ID .)
    >               reduce using rule 53 (designator -> ID .)
    GEQ             reduce using rule 53 (designator -> ID .)
    =               reduce using rule 53 (designator -> ID .)
    NEQ             reduce using rule 53 (designator -> ID .)
    +               reduce using rule 53 (designator -> ID .)
    -               reduce using rule 53 (designator -> ID .)
    *               reduce using rule 53 (designator -> ID .)
    /               reduce using rule 53 (designator -> ID .)
    %               reduce using rule 53 (designator -> ID .)
    (               shift and go to state 117

    actuals                        shift and go to state 116

state 128

    (85) quantifier -> ID : typeexpr .

    ;               reduce using rule 85 (quantifier -> ID : typeexpr .)
    DO              reduce using rule 85 (quantifier -> ID : typeexpr .)


state 129

    (13) typeexpr -> typeid .

    ;               reduce using rule 13 (typeexpr -> typeid .)
    DO              reduce using rule 13 (typeexpr -> typeid .)
    )               reduce using rule 13 (typeexpr -> typeid .)
    ]               reduce using rule 13 (typeexpr -> typeid .)
    END             reduce using rule 13 (typeexpr -> typeid .)


state 130

    (14) typeexpr -> enumtype .

    ;               reduce using rule 14 (typeexpr -> enumtype .)
    DO              reduce using rule 14 (typeexpr -> enumtype .)
    )               reduce using rule 14 (typeexpr -> enumtype .)
    ]               reduce using rule 14 (typeexpr -> enumtype .)
    END             reduce using rule 14 (typeexpr -> enumtype .)


state 131

    (15) typeexpr -> subrangetype .

    ;               reduce using rule 15 (typeexpr -> subrangetype .)
    DO              reduce using rule 15 (typeexpr -> subrangetype .)
    )               reduce using rule 15 (typeexpr -> subrangetype .)
    ]               reduce using rule 15 (typeexpr -> subrangetype .)
    END             reduce using rule 15 (typeexpr -> subrangetype .)


state 132

    (16) typeexpr -> recordtype .

    ;               reduce using rule 16 (typeexpr -> recordtype .)
    DO              reduce using rule 16 (typeexpr -> recordtype .)
    )               reduce using rule 16 (typeexpr -> recordtype .)
    ]               reduce using rule 16 (typeexpr -> recordtype .)
    END             reduce using rule 16 (typeexpr -> recordtype .)


state 133

    (17) typeexpr -> arraytype .

    ;               reduce using rule 17 (typeexpr -> arraytype .)
    DO              reduce using rule 17 (typeexpr -> arraytype .)
    )               reduce using rule 17 (typeexpr -> arraytype .)
    ]               reduce using rule 17 (typeexpr -> arraytype .)
    END             reduce using rule 17 (typeexpr -> arraytype .)


state 134

    (19) enumtype -> ENUM . { enums }

    {               shift and go to state 206


state 135

    (22) subrangetype -> expr . DOTDOT expr
    (56) expr -> expr . ? expr : expr
    (57) expr -> expr . IMPLIES expr
    (58) expr -> expr . | expr
    (59) expr -> expr . & expr
    (60) expr -> expr . < expr
    (61) expr -> expr . LEQ expr
    (62) expr -> expr . > expr
    (63) expr -> expr . GEQ expr
    (64) expr -> expr . = expr
    (65) expr -> expr . NEQ expr
    (66) expr -> expr . + expr
    (67) expr -> expr . - expr
    (68) expr -> expr . * expr
    (69) expr -> expr . / expr
    (70) expr -> expr . % expr

    DOTDOT          shift and go to state 207
    ?               shift and go to state 96
    IMPLIES         shift and go to state 97
    |               shift and go to state 98
    &               shift and go to state 99
    <               shift and go to state 100
    LEQ             shift and go to state 101
    >               shift and go to state 102
    GEQ             shift and go to state 103
    =               shift and go to state 104
    NEQ             shift and go to state 105
    +               shift and go to state 106
    -               shift and go to state 107
    *               shift and go to state 108
    /               shift and go to state 109
    %               shift and go to state 110


state 136

    (23) recordtype -> RECORD . fields END
    (24) fields -> . fields ; field
    (25) fields -> . fields ;
    (26) fields -> . field
    (27) field -> . ID fieldtail

    ID              shift and go to state 210

    fields                         shift and go to state 208
    field                          shift and go to state 209

state 137

    (30) arraytype -> ARRAY . [ typeexpr ] OF typeexpr

    [               shift and go to state 211


state 138

    (146) startstate -> STARTSTATE optstring optdecls optstmts . END

    END             shift and go to state 212


state 139

    (88) optstmts -> stmts .
    (90) stmts -> stmts . ; stmt
    (91) stmts -> stmts . ;

    END             reduce using rule 88 (optstmts -> stmts .)
    ELSIF           reduce using rule 88 (optstmts -> stmts .)
    ELSE            reduce using rule 88 (optstmts -> stmts .)
    CASE            reduce using rule 88 (optstmts -> stmts .)
    ;               shift and go to state 213


state 140

    (89) optstmts -> empty .

    END             reduce using rule 89 (optstmts -> empty .)
    ELSIF           reduce using rule 89 (optstmts -> empty .)
    ELSE            reduce using rule 89 (optstmts -> empty .)
    CASE            reduce using rule 89 (optstmts -> empty .)


state 141

    (92) stmts -> stmt .

    ;               reduce using rule 92 (stmts -> stmt .)
    END             reduce using rule 92 (stmts -> stmt .)
    ELSIF           reduce using rule 92 (stmts -> stmt .)
    ELSE            reduce using rule 92 (stmts -> stmt .)
    CASE            reduce using rule 92 (stmts -> stmt .)


state 142

    (93) stmt -> assignment .

    ;               reduce using rule 93 (stmt -> assignment .)
    END             reduce using rule 93 (stmt -> assignment .)
    ELSIF           reduce using rule 93 (stmt -> assignment .)
    ELSE            reduce using rule 93 (stmt -> assignment .)
    CASE            reduce using rule 93 (stmt -> assignment .)


state 143

    (94) stmt -> ifstmt .

    ;               reduce using rule 94 (stmt -> ifstmt .)
    END             reduce using rule 94 (stmt -> ifstmt .)
    ELSIF           reduce using rule 94 (stmt -> ifstmt .)
    ELSE            reduce using rule 94 (stmt -> ifstmt .)
    CASE            reduce using rule 94 (stmt -> ifstmt .)


state 144

    (95) stmt -> whilestmt .

    ;               reduce using rule 95 (stmt -> whilestmt .)
    END             reduce using rule 95 (stmt -> whilestmt .)
    ELSIF           reduce using rule 95 (stmt -> whilestmt .)
    ELSE            reduce using rule 95 (stmt -> whilestmt .)
    CASE            reduce using rule 95 (stmt -> whilestmt .)


state 145

    (96) stmt -> switchstmt .

    ;               reduce using rule 96 (stmt -> switchstmt .)
    END             reduce using rule 96 (stmt -> switchstmt .)
    ELSIF           reduce using rule 96 (stmt -> switchstmt .)
    ELSE            reduce using rule 96 (stmt -> switchstmt .)
    CASE            reduce using rule 96 (stmt -> switchstmt .)


state 146

    (97) stmt -> forstmt .

    ;               reduce using rule 97 (stmt -> forstmt .)
    END             reduce using rule 97 (stmt -> forstmt .)
    ELSIF           reduce using rule 97 (stmt -> forstmt .)
    ELSE            reduce using rule 97 (stmt -> forstmt .)
    CASE            reduce using rule 97 (stmt -> forstmt .)


state 147

    (98) stmt -> proccall .

    ;               reduce using rule 98 (stmt -> proccall .)
    END             reduce using rule 98 (stmt -> proccall .)
    ELSIF           reduce using rule 98 (stmt -> proccall .)
    ELSE            reduce using rule 98 (stmt -> proccall .)
    CASE            reduce using rule 98 (stmt -> proccall .)


state 148

    (99) stmt -> clearstmt .

    ;               reduce using rule 99 (stmt -> clearstmt .)
    END             reduce using rule 99 (stmt -> clearstmt .)
    ELSIF           reduce using rule 99 (stmt -> clearstmt .)
    ELSE            reduce using rule 99 (stmt -> clearstmt .)
    CASE            reduce using rule 99 (stmt -> clearstmt .)


state 149

    (100) stmt -> errorstmt .

    ;               reduce using rule 100 (stmt -> errorstmt .)
    END             reduce using rule 100 (stmt -> errorstmt .)
    ELSIF           reduce using rule 100 (stmt -> errorstmt .)
    ELSE            reduce using rule 100 (stmt -> errorstmt .)
    CASE            reduce using rule 100 (stmt -> errorstmt .)


state 150

    (101) stmt -> assertstmt .

    ;               reduce using rule 101 (stmt -> assertstmt .)
    END             reduce using rule 101 (stmt -> assertstmt .)
    ELSIF           reduce using rule 101 (stmt -> assertstmt .)
    ELSE            reduce using rule 101 (stmt -> assertstmt .)
    CASE            reduce using rule 101 (stmt -> assertstmt .)


state 151

    (102) stmt -> aliasstmt .

    ;               reduce using rule 102 (stmt -> aliasstmt .)
    END             reduce using rule 102 (stmt -> aliasstmt .)
    ELSIF           reduce using rule 102 (stmt -> aliasstmt .)
    ELSE            reduce using rule 102 (stmt -> aliasstmt .)
    CASE            reduce using rule 102 (stmt -> aliasstmt .)


state 152

    (103) stmt -> returnstmt .

    ;               reduce using rule 103 (stmt -> returnstmt .)
    END             reduce using rule 103 (stmt -> returnstmt .)
    ELSIF           reduce using rule 103 (stmt -> returnstmt .)
    ELSE            reduce using rule 103 (stmt -> returnstmt .)
    CASE            reduce using rule 103 (stmt -> returnstmt .)


state 153

    (104) stmt -> undefinestmt .

    ;               reduce using rule 104 (stmt -> undefinestmt .)
    END             reduce using rule 104 (stmt -> undefinestmt .)
    ELSIF           reduce using rule 104 (stmt -> undefinestmt .)
    ELSE            reduce using rule 104 (stmt -> undefinestmt .)
    CASE            reduce using rule 104 (stmt -> undefinestmt .)


state 154

    (105) assignment -> designator . ASSIGN expr
    (54) designator -> designator . [ expr ]
    (55) designator -> designator . . ID

    ASSIGN          shift and go to state 214
    [               shift and go to state 114
    .               shift and go to state 115


state 155

    (106) ifstmt -> IF . expr THEN optstmts optelses END
    (56) expr -> . expr ? expr : expr
    (57) expr -> . expr IMPLIES expr
    (58) expr -> . expr | expr
    (59) expr -> . expr & expr
    (60) expr -> . expr < expr
    (61) expr -> . expr LEQ expr
    (62) expr -> . expr > expr
    (63) expr -> . expr GEQ expr
    (64) expr -> . expr = expr
    (65) expr -> . expr NEQ expr
    (66) expr -> . expr + expr
    (67) expr -> . expr - expr
    (68) expr -> . expr * expr
    (69) expr -> . expr / expr
    (70) expr -> . expr % expr
    (71) expr -> . ! expr
    (72) expr -> . + expr
    (73) expr -> . - expr
    (74) expr -> . INTCONST
    (75) expr -> . designator
    (76) expr -> . ID actuals
    (77) expr -> . ISUNDEFINED ( designator )
    (78) expr -> . ( expr )
    (79) expr -> . FORALL quantifiers DO expr END
    (80) expr -> . EXISTS quantifiers DO expr END
    (53) designator -> . ID
    (54) designator -> . designator [ expr ]
    (55) designator -> . designator . ID

    !               shift and go to state 60
    +               shift and go to state 58
    -               shift and go to state 59
    INTCONST        shift and go to state 61
    ID              shift and go to state 63
    ISUNDEFINED     shift and go to state 64
    (               shift and go to state 65
    FORALL          shift and go to state 66
    EXISTS          shift and go to state 67

    expr                           shift and go to state 215
    designator                     shift and go to state 62

state 156

    (112) whilestmt -> WHILE . expr DO optstmts END
    (56) expr -> . expr ? expr : expr
    (57) expr -> . expr IMPLIES expr
    (58) expr -> . expr | expr
    (59) expr -> . expr & expr
    (60) expr -> . expr < expr
    (61) expr -> . expr LEQ expr
    (62) expr -> . expr > expr
    (63) expr -> . expr GEQ expr
    (64) expr -> . expr = expr
    (65) expr -> . expr NEQ expr
    (66) expr -> . expr + expr
    (67) expr -> . expr - expr
    (68) expr -> . expr * expr
    (69) expr -> . expr / expr
    (70) expr -> . expr % expr
    (71) expr -> . ! expr
    (72) expr -> . + expr
    (73) expr -> . - expr
    (74) expr -> . INTCONST
    (75) expr -> . designator
    (76) expr -> . ID actuals
    (77) expr -> . ISUNDEFINED ( designator )
    (78) expr -> . ( expr )
    (79) expr -> . FORALL quantifiers DO expr END
    (80) expr -> . EXISTS quantifiers DO expr END
    (53) designator -> . ID
    (54) designator -> . designator [ expr ]
    (55) designator -> . designator . ID

    !               shift and go to state 60
    +               shift and go to state 58
    -               shift and go to state 59
    INTCONST        shift and go to state 61
    ID              shift and go to state 63
    ISUNDEFINED     shift and go to state 64
    (               shift and go to state 65
    FORALL          shift and go to state 66
    EXISTS          shift and go to state 67

    expr                           shift and go to state 216
    designator                     shift and go to state 62

state 157

    (113) switchstmt -> SWITCH . expr optcases optelse END
    (56) expr -> . expr ? expr : expr
    (57) expr -> . expr IMPLIES expr
    (58) expr -> . expr | expr
    (59) expr -> . expr & expr
    (60) expr -> . expr < expr
    (61) expr -> . expr LEQ expr
    (62) expr -> . expr > expr
    (63) expr -> . expr GEQ expr
    (64) expr -> . expr = expr
    (65) expr -> . expr NEQ expr
    (66) expr -> . expr + expr
    (67) expr -> . expr - expr
    (68) expr -> . expr * expr
    (69) expr -> . expr / expr
    (70) expr -> . expr % expr
    (71) expr -> . ! expr
    (72) expr -> . + expr
    (73) expr -> . - expr
    (74) expr -> . INTCONST
    (75) expr -> . designator
    (76) expr -> . ID actuals
    (77) expr -> . ISUNDEFINED ( designator )
    (78) expr -> . ( expr )
    (79) expr -> . FORALL quantifiers DO expr END
    (80) expr -> . EXISTS quantifiers DO expr END
    (53) designator -> . ID
    (54) designator -> . designator [ expr ]
    (55) designator -> . designator . ID

    !               shift and go to state 60
    +               shift and go to state 58
    -               shift and go to state 59
    INTCONST        shift and go to state 61
    ID              shift and go to state 63
    ISUNDEFINED     shift and go to state 64
    (               shift and go to state 65
    FORALL          shift and go to state 66
    EXISTS          shift and go to state 67

    expr                           shift and go to state 217
    designator                     shift and go to state 62

state 158

    (117) forstmt -> FOR . quantifiers DO optstmts END
    (86) quantifiers -> . quantifier ; quantifiers
    (87) quantifiers -> . quantifier
    (85) quantifier -> . ID : typeexpr

    ID              shift and go to state 43

    quantifiers                    shift and go to state 218
    quantifier                     shift and go to state 42

state 159

    (118) proccall -> ID . actuals
    (53) designator -> ID .
    (81) actuals -> . ( exprlist )
    (82) actuals -> . ( )

    ASSIGN          reduce using rule 53 (designator -> ID .)
    [               reduce using rule 53 (designator -> ID .)
    .               reduce using rule 53 (designator -> ID .)
    (               shift and go to state 117

    actuals                        shift and go to state 219

state 160

    (119) clearstmt -> CLEAR . designator
    (53) designator -> . ID
    (54) designator -> . designator [ expr ]
    (55) designator -> . designator . ID

    ID              shift and go to state 200

    designator                     shift and go to state 220

state 161

    (121) errorstmt -> ERROR . STRING

    STRING          shift and go to state 221


state 162

    (122) assertstmt -> ASSERT . expr optstring
    (56) expr -> . expr ? expr : expr
    (57) expr -> . expr IMPLIES expr
    (58) expr -> . expr | expr
    (59) expr -> . expr & expr
    (60) expr -> . expr < expr
    (61) expr -> . expr LEQ expr
    (62) expr -> . expr > expr
    (63) expr -> . expr GEQ expr
    (64) expr -> . expr = expr
    (65) expr -> . expr NEQ expr
    (66) expr -> . expr + expr
    (67) expr -> . expr - expr
    (68) expr -> . expr * expr
    (69) expr -> . expr / expr
    (70) expr -> . expr % expr
    (71) expr -> . ! expr
    (72) expr -> . + expr
    (73) expr -> . - expr
    (74) expr -> . INTCONST
    (75) expr -> . designator
    (76) expr -> . ID actuals
    (77) expr -> . ISUNDEFINED ( designator )
    (78) expr -> . ( expr )
    (79) expr -> . FORALL quantifiers DO expr END
    (80) expr -> . EXISTS quantifiers DO expr END
    (53) designator -> . ID
    (54) designator -> . designator [ expr ]
    (55) designator -> . designator . ID

    !               shift and go to state 60
    +               shift and go to state 58
    -               shift and go to state 59
    INTCONST        shift and go to state 61
    ID              shift and go to state 63
    ISUNDEFINED     shift and go to state 64
    (               shift and go to state 65
    FORALL          shift and go to state 66
    EXISTS          shift and go to state 67

    expr                           shift and go to state 222
    designator                     shift and go to state 62

state 163

    (123) aliasstmt -> ALIAS . aliases DO optstmts END
    (124) aliases -> . aliases ; alias
    (125) aliases -> . aliases ;
    (126) aliases -> . alias
    (127) alias -> . ID : expr

    ID              shift and go to state 40

    aliases                        shift and go to state 223
    alias                          shift and go to state 39

state 164

    (128) returnstmt -> RETURN . optretexpr
    (129) optretexpr -> . expr
    (130) optretexpr -> . empty
    (56) expr -> . expr ? expr : expr
    (57) expr -> . expr IMPLIES expr
    (58) expr -> . expr | expr
    (59) expr -> . expr & expr
    (60) expr -> . expr < expr
    (61) expr -> . expr LEQ expr
    (62) expr -> . expr > expr
    (63) expr -> . expr GEQ expr
    (64) expr -> . expr = expr
    (65) expr -> . expr NEQ expr
    (66) expr -> . expr + expr
    (67) expr -> . expr - expr
    (68) expr -> . expr * expr
    (69) expr -> . expr / expr
    (70) expr -> . expr % expr
    (71) expr -> . ! expr
    (72) expr -> . + expr
    (73) expr -> . - expr
    (74) expr -> . INTCONST
    (75) expr -> . designator
    (76) expr -> . ID actuals
    (77) expr -> . ISUNDEFINED ( designator )
    (78) expr -> . ( expr )
    (79) expr -> . FORALL quantifiers DO expr END
    (80) expr -> . EXISTS quantifiers DO expr END
    (148) empty -> .
    (53) designator -> . ID
    (54) designator -> . designator [ expr ]
    (55) designator -> . designator . ID

    !               shift and go to state 60
    +               shift and go to state 58
    -               shift and go to state 59
    INTCONST        shift and go to state 61
    ID              shift and go to state 63
    ISUNDEFINED     shift and go to state 64
    (               shift and go to state 65
    FORALL          shift and go to state 66
    EXISTS          shift and go to state 67
    ;               reduce using rule 148 (empty -> .)
    END             reduce using rule 148 (empty -> .)
    ELSIF           reduce using rule 148 (empty -> .)
    ELSE            reduce using rule 148 (empty -> .)
    CASE            reduce using rule 148 (empty -> .)

    optretexpr                     shift and go to state 224
    expr                           shift and go to state 225
    empty                          shift and go to state 226
    designator                     shift and go to state 62

state 165

    (120) undefinestmt -> UNDEFINE . designator
    (53) designator -> . ID
    (54) designator -> . designator [ expr ]
    (55) designator -> . designator . ID

    ID              shift and go to state 200

    designator                     shift and go to state 227

state 166

    (51) optdecls -> decls BEGIN .

    IF              reduce using rule 51 (optdecls -> decls BEGIN .)
    WHILE           reduce using rule 51 (optdecls -> decls BEGIN .)
    SWITCH          reduce using rule 51 (optdecls -> decls BEGIN .)
    FOR             reduce using rule 51 (optdecls -> decls BEGIN .)
    ID              reduce using rule 51 (optdecls -> decls BEGIN .)
    CLEAR           reduce using rule 51 (optdecls -> decls BEGIN .)
    ERROR           reduce using rule 51 (optdecls -> decls BEGIN .)
    ASSERT          reduce using rule 51 (optdecls -> decls BEGIN .)
    ALIAS           reduce using rule 51 (optdecls -> decls BEGIN .)
    RETURN          reduce using rule 51 (optdecls -> decls BEGIN .)
    UNDEFINE        reduce using rule 51 (optdecls -> decls BEGIN .)
    END             reduce using rule 51 (optdecls -> decls BEGIN .)


state 167

    (9) constdecl -> ID : expr .
    (56) expr -> expr . ? expr : expr
    (57) expr -> expr . IMPLIES expr
    (58) expr -> expr . | expr
    (59) expr -> expr . & expr
    (60) expr -> expr . < expr
    (61) expr -> expr . LEQ expr
    (62) expr -> expr . > expr
    (63) expr -> expr . GEQ expr
    (64) expr -> expr . = expr
    (65) expr -> expr . NEQ expr
    (66) expr -> expr . + expr
    (67) expr -> expr . - expr
    (68) expr -> expr . * expr
    (69) expr -> expr . / expr
    (70) expr -> expr . % expr

    ;               reduce using rule 9 (constdecl -> ID : expr .)
    ?               shift and go to state 96
    IMPLIES         shift and go to state 97
    |               shift and go to state 98
    &               shift and go to state 99
    <               shift and go to state 100
    LEQ             shift and go to state 101
    >               shift and go to state 102
    GEQ             shift and go to state 103
    =               shift and go to state 104
    NEQ             shift and go to state 105
    +               shift and go to state 106
    -               shift and go to state 107
    *               shift and go to state 108
    /               shift and go to state 109
    %               shift and go to state 110


state 168

    (12) typedecl -> ID : typeexpr .

    ;               reduce using rule 12 (typedecl -> ID : typeexpr .)


state 169

    (34) vardecltail -> , ID . vardecltail
    (34) vardecltail -> . , ID vardecltail
    (35) vardecltail -> . : typeexpr

    ,               shift and go to state 84
    :               shift and go to state 85

    vardecltail                    shift and go to state 228

state 170

    (35) vardecltail -> : typeexpr .

    ;               reduce using rule 35 (vardecltail -> : typeexpr .)


state 171

    (48) formalrest -> ID formaltail .

    ;               reduce using rule 48 (formalrest -> ID formaltail .)
    )               reduce using rule 48 (formalrest -> ID formaltail .)


state 172

    (49) formaltail -> , . ID formaltail

    ID              shift and go to state 229


state 173

    (50) formaltail -> : . typeexpr
    (13) typeexpr -> . typeid
    (14) typeexpr -> . enumtype
    (15) typeexpr -> . subrangetype
    (16) typeexpr -> . recordtype
    (17) typeexpr -> . arraytype
    (18) typeid -> . ID
    (19) enumtype -> . ENUM { enums }
    (22) subrangetype -> . expr DOTDOT expr
    (23) recordtype -> . RECORD fields END
    (30) arraytype -> . ARRAY [ typeexpr ] OF typeexpr
    (56) expr -> . expr ? expr : expr
    (57) expr -> . expr IMPLIES expr
    (58) expr -> . expr | expr
    (59) expr -> . expr & expr
    (60) expr -> . expr < expr
    (61) expr -> . expr LEQ expr
    (62) expr -> . expr > expr
    (63) expr -> . expr GEQ expr
    (64) expr -> . expr = expr
    (65) expr -> . expr NEQ expr
    (66) expr -> . expr + expr
    (67) expr -> . expr - expr
    (68) expr -> . expr * expr
    (69) expr -> . expr / expr
    (70) expr -> . expr % expr
    (71) expr -> . ! expr
    (72) expr -> . + expr
    (73) expr -> . - expr
    (74) expr -> . INTCONST
    (75) expr -> . designator
    (76) expr -> . ID actuals
    (77) expr -> . ISUNDEFINED ( designator )
    (78) expr -> . ( expr )
    (79) expr -> . FORALL quantifiers DO expr END
    (80) expr -> . EXISTS quantifiers DO expr END
    (53) designator -> . ID
    (54) designator -> . designator [ expr ]
    (55) designator -> . designator . ID

    ID              shift and go to state 127
    ENUM            shift and go to state 134
    RECORD          shift and go to state 136
    ARRAY           shift and go to state 137
    !               shift and go to state 60
    +               shift and go to state 58
    -               shift and go to state 59
    INTCONST        shift and go to state 61
    ISUNDEFINED     shift and go to state 64
    (               shift and go to state 65
    FORALL          shift and go to state 66
    EXISTS          shift and go to state 67

    typeexpr                       shift and go to state 230
    typeid                         shift and go to state 129
    enumtype                       shift and go to state 130
    subrangetype                   shift and go to state 131
    recordtype                     shift and go to state 132
    arraytype                      shift and go to state 133
    expr                           shift and go to state 135
    designator                     shift and go to state 62

state 174

    (39) procdecl -> PROCEDURE ID ( optformals ) . ; optdecls optstmts END ;

    ;               shift and go to state 231


state 175

    (43) formals -> formals ; . formal
    (44) formals -> formals ; .
    (46) formal -> . VAR formalrest
    (47) formal -> . formalrest
    (48) formalrest -> . ID formaltail

    ;               reduce using rule 44 (formals -> formals ; .)
    )               reduce using rule 44 (formals -> formals ; .)
    VAR             shift and go to state 91
    ID              shift and go to state 86

    formal                         shift and go to state 232
    formalrest                     shift and go to state 92

state 176

    (46) formal -> VAR formalrest .

    ;               reduce using rule 46 (formal -> VAR formalrest .)
    )               reduce using rule 46 (formal -> VAR formalrest .)


state 177

    (40) funcdecl -> FUNCTION ID ( optformals ) . : typeexpr ; optdecls optstmts END ;

    :               shift and go to state 233


state 178

    (139) simplerule -> RULE optstring optcondition optdecls optstmts . END

    END             shift and go to state 234


state 179

    (56) expr -> expr ? expr . : expr
    (56) expr -> expr . ? expr : expr
    (57) expr -> expr . IMPLIES expr
    (58) expr -> expr . | expr
    (59) expr -> expr . & expr
    (60) expr -> expr . < expr
    (61) expr -> expr . LEQ expr
    (62) expr -> expr . > expr
    (63) expr -> expr . GEQ expr
    (64) expr -> expr . = expr
    (65) expr -> expr . NEQ expr
    (66) expr -> expr . + expr
    (67) expr -> expr . - expr
    (68) expr -> expr . * expr
    (69) expr -> expr . / expr
    (70) expr -> expr . % expr

    :               shift and go to state 235
    ?               shift and go to state 96
    IMPLIES         shift and go to state 97
    |               shift and go to state 98
    &               shift and go to state 99
    <               shift and go to state 100
    LEQ             shift and go to state 101
    >               shift and go to state 102
    GEQ             shift and go to state 103
    =               shift and go to state 104
    NEQ             shift and go to state 105
    +               shift and go to state 106
    -               shift and go to state 107
    *               shift and go to state 108
    /               shift and go to state 109
    %               shift and go to state 110


state 180

    (57) expr -> expr IMPLIES expr .
    (56) expr -> expr . ? expr : expr
    (57) expr -> expr . IMPLIES expr
    (58) expr -> expr . | expr
    (59) expr -> expr . & expr
    (60) expr -> expr . < expr
    (61) expr -> expr . LEQ expr
    (62) expr -> expr . > expr
    (63) expr -> expr . GEQ expr
    (64) expr -> expr . = expr
    (65) expr -> expr . NEQ expr
    (66) expr -> expr . + expr
    (67) expr -> expr . - expr
    (68) expr -> expr . * expr
    (69) expr -> expr . / expr
    (70) expr -> expr . % expr

    LONGARROW       reduce using rule 57 (expr -> expr IMPLIES expr .)
    ?               reduce using rule 57 (expr -> expr IMPLIES expr .)
    IMPLIES         reduce using rule 57 (expr -> expr IMPLIES expr .)
    ;               reduce using rule 57 (expr -> expr IMPLIES expr .)
    $end            reduce using rule 57 (expr -> expr IMPLIES expr .)
    END             reduce using rule 57 (expr -> expr IMPLIES expr .)
    )               reduce using rule 57 (expr -> expr IMPLIES expr .)
    DO              reduce using rule 57 (expr -> expr IMPLIES expr .)
    DOTDOT          reduce using rule 57 (expr -> expr IMPLIES expr .)
    :               reduce using rule 57 (expr -> expr IMPLIES expr .)
    ]               reduce using rule 57 (expr -> expr IMPLIES expr .)
    ,               reduce using rule 57 (expr -> expr IMPLIES expr .)
    THEN            reduce using rule 57 (expr -> expr IMPLIES expr .)
    ELSE            reduce using rule 57 (expr -> expr IMPLIES expr .)
    CASE            reduce using rule 57 (expr -> expr IMPLIES expr .)
    STRING          reduce using rule 57 (expr -> expr IMPLIES expr .)
    ELSIF           reduce using rule 57 (expr -> expr IMPLIES expr .)
    |               shift and go to state 98
    &               shift and go to state 99
    <               shift and go to state 100
    LEQ             shift and go to state 101
    >               shift and go to state 102
    GEQ             shift and go to state 103
    =               shift and go to state 104
    NEQ             shift and go to state 105
    +               shift and go to state 106
    -               shift and go to state 107
    *               shift and go to state 108
    /               shift and go to state 109
    %               shift and go to state 110

  ! |               [ reduce using rule 57 (expr -> expr IMPLIES expr .) ]
  ! &               [ reduce using rule 57 (expr -> expr IMPLIES expr .) ]
  ! <               [ reduce using rule 57 (expr -> expr IMPLIES expr .) ]
  ! LEQ             [ reduce using rule 57 (expr -> expr IMPLIES expr .) ]
  ! >               [ reduce using rule 57 (expr -> expr IMPLIES expr .) ]
  ! GEQ             [ reduce using rule 57 (expr -> expr IMPLIES expr .) ]
  ! =               [ reduce using rule 57 (expr -> expr IMPLIES expr .) ]
  ! NEQ             [ reduce using rule 57 (expr -> expr IMPLIES expr .) ]
  ! +               [ reduce using rule 57 (expr -> expr IMPLIES expr .) ]
  ! -               [ reduce using rule 57 (expr -> expr IMPLIES expr .) ]
  ! *               [ reduce using rule 57 (expr -> expr IMPLIES expr .) ]
  ! /               [ reduce using rule 57 (expr -> expr IMPLIES expr .) ]
  ! %               [ reduce using rule 57 (expr -> expr IMPLIES expr .) ]
  ! ?               [ shift and go to state 96 ]
  ! IMPLIES         [ shift and go to state 97 ]


state 181

    (58) expr -> expr | expr .
    (56) expr -> expr . ? expr : expr
    (57) expr -> expr . IMPLIES expr
    (58) expr -> expr . | expr
    (59) expr -> expr . & expr
    (60) expr -> expr . < expr
    (61) expr -> expr . LEQ expr
    (62) expr -> expr . > expr
    (63) expr -> expr . GEQ expr
    (64) expr -> expr . = expr
    (65) expr -> expr . NEQ expr
    (66) expr -> expr . + expr
    (67) expr -> expr . - expr
    (68) expr -> expr . * expr
    (69) expr -> expr . / expr
    (70) expr -> expr . % expr

    LONGARROW       reduce using rule 58 (expr -> expr | expr .)
    ?               reduce using rule 58 (expr -> expr | expr .)
    IMPLIES         reduce using rule 58 (expr -> expr | expr .)
    |               reduce using rule 58 (expr -> expr | expr .)
    ;               reduce using rule 58 (expr -> expr | expr .)
    $end            reduce using rule 58 (expr -> expr | expr .)
    END             reduce using rule 58 (expr -> expr | expr .)
    )               reduce using rule 58 (expr -> expr | expr .)
    DO              reduce using rule 58 (expr -> expr | expr .)
    DOTDOT          reduce using rule 58 (expr -> expr | expr .)
    :               reduce using rule 58 (expr -> expr | expr .)
    ]               reduce using rule 58 (expr -> expr | expr .)
    ,               reduce using rule 58 (expr -> expr | expr .)
    THEN            reduce using rule 58 (expr -> expr | expr .)
    ELSE            reduce using rule 58 (expr -> expr | expr .)
    CASE            reduce using rule 58 (expr -> expr | expr .)
    STRING          reduce using rule 58 (expr -> expr | expr .)
    ELSIF           reduce using rule 58 (expr -> expr | expr .)
    &               shift and go to state 99
    <               shift and go to state 100
    LEQ             shift and go to state 101
    >               shift and go to state 102
    GEQ             shift and go to state 103
    =               shift and go to state 104
    NEQ             shift and go to state 105
    +               shift and go to state 106
    -               shift and go to state 107
    *               shift and go to state 108
    /               shift and go to state 109
    %               shift and go to state 110

  ! &               [ reduce using rule 58 (expr -> expr | expr .) ]
  ! <               [ reduce using rule 58 (expr -> expr | expr .) ]
  ! LEQ             [ reduce using rule 58 (expr -> expr | expr .) ]
  ! >               [ reduce using rule 58 (expr -> expr | expr .) ]
  ! GEQ             [ reduce using rule 58 (expr -> expr | expr .) ]
  ! =               [ reduce using rule 58 (expr -> expr | expr .) ]
  ! NEQ             [ reduce using rule 58 (expr -> expr | expr .) ]
  ! +               [ reduce using rule 58 (expr -> expr | expr .) ]
  ! -               [ reduce using rule 58 (expr -> expr | expr .) ]
  ! *               [ reduce using rule 58 (expr -> expr | expr .) ]
  ! /               [ reduce using rule 58 (expr -> expr | expr .) ]
  ! %               [ reduce using rule 58 (expr -> expr | expr .) ]
  ! ?               [ shift and go to state 96 ]
  ! IMPLIES         [ shift and go to state 97 ]
  ! |               [ shift and go to state 98 ]


state 182

    (59) expr -> expr & expr .
    (56) expr -> expr . ? expr : expr
    (57) expr -> expr . IMPLIES expr
    (58) expr -> expr . | expr
    (59) expr -> expr . & expr
    (60) expr -> expr . < expr
    (61) expr -> expr . LEQ expr
    (62) expr -> expr . > expr
    (63) expr -> expr . GEQ expr
    (64) expr -> expr . = expr
    (65) expr -> expr . NEQ expr
    (66) expr -> expr . + expr
    (67) expr -> expr . - expr
    (68) expr -> expr . * expr
    (69) expr -> expr . / expr
    (70) expr -> expr . % expr

    LONGARROW       reduce using rule 59 (expr -> expr & expr .)
    ?               reduce using rule 59 (expr -> expr & expr .)
    IMPLIES         reduce using rule 59 (expr -> expr & expr .)
    |               reduce using rule 59 (expr -> expr & expr .)
    &               reduce using rule 59 (expr -> expr & expr .)
    ;               reduce using rule 59 (expr -> expr & expr .)
    $end            reduce using rule 59 (expr -> expr & expr .)
    END             reduce using rule 59 (expr -> expr & expr .)
    )               reduce using rule 59 (expr -> expr & expr .)
    DO              reduce using rule 59 (expr -> expr & expr .)
    DOTDOT          reduce using rule 59 (expr -> expr & expr .)
    :               reduce using rule 59 (expr -> expr & expr .)
    ]               reduce using rule 59 (expr -> expr & expr .)
    ,               reduce using rule 59 (expr -> expr & expr .)
    THEN            reduce using rule 59 (expr -> expr & expr .)
    ELSE            reduce using rule 59 (expr -> expr & expr .)
    CASE            reduce using rule 59 (expr -> expr & expr .)
    STRING          reduce using rule 59 (expr -> expr & expr .)
    ELSIF           reduce using rule 59 (expr -> expr & expr .)
    <               shift and go to state 100
    LEQ             shift and go to state 101
    >               shift and go to state 102
    GEQ             shift and go to state 103
    =               shift and go to state 104
    NEQ             shift and go to state 105
    +               shift and go to state 106
    -               shift and go to state 107
    *               shift and go to state 108
    /               shift and go to state 109
    %               shift and go to state 110

  ! <               [ reduce using rule 59 (expr -> expr & expr .) ]
  ! LEQ             [ reduce using rule 59 (expr -> expr & expr .) ]
  ! >               [ reduce using rule 59 (expr -> expr & expr .) ]
  ! GEQ             [ reduce using rule 59 (expr -> expr & expr .) ]
  ! =               [ reduce using rule 59 (expr -> expr & expr .) ]
  ! NEQ             [ reduce using rule 59 (expr -> expr & expr .) ]
  ! +               [ reduce using rule 59 (expr -> expr & expr .) ]
  ! -               [ reduce using rule 59 (expr -> expr & expr .) ]
  ! *               [ reduce using rule 59 (expr -> expr & expr .) ]
  ! /               [ reduce using rule 59 (expr -> expr & expr .) ]
  ! %               [ reduce using rule 59 (expr -> expr & expr .) ]
  ! ?               [ shift and go to state 96 ]
  ! IMPLIES         [ shift and go to state 97 ]
  ! |               [ shift and go to state 98 ]
  ! &               [ shift and go to state 99 ]


state 183

    (60) expr -> expr < expr .
    (56) expr -> expr . ? expr : expr
    (57) expr -> expr . IMPLIES expr
    (58) expr -> expr . | expr
    (59) expr -> expr . & expr
    (60) expr -> expr . < expr
    (61) expr -> expr . LEQ expr
    (62) expr -> expr . > expr
    (63) expr -> expr . GEQ expr
    (64) expr -> expr . = expr
    (65) expr -> expr . NEQ expr
    (66) expr -> expr . + expr
    (67) expr -> expr . - expr
    (68) expr -> expr . * expr
    (69) expr -> expr . / expr
    (70) expr -> expr . % expr

    LONGARROW       reduce using rule 60 (expr -> expr < expr .)
    ?               reduce using rule 60 (expr -> expr < expr .)
    IMPLIES         reduce using rule 60 (expr -> expr < expr .)
    |               reduce using rule 60 (expr -> expr < expr .)
    &               reduce using rule 60 (expr -> expr < expr .)
    <               reduce using rule 60 (expr -> expr < expr .)
    LEQ             reduce using rule 60 (expr -> expr < expr .)
    >               reduce using rule 60 (expr -> expr < expr .)
    GEQ             reduce using rule 60 (expr -> expr < expr .)
    =               reduce using rule 60 (expr -> expr < expr .)
    NEQ             reduce using rule 60 (expr -> expr < expr .)
    ;               reduce using rule 60 (expr -> expr < expr .)
    $end            reduce using rule 60 (expr -> expr < expr .)
    END             reduce using rule 60 (expr -> expr < expr .)
    )               reduce using rule 60 (expr -> expr < expr .)
    DO              reduce using rule 60 (expr -> expr < expr .)
    DOTDOT          reduce using rule 60 (expr -> expr < expr .)
    :               reduce using rule 60 (expr -> expr < expr .)
    ]               reduce using rule 60 (expr -> expr < expr .)
    ,               reduce using rule 60 (expr -> expr < expr .)
    THEN            reduce using rule 60 (expr -> expr < expr .)
    ELSE            reduce using rule 60 (expr -> expr < expr .)
    CASE            reduce using rule 60 (expr -> expr < expr .)
    STRING          reduce using rule 60 (expr -> expr < expr .)
    ELSIF           reduce using rule 60 (expr -> expr < expr .)
    +               shift and go to state 106
    -               shift and go to state 107
    *               shift and go to state 108
    /               shift and go to state 109
    %               shift and go to state 110

  ! +               [ reduce using rule 60 (expr -> expr < expr .) ]
  ! -               [ reduce using rule 60 (expr -> expr < expr .) ]
  ! *               [ reduce using rule 60 (expr -> expr < expr .) ]
  ! /               [ reduce using rule 60 (expr -> expr < expr .) ]
  ! %               [ reduce using rule 60 (expr -> expr < expr .) ]
  ! ?               [ shift and go to state 96 ]
  ! IMPLIES         [ shift and go to state 97 ]
  ! |               [ shift and go to state 98 ]
  ! &               [ shift and go to state 99 ]
  ! <               [ shift and go to state 100 ]
  ! LEQ             [ shift and go to state 101 ]
  ! >               [ shift and go to state 102 ]
  ! GEQ             [ shift and go to state 103 ]
  ! =               [ shift and go to state 104 ]
  ! NEQ             [ shift and go to state 105 ]


state 184

    (61) expr -> expr LEQ expr .
    (56) expr -> expr . ? expr : expr
    (57) expr -> expr . IMPLIES expr
    (58) expr -> expr . | expr
    (59) expr -> expr . & expr
    (60) expr -> expr . < expr
    (61) expr -> expr . LEQ expr
    (62) expr -> expr . > expr
    (63) expr -> expr . GEQ expr
    (64) expr -> expr . = expr
    (65) expr -> expr . NEQ expr
    (66) expr -> expr . + expr
    (67) expr -> expr . - expr
    (68) expr -> expr . * expr
    (69) expr -> expr . / expr
    (70) expr -> expr . % expr

    LONGARROW       reduce using rule 61 (expr -> expr LEQ expr .)
    ?               reduce using rule 61 (expr -> expr LEQ expr .)
    IMPLIES         reduce using rule 61 (expr -> expr LEQ expr .)
    |               reduce using rule 61 (expr -> expr LEQ expr .)
    &               reduce using rule 61 (expr -> expr LEQ expr .)
    <               reduce using rule 61 (expr -> expr LEQ expr .)
    LEQ             reduce using rule 61 (expr -> expr LEQ expr .)
    >               reduce using rule 61 (expr -> expr LEQ expr .)
    GEQ             reduce using rule 61 (expr -> expr LEQ expr .)
    =               reduce using rule 61 (expr -> expr LEQ expr .)
    NEQ             reduce using rule 61 (expr -> expr LEQ expr .)
    ;               reduce using rule 61 (expr -> expr LEQ expr .)
    $end            reduce using rule 61 (expr -> expr LEQ expr .)
    END             reduce using rule 61 (expr -> expr LEQ expr .)
    )               reduce using rule 61 (expr -> expr LEQ expr .)
    DO              reduce using rule 61 (expr -> expr LEQ expr .)
    DOTDOT          reduce using rule 61 (expr -> expr LEQ expr .)
    :               reduce using rule 61 (expr -> expr LEQ expr .)
    ]               reduce using rule 61 (expr -> expr LEQ expr .)
    ,               reduce using rule 61 (expr -> expr LEQ expr .)
    THEN            reduce using rule 61 (expr -> expr LEQ expr .)
    ELSE            reduce using rule 61 (expr -> expr LEQ expr .)
    CASE            reduce using rule 61 (expr -> expr LEQ expr .)
    STRING          reduce using rule 61 (expr -> expr LEQ expr .)
    ELSIF           reduce using rule 61 (expr -> expr LEQ expr .)
    +               shift and go to state 106
    -               shift and go to state 107
    *               shift and go to state 108
    /               shift and go to state 109
    %               shift and go to state 110

  ! +               [ reduce using rule 61 (expr -> expr LEQ expr .) ]
  ! -               [ reduce using rule 61 (expr -> expr LEQ expr .) ]
  ! *               [ reduce using rule 61 (expr -> expr LEQ expr .) ]
  ! /               [ reduce using rule 61 (expr -> expr LEQ expr .) ]
  ! %               [ reduce using rule 61 (expr -> expr LEQ expr .) ]
  ! ?               [ shift and go to state 96 ]
  ! IMPLIES         [ shift and go to state 97 ]
  ! |               [ shift and go to state 98 ]
  ! &               [ shift and go to state 99 ]
  ! <               [ shift and go to state 100 ]
  ! LEQ             [ shift and go to state 101 ]
  ! >               [ shift and go to state 102 ]
  ! GEQ             [ shift and go to state 103 ]
  ! =               [ shift and go to state 104 ]
  ! NEQ             [ shift and go to state 105 ]


state 185

    (62) expr -> expr > expr .
    (56) expr -> expr . ? expr : expr
    (57) expr -> expr . IMPLIES expr
    (58) expr -> expr . | expr
    (59) expr -> expr . & expr
    (60) expr -> expr . < expr
    (61) expr -> expr . LEQ expr
    (62) expr -> expr . > expr
    (63) expr -> expr . GEQ expr
    (64) expr -> expr . = expr
    (65) expr -> expr . NEQ expr
    (66) expr -> expr . + expr
    (67) expr -> expr . - expr
    (68) expr -> expr . * expr
    (69) expr -> expr . / expr
    (70) expr -> expr . % expr

    LONGARROW       reduce using rule 62 (expr -> expr > expr .)
    ?               reduce using rule 62 (expr -> expr > expr .)
    IMPLIES         reduce using rule 62 (expr -> expr > expr .)
    |               reduce using rule 62 (expr -> expr > expr .)
    &               reduce using rule 62 (expr -> expr > expr .)
    <               reduce using rule 62 (expr -> expr > expr .)
    LEQ             reduce using rule 62 (expr -> expr > expr .)
    >               reduce using rule 62 (expr -> expr > expr .)
    GEQ             reduce using rule 62 (expr -> expr > expr .)
    =               reduce using rule 62 (expr -> expr > expr .)
    NEQ             reduce using rule 62 (expr -> expr > expr .)
    ;               reduce using rule 62 (expr -> expr > expr .)
    $end            reduce using rule 62 (expr -> expr > expr .)
    END             reduce using rule 62 (expr -> expr > expr .)
    )               reduce using rule 62 (expr -> expr > expr .)
    DO              reduce using rule 62 (expr -> expr > expr .)
    DOTDOT          reduce using rule 62 (expr -> expr > expr .)
    :               reduce using rule 62 (expr -> expr > expr .)
    ]               reduce using rule 62 (expr -> expr > expr .)
    ,               reduce using rule 62 (expr -> expr > expr .)
    THEN            reduce using rule 62 (expr -> expr > expr .)
    ELSE            reduce using rule 62 (expr -> expr > expr .)
    CASE            reduce using rule 62 (expr -> expr > expr .)
    STRING          reduce using rule 62 (expr -> expr > expr .)
    ELSIF           reduce using rule 62 (expr -> expr > expr .)
    +               shift and go to state 106
    -               shift and go to state 107
    *               shift and go to state 108
    /               shift and go to state 109
    %               shift and go to state 110

  ! +               [ reduce using rule 62 (expr -> expr > expr .) ]
  ! -               [ reduce using rule 62 (expr -> expr > expr .) ]
  ! *               [ reduce using rule 62 (expr -> expr > expr .) ]
  ! /               [ reduce using rule 62 (expr -> expr > expr .) ]
  ! %               [ reduce using rule 62 (expr -> expr > expr .) ]
  ! ?               [ shift and go to state 96 ]
  ! IMPLIES         [ shift and go to state 97 ]
  ! |               [ shift and go to state 98 ]
  ! &               [ shift and go to state 99 ]
  ! <               [ shift and go to state 100 ]
  ! LEQ             [ shift and go to state 101 ]
  ! >               [ shift and go to state 102 ]
  ! GEQ             [ shift and go to state 103 ]
  ! =               [ shift and go to state 104 ]
  ! NEQ             [ shift and go to state 105 ]


state 186

    (63) expr -> expr GEQ expr .
    (56) expr -> expr . ? expr : expr
    (57) expr -> expr . IMPLIES expr
    (58) expr -> expr . | expr
    (59) expr -> expr . & expr
    (60) expr -> expr . < expr
    (61) expr -> expr . LEQ expr
    (62) expr -> expr . > expr
    (63) expr -> expr . GEQ expr
    (64) expr -> expr . = expr
    (65) expr -> expr . NEQ expr
    (66) expr -> expr . + expr
    (67) expr -> expr . - expr
    (68) expr -> expr . * expr
    (69) expr -> expr . / expr
    (70) expr -> expr . % expr

    LONGARROW       reduce using rule 63 (expr -> expr GEQ expr .)
    ?               reduce using rule 63 (expr -> expr GEQ expr .)
    IMPLIES         reduce using rule 63 (expr -> expr GEQ expr .)
    |               reduce using rule 63 (expr -> expr GEQ expr .)
    &               reduce using rule 63 (expr -> expr GEQ expr .)
    <               reduce using rule 63 (expr -> expr GEQ expr .)
    LEQ             reduce using rule 63 (expr -> expr GEQ expr .)
    >               reduce using rule 63 (expr -> expr GEQ expr .)
    GEQ             reduce using rule 63 (expr -> expr GEQ expr .)
    =               reduce using rule 63 (expr -> expr GEQ expr .)
    NEQ             reduce using rule 63 (expr -> expr GEQ expr .)
    ;               reduce using rule 63 (expr -> expr GEQ expr .)
    $end            reduce using rule 63 (expr -> expr GEQ expr .)
    END             reduce using rule 63 (expr -> expr GEQ expr .)
    )               reduce using rule 63 (expr -> expr GEQ expr .)
    DO              reduce using rule 63 (expr -> expr GEQ expr .)
    DOTDOT          reduce using rule 63 (expr -> expr GEQ expr .)
    :               reduce using rule 63 (expr -> expr GEQ expr .)
    ]               reduce using rule 63 (expr -> expr GEQ expr .)
    ,               reduce using rule 63 (expr -> expr GEQ expr .)
    THEN            reduce using rule 63 (expr -> expr GEQ expr .)
    ELSE            reduce using rule 63 (expr -> expr GEQ expr .)
    CASE            reduce using rule 63 (expr -> expr GEQ expr .)
    STRING          reduce using rule 63 (expr -> expr GEQ expr .)
    ELSIF           reduce using rule 63 (expr -> expr GEQ expr .)
    +               shift and go to state 106
    -               shift and go to state 107
    *               shift and go to state 108
    /               shift and go to state 109
    %               shift and go to state 110

  ! +               [ reduce using rule 63 (expr -> expr GEQ expr .) ]
  ! -               [ reduce using rule 63 (expr -> expr GEQ expr .) ]
  ! *               [ reduce using rule 63 (expr -> expr GEQ expr .) ]
  ! /               [ reduce using rule 63 (expr -> expr GEQ expr .) ]
  ! %               [ reduce using rule 63 (expr -> expr GEQ expr .) ]
  ! ?               [ shift and go to state 96 ]
  ! IMPLIES         [ shift and go to state 97 ]
  ! |               [ shift and go to state 98 ]
  ! &               [ shift and go to state 99 ]
  ! <               [ shift and go to state 100 ]
  ! LEQ             [ shift and go to state 101 ]
  ! >               [ shift and go to state 102 ]
  ! GEQ             [ shift and go to state 103 ]
  ! =               [ shift and go to state 104 ]
  ! NEQ             [ shift and go to state 105 ]


state 187

    (64) expr -> expr = expr .
    (56) expr -> expr . ? expr : expr
    (57) expr -> expr . IMPLIES expr
    (58) expr -> expr . | expr
    (59) expr -> expr . & expr
    (60) expr -> expr . < expr
    (61) expr -> expr . LEQ expr
    (62) expr -> expr . > expr
    (63) expr -> expr . GEQ expr
    (64) expr -> expr . = expr
    (65) expr -> expr . NEQ expr
    (66) expr -> expr . + expr
    (67) expr -> expr . - expr
    (68) expr -> expr . * expr
    (69) expr -> expr . / expr
    (70) expr -> expr . % expr

    LONGARROW       reduce using rule 64 (expr -> expr = expr .)
    ?               reduce using rule 64 (expr -> expr = expr .)
    IMPLIES         reduce using rule 64 (expr -> expr = expr .)
    |               reduce using rule 64 (expr -> expr = expr .)
    &               reduce using rule 64 (expr -> expr = expr .)
    <               reduce using rule 64 (expr -> expr = expr .)
    LEQ             reduce using rule 64 (expr -> expr = expr .)
    >               reduce using rule 64 (expr -> expr = expr .)
    GEQ             reduce using rule 64 (expr -> expr = expr .)
    =               reduce using rule 64 (expr -> expr = expr .)
    NEQ             reduce using rule 64 (expr -> expr = expr .)
    ;               reduce using rule 64 (expr -> expr = expr .)
    $end            reduce using rule 64 (expr -> expr = expr .)
    END             reduce using rule 64 (expr -> expr = expr .)
    )               reduce using rule 64 (expr -> expr = expr .)
    DO              reduce using rule 64 (expr -> expr = expr .)
    DOTDOT          reduce using rule 64 (expr -> expr = expr .)
    :               reduce using rule 64 (expr -> expr = expr .)
    ]               reduce using rule 64 (expr -> expr = expr .)
    ,               reduce using rule 64 (expr -> expr = expr .)
    THEN            reduce using rule 64 (expr -> expr = expr .)
    ELSE            reduce using rule 64 (expr -> expr = expr .)
    CASE            reduce using rule 64 (expr -> expr = expr .)
    STRING          reduce using rule 64 (expr -> expr = expr .)
    ELSIF           reduce using rule 64 (expr -> expr = expr .)
    +               shift and go to state 106
    -               shift and go to state 107
    *               shift and go to state 108
    /               shift and go to state 109
    %               shift and go to state 110

  ! +               [ reduce using rule 64 (expr -> expr = expr .) ]
  ! -               [ reduce using rule 64 (expr -> expr = expr .) ]
  ! *               [ reduce using rule 64 (expr -> expr = expr .) ]
  ! /               [ reduce using rule 64 (expr -> expr = expr .) ]
  ! %               [ reduce using rule 64 (expr -> expr = expr .) ]
  ! ?               [ shift and go to state 96 ]
  ! IMPLIES         [ shift and go to state 97 ]
  ! |               [ shift and go to state 98 ]
  ! &               [ shift and go to state 99 ]
  ! <               [ shift and go to state 100 ]
  ! LEQ             [ shift and go to state 101 ]
  ! >               [ shift and go to state 102 ]
  ! GEQ             [ shift and go to state 103 ]
  ! =               [ shift and go to state 104 ]
  ! NEQ             [ shift and go to state 105 ]


state 188

    (65) expr -> expr NEQ expr .
    (56) expr -> expr . ? expr : expr
    (57) expr -> expr . IMPLIES expr
    (58) expr -> expr . | expr
    (59) expr -> expr . & expr
    (60) expr -> expr . < expr
    (61) expr -> expr . LEQ expr
    (62) expr -> expr . > expr
    (63) expr -> expr . GEQ expr
    (64) expr -> expr . = expr
    (65) expr -> expr . NEQ expr
    (66) expr -> expr . + expr
    (67) expr -> expr . - expr
    (68) expr -> expr . * expr
    (69) expr -> expr . / expr
    (70) expr -> expr . % expr

    LONGARROW       reduce using rule 65 (expr -> expr NEQ expr .)
    ?               reduce using rule 65 (expr -> expr NEQ expr .)
    IMPLIES         reduce using rule 65 (expr -> expr NEQ expr .)
    |               reduce using rule 65 (expr -> expr NEQ expr .)
    &               reduce using rule 65 (expr -> expr NEQ expr .)
    <               reduce using rule 65 (expr -> expr NEQ expr .)
    LEQ             reduce using rule 65 (expr -> expr NEQ expr .)
    >               reduce using rule 65 (expr -> expr NEQ expr .)
    GEQ             reduce using rule 65 (expr -> expr NEQ expr .)
    =               reduce using rule 65 (expr -> expr NEQ expr .)
    NEQ             reduce using rule 65 (expr -> expr NEQ expr .)
    ;               reduce using rule 65 (expr -> expr NEQ expr .)
    $end            reduce using rule 65 (expr -> expr NEQ expr .)
    END             reduce using rule 65 (expr -> expr NEQ expr .)
    )               reduce using rule 65 (expr -> expr NEQ expr .)
    DO              reduce using rule 65 (expr -> expr NEQ expr .)
    DOTDOT          reduce using rule 65 (expr -> expr NEQ expr .)
    :               reduce using rule 65 (expr -> expr NEQ expr .)
    ]               reduce using rule 65 (expr -> expr NEQ expr .)
    ,               reduce using rule 65 (expr -> expr NEQ expr .)
    THEN            reduce using rule 65 (expr -> expr NEQ expr .)
    ELSE            reduce using rule 65 (expr -> expr NEQ expr .)
    CASE            reduce using rule 65 (expr -> expr NEQ expr .)
    STRING          reduce using rule 65 (expr -> expr NEQ expr .)
    ELSIF           reduce using rule 65 (expr -> expr NEQ expr .)
    +               shift and go to state 106
    -               shift and go to state 107
    *               shift and go to state 108
    /               shift and go to state 109
    %               shift and go to state 110

  ! +               [ reduce using rule 65 (expr -> expr NEQ expr .) ]
  ! -               [ reduce using rule 65 (expr -> expr NEQ expr .) ]
  ! *               [ reduce using rule 65 (expr -> expr NEQ expr .) ]
  ! /               [ reduce using rule 65 (expr -> expr NEQ expr .) ]
  ! %               [ reduce using rule 65 (expr -> expr NEQ expr .) ]
  ! ?               [ shift and go to state 96 ]
  ! IMPLIES         [ shift and go to state 97 ]
  ! |               [ shift and go to state 98 ]
  ! &               [ shift and go to state 99 ]
  ! <               [ shift and go to state 100 ]
  ! LEQ             [ shift and go to state 101 ]
  ! >               [ shift and go to state 102 ]
  ! GEQ             [ shift and go to state 103 ]
  ! =               [ shift and go to state 104 ]
  ! NEQ             [ shift and go to state 105 ]


state 189

    (66) expr -> expr + expr .
    (56) expr -> expr . ? expr : expr
    (57) expr -> expr . IMPLIES expr
    (58) expr -> expr . | expr
    (59) expr -> expr . & expr
    (60) expr -> expr . < expr
    (61) expr -> expr . LEQ expr
    (62) expr -> expr . > expr
    (63) expr -> expr . GEQ expr
    (64) expr -> expr . = expr
    (65) expr -> expr . NEQ expr
    (66) expr -> expr . + expr
    (67) expr -> expr . - expr
    (68) expr -> expr . * expr
    (69) expr -> expr . / expr
    (70) expr -> expr . % expr

    LONGARROW       reduce using rule 66 (expr -> expr + expr .)
    ?               reduce using rule 66 (expr -> expr + expr .)
    IMPLIES         reduce using rule 66 (expr -> expr + expr .)
    |               reduce using rule 66 (expr -> expr + expr .)
    &               reduce using rule 66 (expr -> expr + expr .)
    <               reduce using rule 66 (expr -> expr + expr .)
    LEQ             reduce using rule 66 (expr -> expr + expr .)
    >               reduce using rule 66 (expr -> expr + expr .)
    GEQ             reduce using rule 66 (expr -> expr + expr .)
    =               reduce using rule 66 (expr -> expr + expr .)
    NEQ             reduce using rule 66 (expr -> expr + expr .)
    +               reduce using rule 66 (expr -> expr + expr .)
    -               reduce using rule 66 (expr -> expr + expr .)
    ;               reduce using rule 66 (expr -> expr + expr .)
    $end            reduce using rule 66 (expr -> expr + expr .)
    END             reduce using rule 66 (expr -> expr + expr .)
    )               reduce using rule 66 (expr -> expr + expr .)
    DO              reduce using rule 66 (expr -> expr + expr .)
    DOTDOT          reduce using rule 66 (expr -> expr + expr .)
    :               reduce using rule 66 (expr -> expr + expr .)
    ]               reduce using rule 66 (expr -> expr + expr .)
    ,               reduce using rule 66 (expr -> expr + expr .)
    THEN            reduce using rule 66 (expr -> expr + expr .)
    ELSE            reduce using rule 66 (expr -> expr + expr .)
    CASE            reduce using rule 66 (expr -> expr + expr .)
    STRING          reduce using rule 66 (expr -> expr + expr .)
    ELSIF           reduce using rule 66 (expr -> expr + expr .)
    *               shift and go to state 108
    /               shift and go to state 109
    %               shift and go to state 110

  ! *               [ reduce using rule 66 (expr -> expr + expr .) ]
  ! /               [ reduce using rule 66 (expr -> expr + expr .) ]
  ! %               [ reduce using rule 66 (expr -> expr + expr .) ]
  ! ?               [ shift and go to state 96 ]
  ! IMPLIES         [ shift and go to state 97 ]
  ! |               [ shift and go to state 98 ]
  ! &               [ shift and go to state 99 ]
  ! <               [ shift and go to state 100 ]
  ! LEQ             [ shift and go to state 101 ]
  ! >               [ shift and go to state 102 ]
  ! GEQ             [ shift and go to state 103 ]
  ! =               [ shift and go to state 104 ]
  ! NEQ             [ shift and go to state 105 ]
  ! +               [ shift and go to state 106 ]
  ! -               [ shift and go to state 107 ]


state 190

    (67) expr -> expr - expr .
    (56) expr -> expr . ? expr : expr
    (57) expr -> expr . IMPLIES expr
    (58) expr -> expr . | expr
    (59) expr -> expr . & expr
    (60) expr -> expr . < expr
    (61) expr -> expr . LEQ expr
    (62) expr -> expr . > expr
    (63) expr -> expr . GEQ expr
    (64) expr -> expr . = expr
    (65) expr -> expr . NEQ expr
    (66) expr -> expr . + expr
    (67) expr -> expr . - expr
    (68) expr -> expr . * expr
    (69) expr -> expr . / expr
    (70) expr -> expr . % expr

    LONGARROW       reduce using rule 67 (expr -> expr - expr .)
    ?               reduce using rule 67 (expr -> expr - expr .)
    IMPLIES         reduce using rule 67 (expr -> expr - expr .)
    |               reduce using rule 67 (expr -> expr - expr .)
    &               reduce using rule 67 (expr -> expr - expr .)
    <               reduce using rule 67 (expr -> expr - expr .)
    LEQ             reduce using rule 67 (expr -> expr - expr .)
    >               reduce using rule 67 (expr -> expr - expr .)
    GEQ             reduce using rule 67 (expr -> expr - expr .)
    =               reduce using rule 67 (expr -> expr - expr .)
    NEQ             reduce using rule 67 (expr -> expr - expr .)
    +               reduce using rule 67 (expr -> expr - expr .)
    -               reduce using rule 67 (expr -> expr - expr .)
    ;               reduce using rule 67 (expr -> expr - expr .)
    $end            reduce using rule 67 (expr -> expr - expr .)
    END             reduce using rule 67 (expr -> expr - expr .)
    )               reduce using rule 67 (expr -> expr - expr .)
    DO              reduce using rule 67 (expr -> expr - expr .)
    DOTDOT          reduce using rule 67 (expr -> expr - expr .)
    :               reduce using rule 67 (expr -> expr - expr .)
    ]               reduce using rule 67 (expr -> expr - expr .)
    ,               reduce using rule 67 (expr -> expr - expr .)
    THEN            reduce using rule 67 (expr -> expr - expr .)
    ELSE            reduce using rule 67 (expr -> expr - expr .)
    CASE            reduce using rule 67 (expr -> expr - expr .)
    STRING          reduce using rule 67 (expr -> expr - expr .)
    ELSIF           reduce using rule 67 (expr -> expr - expr .)
    *               shift and go to state 108
    /               shift and go to state 109
    %               shift and go to state 110

  ! *               [ reduce using rule 67 (expr -> expr - expr .) ]
  ! /               [ reduce using rule 67 (expr -> expr - expr .) ]
  ! %               [ reduce using rule 67 (expr -> expr - expr .) ]
  ! ?               [ shift and go to state 96 ]
  ! IMPLIES         [ shift and go to state 97 ]
  ! |               [ shift and go to state 98 ]
  ! &               [ shift and go to state 99 ]
  ! <               [ shift and go to state 100 ]
  ! LEQ             [ shift and go to state 101 ]
  ! >               [ shift and go to state 102 ]
  ! GEQ             [ shift and go to state 103 ]
  ! =               [ shift and go to state 104 ]
  ! NEQ             [ shift and go to state 105 ]
  ! +               [ shift and go to state 106 ]
  ! -               [ shift and go to state 107 ]


state 191

    (68) expr -> expr * expr .
    (56) expr -> expr . ? expr : expr
    (57) expr -> expr . IMPLIES expr
    (58) expr -> expr . | expr
    (59) expr -> expr . & expr
    (60) expr -> expr . < expr
    (61) expr -> expr . LEQ expr
    (62) expr -> expr . > expr
    (63) expr -> expr . GEQ expr
    (64) expr -> expr . = expr
    (65) expr -> expr . NEQ expr
    (66) expr -> expr . + expr
    (67) expr -> expr . - expr
    (68) expr -> expr . * expr
    (69) expr -> expr . / expr
    (70) expr -> expr . % expr

    LONGARROW       reduce using rule 68 (expr -> expr * expr .)
    ?               reduce using rule 68 (expr -> expr * expr .)
    IMPLIES         reduce using rule 68 (expr -> expr * expr .)
    |               reduce using rule 68 (expr -> expr * expr .)
    &               reduce using rule 68 (expr -> expr * expr .)
    <               reduce using rule 68 (expr -> expr * expr .)
    LEQ             reduce using rule 68 (expr -> expr * expr .)
    >               reduce using rule 68 (expr -> expr * expr .)
    GEQ             reduce using rule 68 (expr -> expr * expr .)
    =               reduce using rule 68 (expr -> expr * expr .)
    NEQ             reduce using rule 68 (expr -> expr * expr .)
    +               reduce using rule 68 (expr -> expr * expr .)
    -               reduce using rule 68 (expr -> expr * expr .)
    *               reduce using rule 68 (expr -> expr * expr .)
    /               reduce using rule 68 (expr -> expr * expr .)
    %               reduce using rule 68 (expr -> expr * expr .)
    ;               reduce using rule 68 (expr -> expr * expr .)
    $end            reduce using rule 68 (expr -> expr * expr .)
    END             reduce using rule 68 (expr -> expr * expr .)
    )               reduce using rule 68 (expr -> expr * expr .)
    DO              reduce using rule 68 (expr -> expr * expr .)
    DOTDOT          reduce using rule 68 (expr -> expr * expr .)
    :               reduce using rule 68 (expr -> expr * expr .)
    ]               reduce using rule 68 (expr -> expr * expr .)
    ,               reduce using rule 68 (expr -> expr * expr .)
    THEN            reduce using rule 68 (expr -> expr * expr .)
    ELSE            reduce using rule 68 (expr -> expr * expr .)
    CASE            reduce using rule 68 (expr -> expr * expr .)
    STRING          reduce using rule 68 (expr -> expr * expr .)
    ELSIF           reduce using rule 68 (expr -> expr * expr .)

  ! ?               [ shift and go to state 96 ]
  ! IMPLIES         [ shift and go to state 97 ]
  ! |               [ shift and go to state 98 ]
  ! &               [ shift and go to state 99 ]
  ! <               [ shift and go to state 100 ]
  ! LEQ             [ shift and go to state 101 ]
  ! >               [ shift and go to state 102 ]
  ! GEQ             [ shift and go to state 103 ]
  ! =               [ shift and go to state 104 ]
  ! NEQ             [ shift and go to state 105 ]
  ! +               [ shift and go to state 106 ]
  ! -               [ shift and go to state 107 ]
  ! *               [ shift and go to state 108 ]
  ! /               [ shift and go to state 109 ]
  ! %               [ shift and go to state 110 ]


state 192

    (69) expr -> expr / expr .
    (56) expr -> expr . ? expr : expr
    (57) expr -> expr . IMPLIES expr
    (58) expr -> expr . | expr
    (59) expr -> expr . & expr
    (60) expr -> expr . < expr
    (61) expr -> expr . LEQ expr
    (62) expr -> expr . > expr
    (63) expr -> expr . GEQ expr
    (64) expr -> expr . = expr
    (65) expr -> expr . NEQ expr
    (66) expr -> expr . + expr
    (67) expr -> expr . - expr
    (68) expr -> expr . * expr
    (69) expr -> expr . / expr
    (70) expr -> expr . % expr

    LONGARROW       reduce using rule 69 (expr -> expr / expr .)
    ?               reduce using rule 69 (expr -> expr / expr .)
    IMPLIES         reduce using rule 69 (expr -> expr / expr .)
    |               reduce using rule 69 (expr -> expr / expr .)
    &               reduce using rule 69 (expr -> expr / expr .)
    <               reduce using rule 69 (expr -> expr / expr .)
    LEQ             reduce using rule 69 (expr -> expr / expr .)
    >               reduce using rule 69 (expr -> expr / expr .)
    GEQ             reduce using rule 69 (expr -> expr / expr .)
    =               reduce using rule 69 (expr -> expr / expr .)
    NEQ             reduce using rule 69 (expr -> expr / expr .)
    +               reduce using rule 69 (expr -> expr / expr .)
    -               reduce using rule 69 (expr -> expr / expr .)
    *               reduce using rule 69 (expr -> expr / expr .)
    /               reduce using rule 69 (expr -> expr / expr .)
    %               reduce using rule 69 (expr -> expr / expr .)
    ;               reduce using rule 69 (expr -> expr / expr .)
    $end            reduce using rule 69 (expr -> expr / expr .)
    END             reduce using rule 69 (expr -> expr / expr .)
    )               reduce using rule 69 (expr -> expr / expr .)
    DO              reduce using rule 69 (expr -> expr / expr .)
    DOTDOT          reduce using rule 69 (expr -> expr / expr .)
    :               reduce using rule 69 (expr -> expr / expr .)
    ]               reduce using rule 69 (expr -> expr / expr .)
    ,               reduce using rule 69 (expr -> expr / expr .)
    THEN            reduce using rule 69 (expr -> expr / expr .)
    ELSE            reduce using rule 69 (expr -> expr / expr .)
    CASE            reduce using rule 69 (expr -> expr / expr .)
    STRING          reduce using rule 69 (expr -> expr / expr .)
    ELSIF           reduce using rule 69 (expr -> expr / expr .)

  ! ?               [ shift and go to state 96 ]
  ! IMPLIES         [ shift and go to state 97 ]
  ! |               [ shift and go to state 98 ]
  ! &               [ shift and go to state 99 ]
  ! <               [ shift and go to state 100 ]
  ! LEQ             [ shift and go to state 101 ]
  ! >               [ shift and go to state 102 ]
  ! GEQ             [ shift and go to state 103 ]
  ! =               [ shift and go to state 104 ]
  ! NEQ             [ shift and go to state 105 ]
  ! +               [ shift and go to state 106 ]
  ! -               [ shift and go to state 107 ]
  ! *               [ shift and go to state 108 ]
  ! /               [ shift and go to state 109 ]
  ! %               [ shift and go to state 110 ]


state 193

    (70) expr -> expr % expr .
    (56) expr -> expr . ? expr : expr
    (57) expr -> expr . IMPLIES expr
    (58) expr -> expr . | expr
    (59) expr -> expr . & expr
    (60) expr -> expr . < expr
    (61) expr -> expr . LEQ expr
    (62) expr -> expr . > expr
    (63) expr -> expr . GEQ expr
    (64) expr -> expr . = expr
    (65) expr -> expr . NEQ expr
    (66) expr -> expr . + expr
    (67) expr -> expr . - expr
    (68) expr -> expr . * expr
    (69) expr -> expr . / expr
    (70) expr -> expr . % expr

    LONGARROW       reduce using rule 70 (expr -> expr % expr .)
    ?               reduce using rule 70 (expr -> expr % expr .)
    IMPLIES         reduce using rule 70 (expr -> expr % expr .)
    |               reduce using rule 70 (expr -> expr % expr .)
    &               reduce using rule 70 (expr -> expr % expr .)
    <               reduce using rule 70 (expr -> expr % expr .)
    LEQ             reduce using rule 70 (expr -> expr % expr .)
    >               reduce using rule 70 (expr -> expr % expr .)
    GEQ             reduce using rule 70 (expr -> expr % expr .)
    =               reduce using rule 70 (expr -> expr % expr .)
    NEQ             reduce using rule 70 (expr -> expr % expr .)
    +               reduce using rule 70 (expr -> expr % expr .)
    -               reduce using rule 70 (expr -> expr % expr .)
    *               reduce using rule 70 (expr -> expr % expr .)
    /               reduce using rule 70 (expr -> expr % expr .)
    %               reduce using rule 70 (expr -> expr % expr .)
    ;               reduce using rule 70 (expr -> expr % expr .)
    $end            reduce using rule 70 (expr -> expr % expr .)
    END             reduce using rule 70 (expr -> expr % expr .)
    )               reduce using rule 70 (expr -> expr % expr .)
    DO              reduce using rule 70 (expr -> expr % expr .)
    DOTDOT          reduce using rule 70 (expr -> expr % expr .)
    :               reduce using rule 70 (expr -> expr % expr .)
    ]               reduce using rule 70 (expr -> expr % expr .)
    ,               reduce using rule 70 (expr -> expr % expr .)
    THEN            reduce using rule 70 (expr -> expr % expr .)
    ELSE            reduce using rule 70 (expr -> expr % expr .)
    CASE            reduce using rule 70 (expr -> expr % expr .)
    STRING          reduce using rule 70 (expr -> expr % expr .)
    ELSIF           reduce using rule 70 (expr -> expr % expr .)

  ! ?               [ shift and go to state 96 ]
  ! IMPLIES         [ shift and go to state 97 ]
  ! |               [ shift and go to state 98 ]
  ! &               [ shift and go to state 99 ]
  ! <               [ shift and go to state 100 ]
  ! LEQ             [ shift and go to state 101 ]
  ! >               [ shift and go to state 102 ]
  ! GEQ             [ shift and go to state 103 ]
  ! =               [ shift and go to state 104 ]
  ! NEQ             [ shift and go to state 105 ]
  ! +               [ shift and go to state 106 ]
  ! -               [ shift and go to state 107 ]
  ! *               [ shift and go to state 108 ]
  ! /               [ shift and go to state 109 ]
  ! %               [ shift and go to state 110 ]


state 194

    (54) designator -> designator [ expr . ]
    (56) expr -> expr . ? expr : expr
    (57) expr -> expr . IMPLIES expr
    (58) expr -> expr . | expr
    (59) expr -> expr . & expr
    (60) expr -> expr . < expr
    (61) expr -> expr . LEQ expr
    (62) expr -> expr . > expr
    (63) expr -> expr . GEQ expr
    (64) expr -> expr . = expr
    (65) expr -> expr . NEQ expr
    (66) expr -> expr . + expr
    (67) expr -> expr . - expr
    (68) expr -> expr . * expr
    (69) expr -> expr . / expr
    (70) expr -> expr . % expr

    ]               shift and go to state 236
    ?               shift and go to state 96
    IMPLIES         shift and go to state 97
    |               shift and go to state 98
    &               shift and go to state 99
    <               shift and go to state 100
    LEQ             shift and go to state 101
    >               shift and go to state 102
    GEQ             shift and go to state 103
    =               shift and go to state 104
    NEQ             shift and go to state 105
    +               shift and go to state 106
    -               shift and go to state 107
    *               shift and go to state 108
    /               shift and go to state 109
    %               shift and go to state 110


state 195

    (55) designator -> designator . ID .

    [               reduce using rule 55 (designator -> designator . ID .)
    .               reduce using rule 55 (designator -> designator . ID .)
    LONGARROW       reduce using rule 55 (designator -> designator . ID .)
    ?               reduce using rule 55 (designator -> designator . ID .)
    IMPLIES         reduce using rule 55 (designator -> designator . ID .)
    |               reduce using rule 55 (designator -> designator . ID .)
    &               reduce using rule 55 (designator -> designator . ID .)
    <               reduce using rule 55 (designator -> designator . ID .)
    LEQ             reduce using rule 55 (designator -> designator . ID .)
    >               reduce using rule 55 (designator -> designator . ID .)
    GEQ             reduce using rule 55 (designator -> designator . ID .)
    =               reduce using rule 55 (designator -> designator . ID .)
    NEQ             reduce using rule 55 (designator -> designator . ID .)
    +               reduce using rule 55 (designator -> designator . ID .)
    -               reduce using rule 55 (designator -> designator . ID .)
    *               reduce using rule 55 (designator -> designator . ID .)
    /               reduce using rule 55 (designator -> designator . ID .)
    %               reduce using rule 55 (designator -> designator . ID .)
    ;               reduce using rule 55 (designator -> designator . ID .)
    $end            reduce using rule 55 (designator -> designator . ID .)
    END             reduce using rule 55 (designator -> designator . ID .)
    )               reduce using rule 55 (designator -> designator . ID .)
    DO              reduce using rule 55 (designator -> designator . ID .)
    DOTDOT          reduce using rule 55 (designator -> designator . ID .)
    :               reduce using rule 55 (designator -> designator . ID .)
    ]               reduce using rule 55 (designator -> designator . ID .)
    ,               reduce using rule 55 (designator -> designator . ID .)
    THEN            reduce using rule 55 (designator -> designator . ID .)
    ELSE            reduce using rule 55 (designator -> designator . ID .)
    CASE            reduce using rule 55 (designator -> designator . ID .)
    STRING          reduce using rule 55 (designator -> designator . ID .)
    ELSIF           reduce using rule 55 (designator -> designator . ID .)
    ASSIGN          reduce using rule 55 (designator -> designator . ID .)


state 196

    (81) actuals -> ( exprlist . )
    (83) exprlist -> exprlist . , expr

    )               shift and go to state 237
    ,               shift and go to state 238


state 197

    (82) actuals -> ( ) .

    LONGARROW       reduce using rule 82 (actuals -> ( ) .)
    ?               reduce using rule 82 (actuals -> ( ) .)
    IMPLIES         reduce using rule 82 (actuals -> ( ) .)
    |               reduce using rule 82 (actuals -> ( ) .)
    &               reduce using rule 82 (actuals -> ( ) .)
    <               reduce using rule 82 (actuals -> ( ) .)
    LEQ             reduce using rule 82 (actuals -> ( ) .)
    >               reduce using rule 82 (actuals -> ( ) .)
    GEQ             reduce using rule 82 (actuals -> ( ) .)
    =               reduce using rule 82 (actuals -> ( ) .)
    NEQ             reduce using rule 82 (actuals -> ( ) .)
    +               reduce using rule 82 (actuals -> ( ) .)
    -               reduce using rule 82 (actuals -> ( ) .)
    *               reduce using rule 82 (actuals -> ( ) .)
    /               reduce using rule 82 (actuals -> ( ) .)
    %               reduce using rule 82 (actuals -> ( ) .)
    ;               reduce using rule 82 (actuals -> ( ) .)
    $end            reduce using rule 82 (actuals -> ( ) .)
    END             reduce using rule 82 (actuals -> ( ) .)
    )               reduce using rule 82 (actuals -> ( ) .)
    DO              reduce using rule 82 (actuals -> ( ) .)
    DOTDOT          reduce using rule 82 (actuals -> ( ) .)
    :               reduce using rule 82 (actuals -> ( ) .)
    ]               reduce using rule 82 (actuals -> ( ) .)
    ,               reduce using rule 82 (actuals -> ( ) .)
    THEN            reduce using rule 82 (actuals -> ( ) .)
    ELSE            reduce using rule 82 (actuals -> ( ) .)
    CASE            reduce using rule 82 (actuals -> ( ) .)
    STRING          reduce using rule 82 (actuals -> ( ) .)
    ELSIF           reduce using rule 82 (actuals -> ( ) .)


state 198

    (84) exprlist -> expr .
    (56) expr -> expr . ? expr : expr
    (57) expr -> expr . IMPLIES expr
    (58) expr -> expr . | expr
    (59) expr -> expr . & expr
    (60) expr -> expr . < expr
    (61) expr -> expr . LEQ expr
    (62) expr -> expr . > expr
    (63) expr -> expr . GEQ expr
    (64) expr -> expr . = expr
    (65) expr -> expr . NEQ expr
    (66) expr -> expr . + expr
    (67) expr -> expr . - expr
    (68) expr -> expr . * expr
    (69) expr -> expr . / expr
    (70) expr -> expr . % expr

    )               reduce using rule 84 (exprlist -> expr .)
    ,               reduce using rule 84 (exprlist -> expr .)
    :               reduce using rule 84 (exprlist -> expr .)
    ?               shift and go to state 96
    IMPLIES         shift and go to state 97
    |               shift and go to state 98
    &               shift and go to state 99
    <               shift and go to state 100
    LEQ             shift and go to state 101
    >               shift and go to state 102
    GEQ             shift and go to state 103
    =               shift and go to state 104
    NEQ             shift and go to state 105
    +               shift and go to state 106
    -               shift and go to state 107
    *               shift and go to state 108
    /               shift and go to state 109
    %               shift and go to state 110


state 199

    (77) expr -> ISUNDEFINED ( designator . )
    (54) designator -> designator . [ expr ]
    (55) designator -> designator . . ID

    )               shift and go to state 239
    [               shift and go to state 114
    .               shift and go to state 115


state 200

    (53) designator -> ID .

    )               reduce using rule 53 (designator -> ID .)
    [               reduce using rule 53 (designator -> ID .)
    .               reduce using rule 53 (designator -> ID .)
    ;               reduce using rule 53 (designator -> ID .)
    END             reduce using rule 53 (designator -> ID .)
    ELSIF           reduce using rule 53 (designator -> ID .)
    ELSE            reduce using rule 53 (designator -> ID .)
    CASE            reduce using rule 53 (designator -> ID .)


state 201

    (78) expr -> ( expr ) .

    LONGARROW       reduce using rule 78 (expr -> ( expr ) .)
    ?               reduce using rule 78 (expr -> ( expr ) .)
    IMPLIES         reduce using rule 78 (expr -> ( expr ) .)
    |               reduce using rule 78 (expr -> ( expr ) .)
    &               reduce using rule 78 (expr -> ( expr ) .)
    <               reduce using rule 78 (expr -> ( expr ) .)
    LEQ             reduce using rule 78 (expr -> ( expr ) .)
    >               reduce using rule 78 (expr -> ( expr ) .)
    GEQ             reduce using rule 78 (expr -> ( expr ) .)
    =               reduce using rule 78 (expr -> ( expr ) .)
    NEQ             reduce using rule 78 (expr -> ( expr ) .)
    +               reduce using rule 78 (expr -> ( expr ) .)
    -               reduce using rule 78 (expr -> ( expr ) .)
    *               reduce using rule 78 (expr -> ( expr ) .)
    /               reduce using rule 78 (expr -> ( expr ) .)
    %               reduce using rule 78 (expr -> ( expr ) .)
    ;               reduce using rule 78 (expr -> ( expr ) .)
    $end            reduce using rule 78 (expr -> ( expr ) .)
    END             reduce using rule 78 (expr -> ( expr ) .)
    )               reduce using rule 78 (expr -> ( expr ) .)
    DO              reduce using rule 78 (expr -> ( expr ) .)
    DOTDOT          reduce using rule 78 (expr -> ( expr ) .)
    :               reduce using rule 78 (expr -> ( expr ) .)
    ]               reduce using rule 78 (expr -> ( expr ) .)
    ,               reduce using rule 78 (expr -> ( expr ) .)
    THEN            reduce using rule 78 (expr -> ( expr ) .)
    ELSE            reduce using rule 78 (expr -> ( expr ) .)
    CASE            reduce using rule 78 (expr -> ( expr ) .)
    STRING          reduce using rule 78 (expr -> ( expr ) .)
    ELSIF           reduce using rule 78 (expr -> ( expr ) .)


state 202

    (79) expr -> FORALL quantifiers DO . expr END
    (56) expr -> . expr ? expr : expr
    (57) expr -> . expr IMPLIES expr
    (58) expr -> . expr | expr
    (59) expr -> . expr & expr
    (60) expr -> . expr < expr
    (61) expr -> . expr LEQ expr
    (62) expr -> . expr > expr
    (63) expr -> . expr GEQ expr
    (64) expr -> . expr = expr
    (65) expr -> . expr NEQ expr
    (66) expr -> . expr + expr
    (67) expr -> . expr - expr
    (68) expr -> . expr * expr
    (69) expr -> . expr / expr
    (70) expr -> . expr % expr
    (71) expr -> . ! expr
    (72) expr -> . + expr
    (73) expr -> . - expr
    (74) expr -> . INTCONST
    (75) expr -> . designator
    (76) expr -> . ID actuals
    (77) expr -> . ISUNDEFINED ( designator )
    (78) expr -> . ( expr )
    (79) expr -> . FORALL quantifiers DO expr END
    (80) expr -> . EXISTS quantifiers DO expr END
    (53) designator -> . ID
    (54) designator -> . designator [ expr ]
    (55) designator -> . designator . ID

    !               shift and go to state 60
    +               shift and go to state 58
    -               shift and go to state 59
    INTCONST        shift and go to state 61
    ID              shift and go to state 63
    ISUNDEFINED     shift and go to state 64
    (               shift and go to state 65
    FORALL          shift and go to state 66
    EXISTS          shift and go to state 67

    expr                           shift and go to state 240
    designator                     shift and go to state 62

state 203

    (80) expr -> EXISTS quantifiers DO . expr END
    (56) expr -> . expr ? expr : expr
    (57) expr -> . expr IMPLIES expr
    (58) expr -> . expr | expr
    (59) expr -> . expr & expr
    (60) expr -> . expr < expr
    (61) expr -> . expr LEQ expr
    (62) expr -> . expr > expr
    (63) expr -> . expr GEQ expr
    (64) expr -> . expr = expr
    (65) expr -> . expr NEQ expr
    (66) expr -> . expr + expr
    (67) expr -> . expr - expr
    (68) expr -> . expr * expr
    (69) expr -> . expr / expr
    (70) expr -> . expr % expr
    (71) expr -> . ! expr
    (72) expr -> . + expr
    (73) expr -> . - expr
    (74) expr -> . INTCONST
    (75) expr -> . designator
    (76) expr -> . ID actuals
    (77) expr -> . ISUNDEFINED ( designator )
    (78) expr -> . ( expr )
    (79) expr -> . FORALL quantifiers DO expr END
    (80) expr -> . EXISTS quantifiers DO expr END
    (53) designator -> . ID
    (54) designator -> . designator [ expr ]
    (55) designator -> . designator . ID

    !               shift and go to state 60
    +               shift and go to state 58
    -               shift and go to state 59
    INTCONST        shift and go to state 61
    ID              shift and go to state 63
    ISUNDEFINED     shift and go to state 64
    (               shift and go to state 65
    FORALL          shift and go to state 66
    EXISTS          shift and go to state 67

    expr                           shift and go to state 241
    designator                     shift and go to state 62

state 204

    (144) aliasrule -> ALIAS aliases DO rules END .

    ;               reduce using rule 144 (aliasrule -> ALIAS aliases DO rules END .)
    $end            reduce using rule 144 (aliasrule -> ALIAS aliases DO rules END .)
    END             reduce using rule 144 (aliasrule -> ALIAS aliases DO rules END .)


state 205

    (145) ruleset -> RULESET quantifiers DO rules END .

    ;               reduce using rule 145 (ruleset -> RULESET quantifiers DO rules END .)
    $end            reduce using rule 145 (ruleset -> RULESET quantifiers DO rules END .)
    END             reduce using rule 145 (ruleset -> RULESET quantifiers DO rules END .)


state 206

    (19) enumtype -> ENUM { . enums }
    (20) enums -> . enums , ID
    (21) enums -> . ID

    ID              shift and go to state 243

    enums                          shift and go to state 242

state 207

    (22) subrangetype -> expr DOTDOT . expr
    (56) expr -> . expr ? expr : expr
    (57) expr -> . expr IMPLIES expr
    (58) expr -> . expr | expr
    (59) expr -> . expr & expr
    (60) expr -> . expr < expr
    (61) expr -> . expr LEQ expr
    (62) expr -> . expr > expr
    (63) expr -> . expr GEQ expr
    (64) expr -> . expr = expr
    (65) expr -> . expr NEQ expr
    (66) expr -> . expr + expr
    (67) expr -> . expr - expr
    (68) expr -> . expr * expr
    (69) expr -> . expr / expr
    (70) expr -> . expr % expr
    (71) expr -> . ! expr
    (72) expr -> . + expr
    (73) expr -> . - expr
    (74) expr -> . INTCONST
    (75) expr -> . designator
    (76) expr -> . ID actuals
    (77) expr -> . ISUNDEFINED ( designator )
    (78) expr -> . ( expr )
    (79) expr -> . FORALL quantifiers DO expr END
    (80) expr -> . EXISTS quantifiers DO expr END
    (53) designator -> . ID
    (54) designator -> . designator [ expr ]
    (55) designator -> . designator . ID

    !               shift and go to state 60
    +               shift and go to state 58
    -               shift and go to state 59
    INTCONST        shift and go to state 61
    ID              shift and go to state 63
    ISUNDEFINED     shift and go to state 64
    (               shift and go to state 65
    FORALL          shift and go to state 66
    EXISTS          shift and go to state 67

    expr                           shift and go to state 244
    designator                     shift and go to state 62

state 208

    (23) recordtype -> RECORD fields . END
    (24) fields -> fields . ; field
    (25) fields -> fields . ;

    END             shift and go to state 245
    ;               shift and go to state 246


state 209

    (26) fields -> field .

    END             reduce using rule 26 (fields -> field .)
    ;               reduce using rule 26 (fields -> field .)


state 210

    (27) field -> ID . fieldtail
    (28) fieldtail -> . , ID fieldtail
    (29) fieldtail -> . : typeexpr

    ,               shift and go to state 248
    :               shift and go to state 249

    fieldtail                      shift and go to state 247

state 211

    (30) arraytype -> ARRAY [ . typeexpr ] OF typeexpr
    (13) typeexpr -> . typeid
    (14) typeexpr -> . enumtype
    (15) typeexpr -> . subrangetype
    (16) typeexpr -> . recordtype
    (17) typeexpr -> . arraytype
    (18) typeid -> . ID
    (19) enumtype -> . ENUM { enums }
    (22) subrangetype -> . expr DOTDOT expr
    (23) recordtype -> . RECORD fields END
    (30) arraytype -> . ARRAY [ typeexpr ] OF typeexpr
    (56) expr -> . expr ? expr : expr
    (57) expr -> . expr IMPLIES expr
    (58) expr -> . expr | expr
    (59) expr -> . expr & expr
    (60) expr -> . expr < expr
    (61) expr -> . expr LEQ expr
    (62) expr -> . expr > expr
    (63) expr -> . expr GEQ expr
    (64) expr -> . expr = expr
    (65) expr -> . expr NEQ expr
    (66) expr -> . expr + expr
    (67) expr -> . expr - expr
    (68) expr -> . expr * expr
    (69) expr -> . expr / expr
    (70) expr -> . expr % expr
    (71) expr -> . ! expr
    (72) expr -> . + expr
    (73) expr -> . - expr
    (74) expr -> . INTCONST
    (75) expr -> . designator
    (76) expr -> . ID actuals
    (77) expr -> . ISUNDEFINED ( designator )
    (78) expr -> . ( expr )
    (79) expr -> . FORALL quantifiers DO expr END
    (80) expr -> . EXISTS quantifiers DO expr END
    (53) designator -> . ID
    (54) designator -> . designator [ expr ]
    (55) designator -> . designator . ID

    ID              shift and go to state 127
    ENUM            shift and go to state 134
    RECORD          shift and go to state 136
    ARRAY           shift and go to state 137
    !               shift and go to state 60
    +               shift and go to state 58
    -               shift and go to state 59
    INTCONST        shift and go to state 61
    ISUNDEFINED     shift and go to state 64
    (               shift and go to state 65
    FORALL          shift and go to state 66
    EXISTS          shift and go to state 67

    typeexpr                       shift and go to state 250
    typeid                         shift and go to state 129
    enumtype                       shift and go to state 130
    subrangetype                   shift and go to state 131
    recordtype                     shift and go to state 132
    arraytype                      shift and go to state 133
    expr                           shift and go to state 135
    designator                     shift and go to state 62

state 212

    (146) startstate -> STARTSTATE optstring optdecls optstmts END .

    ;               reduce using rule 146 (startstate -> STARTSTATE optstring optdecls optstmts END .)
    $end            reduce using rule 146 (startstate -> STARTSTATE optstring optdecls optstmts END .)
    END             reduce using rule 146 (startstate -> STARTSTATE optstring optdecls optstmts END .)


state 213

    (90) stmts -> stmts ; . stmt
    (91) stmts -> stmts ; .
    (93) stmt -> . assignment
    (94) stmt -> . ifstmt
    (95) stmt -> . whilestmt
    (96) stmt -> . switchstmt
    (97) stmt -> . forstmt
    (98) stmt -> . proccall
    (99) stmt -> . clearstmt
    (100) stmt -> . errorstmt
    (101) stmt -> . assertstmt
    (102) stmt -> . aliasstmt
    (103) stmt -> . returnstmt
    (104) stmt -> . undefinestmt
    (105) assignment -> . designator ASSIGN expr
    (106) ifstmt -> . IF expr THEN optstmts optelses END
    (112) whilestmt -> . WHILE expr DO optstmts END
    (113) switchstmt -> . SWITCH expr optcases optelse END
    (117) forstmt -> . FOR quantifiers DO optstmts END
    (118) proccall -> . ID actuals
    (119) clearstmt -> . CLEAR designator
    (121) errorstmt -> . ERROR STRING
    (122) assertstmt -> . ASSERT expr optstring
    (123) aliasstmt -> . ALIAS aliases DO optstmts END
    (128) returnstmt -> . RETURN optretexpr
    (120) undefinestmt -> . UNDEFINE designator
    (53) designator -> . ID
    (54) designator -> . designator [ expr ]
    (55) designator -> . designator . ID

    ;               reduce using rule 91 (stmts -> stmts ; .)
    END             reduce using rule 91 (stmts -> stmts ; .)
    ELSIF           reduce using rule 91 (stmts -> stmts ; .)
    ELSE            reduce using rule 91 (stmts -> stmts ; .)
    CASE            reduce using rule 91 (stmts -> stmts ; .)
    IF              shift and go to state 155
    WHILE           shift and go to state 156
    SWITCH          shift and go to state 157
    FOR             shift and go to state 158
    ID              shift and go to state 159
    CLEAR           shift and go to state 160
    ERROR           shift and go to state 161
    ASSERT          shift and go to state 162
    ALIAS           shift and go to state 163
    RETURN          shift and go to state 164
    UNDEFINE        shift and go to state 165

    stmt                           shift and go to state 251
    assignment                     shift and go to state 142
    ifstmt                         shift and go to state 143
    whilestmt                      shift and go to state 144
    switchstmt                     shift and go to state 145
    forstmt                        shift and go to state 146
    proccall                       shift and go to state 147
    clearstmt                      shift and go to state 148
    errorstmt                      shift and go to state 149
    assertstmt                     shift and go to state 150
    aliasstmt                      shift and go to state 151
    returnstmt                     shift and go to state 152
    undefinestmt                   shift and go to state 153
    designator                     shift and go to state 154

state 214

    (105) assignment -> designator ASSIGN . expr
    (56) expr -> . expr ? expr : expr
    (57) expr -> . expr IMPLIES expr
    (58) expr -> . expr | expr
    (59) expr -> . expr & expr
    (60) expr -> . expr < expr
    (61) expr -> . expr LEQ expr
    (62) expr -> . expr > expr
    (63) expr -> . expr GEQ expr
    (64) expr -> . expr = expr
    (65) expr -> . expr NEQ expr
    (66) expr -> . expr + expr
    (67) expr -> . expr - expr
    (68) expr -> . expr * expr
    (69) expr -> . expr / expr
    (70) expr -> . expr % expr
    (71) expr -> . ! expr
    (72) expr -> . + expr
    (73) expr -> . - expr
    (74) expr -> . INTCONST
    (75) expr -> . designator
    (76) expr -> . ID actuals
    (77) expr -> . ISUNDEFINED ( designator )
    (78) expr -> . ( expr )
    (79) expr -> . FORALL quantifiers DO expr END
    (80) expr -> . EXISTS quantifiers DO expr END
    (53) designator -> . ID
    (54) designator -> . designator [ expr ]
    (55) designator -> . designator . ID

    !               shift and go to state 60
    +               shift and go to state 58
    -               shift and go to state 59
    INTCONST        shift and go to state 61
    ID              shift and go to state 63
    ISUNDEFINED     shift and go to state 64
    (               shift and go to state 65
    FORALL          shift and go to state 66
    EXISTS          shift and go to state 67

    designator                     shift and go to state 62
    expr                           shift and go to state 252

state 215

    (106) ifstmt -> IF expr . THEN optstmts optelses END
    (56) expr -> expr . ? expr : expr
    (57) expr -> expr . IMPLIES expr
    (58) expr -> expr . | expr
    (59) expr -> expr . & expr
    (60) expr -> expr . < expr
    (61) expr -> expr . LEQ expr
    (62) expr -> expr . > expr
    (63) expr -> expr . GEQ expr
    (64) expr -> expr . = expr
    (65) expr -> expr . NEQ expr
    (66) expr -> expr . + expr
    (67) expr -> expr . - expr
    (68) expr -> expr . * expr
    (69) expr -> expr . / expr
    (70) expr -> expr . % expr

    THEN            shift and go to state 253
    ?               shift and go to state 96
    IMPLIES         shift and go to state 97
    |               shift and go to state 98
    &               shift and go to state 99
    <               shift and go to state 100
    LEQ             shift and go to state 101
    >               shift and go to state 102
    GEQ             shift and go to state 103
    =               shift and go to state 104
    NEQ             shift and go to state 105
    +               shift and go to state 106
    -               shift and go to state 107
    *               shift and go to state 108
    /               shift and go to state 109
    %               shift and go to state 110


state 216

    (112) whilestmt -> WHILE expr . DO optstmts END
    (56) expr -> expr . ? expr : expr
    (57) expr -> expr . IMPLIES expr
    (58) expr -> expr . | expr
    (59) expr -> expr . & expr
    (60) expr -> expr . < expr
    (61) expr -> expr . LEQ expr
    (62) expr -> expr . > expr
    (63) expr -> expr . GEQ expr
    (64) expr -> expr . = expr
    (65) expr -> expr . NEQ expr
    (66) expr -> expr . + expr
    (67) expr -> expr . - expr
    (68) expr -> expr . * expr
    (69) expr -> expr . / expr
    (70) expr -> expr . % expr

    DO              shift and go to state 254
    ?               shift and go to state 96
    IMPLIES         shift and go to state 97
    |               shift and go to state 98
    &               shift and go to state 99
    <               shift and go to state 100
    LEQ             shift and go to state 101
    >               shift and go to state 102
    GEQ             shift and go to state 103
    =               shift and go to state 104
    NEQ             shift and go to state 105
    +               shift and go to state 106
    -               shift and go to state 107
    *               shift and go to state 108
    /               shift and go to state 109
    %               shift and go to state 110


state 217

    (113) switchstmt -> SWITCH expr . optcases optelse END
    (56) expr -> expr . ? expr : expr
    (57) expr -> expr . IMPLIES expr
    (58) expr -> expr . | expr
    (59) expr -> expr . & expr
    (60) expr -> expr . < expr
    (61) expr -> expr . LEQ expr
    (62) expr -> expr . > expr
    (63) expr -> expr . GEQ expr
    (64) expr -> expr . = expr
    (65) expr -> expr . NEQ expr
    (66) expr -> expr . + expr
    (67) expr -> expr . - expr
    (68) expr -> expr . * expr
    (69) expr -> expr . / expr
    (70) expr -> expr . % expr
    (114) optcases -> . optcases case
    (115) optcases -> . empty
    (148) empty -> .

    ?               shift and go to state 96
    IMPLIES         shift and go to state 97
    |               shift and go to state 98
    &               shift and go to state 99
    <               shift and go to state 100
    LEQ             shift and go to state 101
    >               shift and go to state 102
    GEQ             shift and go to state 103
    =               shift and go to state 104
    NEQ             shift and go to state 105
    +               shift and go to state 106
    -               shift and go to state 107
    *               shift and go to state 108
    /               shift and go to state 109
    %               shift and go to state 110
    ELSE            reduce using rule 148 (empty -> .)
    CASE            reduce using rule 148 (empty -> .)
    END             reduce using rule 148 (empty -> .)

    optcases                       shift and go to state 255
    empty                          shift and go to state 256

state 218

    (117) forstmt -> FOR quantifiers . DO optstmts END

    DO              shift and go to state 257


state 219

    (118) proccall -> ID actuals .

    ;               reduce using rule 118 (proccall -> ID actuals .)
    END             reduce using rule 118 (proccall -> ID actuals .)
    ELSIF           reduce using rule 118 (proccall -> ID actuals .)
    ELSE            reduce using rule 118 (proccall -> ID actuals .)
    CASE            reduce using rule 118 (proccall -> ID actuals .)


state 220

    (119) clearstmt -> CLEAR designator .
    (54) designator -> designator . [ expr ]
    (55) designator -> designator . . ID

    ;               reduce using rule 119 (clearstmt -> CLEAR designator .)
    END             reduce using rule 119 (clearstmt -> CLEAR designator .)
    ELSIF           reduce using rule 119 (clearstmt -> CLEAR designator .)
    ELSE            reduce using rule 119 (clearstmt -> CLEAR designator .)
    CASE            reduce using rule 119 (clearstmt -> CLEAR designator .)
    [               shift and go to state 114
    .               shift and go to state 115


state 221

    (121) errorstmt -> ERROR STRING .

    ;               reduce using rule 121 (errorstmt -> ERROR STRING .)
    END             reduce using rule 121 (errorstmt -> ERROR STRING .)
    ELSIF           reduce using rule 121 (errorstmt -> ERROR STRING .)
    ELSE            reduce using rule 121 (errorstmt -> ERROR STRING .)
    CASE            reduce using rule 121 (errorstmt -> ERROR STRING .)


state 222

    (122) assertstmt -> ASSERT expr . optstring
    (56) expr -> expr . ? expr : expr
    (57) expr -> expr . IMPLIES expr
    (58) expr -> expr . | expr
    (59) expr -> expr . & expr
    (60) expr -> expr . < expr
    (61) expr -> expr . LEQ expr
    (62) expr -> expr . > expr
    (63) expr -> expr . GEQ expr
    (64) expr -> expr . = expr
    (65) expr -> expr . NEQ expr
    (66) expr -> expr . + expr
    (67) expr -> expr . - expr
    (68) expr -> expr . * expr
    (69) expr -> expr . / expr
    (70) expr -> expr . % expr
    (142) optstring -> . STRING
    (143) optstring -> . empty
    (148) empty -> .

    ?               shift and go to state 96
    IMPLIES         shift and go to state 97
    |               shift and go to state 98
    &               shift and go to state 99
    <               shift and go to state 100
    LEQ             shift and go to state 101
    >               shift and go to state 102
    GEQ             shift and go to state 103
    =               shift and go to state 104
    NEQ             shift and go to state 105
    +               shift and go to state 106
    -               shift and go to state 107
    *               shift and go to state 108
    /               shift and go to state 109
    %               shift and go to state 110
    STRING          shift and go to state 36
    ;               reduce using rule 148 (empty -> .)
    END             reduce using rule 148 (empty -> .)
    ELSIF           reduce using rule 148 (empty -> .)
    ELSE            reduce using rule 148 (empty -> .)
    CASE            reduce using rule 148 (empty -> .)

    optstring                      shift and go to state 258
    empty                          shift and go to state 37

state 223

    (123) aliasstmt -> ALIAS aliases . DO optstmts END
    (124) aliases -> aliases . ; alias
    (125) aliases -> aliases . ;

    DO              shift and go to state 259
    ;               shift and go to state 69


state 224

    (128) returnstmt -> RETURN optretexpr .

    ;               reduce using rule 128 (returnstmt -> RETURN optretexpr .)
    END             reduce using rule 128 (returnstmt -> RETURN optretexpr .)
    ELSIF           reduce using rule 128 (returnstmt -> RETURN optretexpr .)
    ELSE            reduce using rule 128 (returnstmt -> RETURN optretexpr .)
    CASE            reduce using rule 128 (returnstmt -> RETURN optretexpr .)


state 225

    (129) optretexpr -> expr .
    (56) expr -> expr . ? expr : expr
    (57) expr -> expr . IMPLIES expr
    (58) expr -> expr . | expr
    (59) expr -> expr . & expr
    (60) expr -> expr . < expr
    (61) expr -> expr . LEQ expr
    (62) expr -> expr . > expr
    (63) expr -> expr . GEQ expr
    (64) expr -> expr . = expr
    (65) expr -> expr . NEQ expr
    (66) expr -> expr . + expr
    (67) expr -> expr . - expr
    (68) expr -> expr . * expr
    (69) expr -> expr . / expr
    (70) expr -> expr . % expr

    ;               reduce using rule 129 (optretexpr -> expr .)
    END             reduce using rule 129 (optretexpr -> expr .)
    ELSIF           reduce using rule 129 (optretexpr -> expr .)
    ELSE            reduce using rule 129 (optretexpr -> expr .)
    CASE            reduce using rule 129 (optretexpr -> expr .)
    ?               shift and go to state 96
    IMPLIES         shift and go to state 97
    |               shift and go to state 98
    &               shift and go to state 99
    <               shift and go to state 100
    LEQ             shift and go to state 101
    >               shift and go to state 102
    GEQ             shift and go to state 103
    =               shift and go to state 104
    NEQ             shift and go to state 105
    +               shift and go to state 106
    -               shift and go to state 107
    *               shift and go to state 108
    /               shift and go to state 109
    %               shift and go to state 110


state 226

    (130) optretexpr -> empty .

    ;               reduce using rule 130 (optretexpr -> empty .)
    END             reduce using rule 130 (optretexpr -> empty .)
    ELSIF           reduce using rule 130 (optretexpr -> empty .)
    ELSE            reduce using rule 130 (optretexpr -> empty .)
    CASE            reduce using rule 130 (optretexpr -> empty .)


state 227

    (120) undefinestmt -> UNDEFINE designator .
    (54) designator -> designator . [ expr ]
    (55) designator -> designator . . ID

    ;               reduce using rule 120 (undefinestmt -> UNDEFINE designator .)
    END             reduce using rule 120 (undefinestmt -> UNDEFINE designator .)
    ELSIF           reduce using rule 120 (undefinestmt -> UNDEFINE designator .)
    ELSE            reduce using rule 120 (undefinestmt -> UNDEFINE designator .)
    CASE            reduce using rule 120 (undefinestmt -> UNDEFINE designator .)
    [               shift and go to state 114
    .               shift and go to state 115


state 228

    (34) vardecltail -> , ID vardecltail .

    ;               reduce using rule 34 (vardecltail -> , ID vardecltail .)


state 229

    (49) formaltail -> , ID . formaltail
    (49) formaltail -> . , ID formaltail
    (50) formaltail -> . : typeexpr

    ,               shift and go to state 172
    :               shift and go to state 173

    formaltail                     shift and go to state 260

state 230

    (50) formaltail -> : typeexpr .

    ;               reduce using rule 50 (formaltail -> : typeexpr .)
    )               reduce using rule 50 (formaltail -> : typeexpr .)


state 231

    (39) procdecl -> PROCEDURE ID ( optformals ) ; . optdecls optstmts END ;
    (51) optdecls -> . decls BEGIN
    (52) optdecls -> . empty
    (2) decls -> . decls decl
    (3) decls -> . empty
    (148) empty -> .

    IF              reduce using rule 148 (empty -> .)
    WHILE           reduce using rule 148 (empty -> .)
    SWITCH          reduce using rule 148 (empty -> .)
    FOR             reduce using rule 148 (empty -> .)
    ID              reduce using rule 148 (empty -> .)
    CLEAR           reduce using rule 148 (empty -> .)
    ERROR           reduce using rule 148 (empty -> .)
    ASSERT          reduce using rule 148 (empty -> .)
    ALIAS           reduce using rule 148 (empty -> .)
    RETURN          reduce using rule 148 (empty -> .)
    UNDEFINE        reduce using rule 148 (empty -> .)
    END             reduce using rule 148 (empty -> .)
    BEGIN           reduce using rule 148 (empty -> .)
    CONST           reduce using rule 148 (empty -> .)
    TYPE            reduce using rule 148 (empty -> .)
    VAR             reduce using rule 148 (empty -> .)

    optdecls                       shift and go to state 261
    decls                          shift and go to state 75
    empty                          shift and go to state 76

state 232

    (43) formals -> formals ; formal .

    ;               reduce using rule 43 (formals -> formals ; formal .)
    )               reduce using rule 43 (formals -> formals ; formal .)


state 233

    (40) funcdecl -> FUNCTION ID ( optformals ) : . typeexpr ; optdecls optstmts END ;
    (13) typeexpr -> . typeid
    (14) typeexpr -> . enumtype
    (15) typeexpr -> . subrangetype
    (16) typeexpr -> . recordtype
    (17) typeexpr -> . arraytype
    (18) typeid -> . ID
    (19) enumtype -> . ENUM { enums }
    (22) subrangetype -> . expr DOTDOT expr
    (23) recordtype -> . RECORD fields END
    (30) arraytype -> . ARRAY [ typeexpr ] OF typeexpr
    (56) expr -> . expr ? expr : expr
    (57) expr -> . expr IMPLIES expr
    (58) expr -> . expr | expr
    (59) expr -> . expr & expr
    (60) expr -> . expr < expr
    (61) expr -> . expr LEQ expr
    (62) expr -> . expr > expr
    (63) expr -> . expr GEQ expr
    (64) expr -> . expr = expr
    (65) expr -> . expr NEQ expr
    (66) expr -> . expr + expr
    (67) expr -> . expr - expr
    (68) expr -> . expr * expr
    (69) expr -> . expr / expr
    (70) expr -> . expr % expr
    (71) expr -> . ! expr
    (72) expr -> . + expr
    (73) expr -> . - expr
    (74) expr -> . INTCONST
    (75) expr -> . designator
    (76) expr -> . ID actuals
    (77) expr -> . ISUNDEFINED ( designator )
    (78) expr -> . ( expr )
    (79) expr -> . FORALL quantifiers DO expr END
    (80) expr -> . EXISTS quantifiers DO expr END
    (53) designator -> . ID
    (54) designator -> . designator [ expr ]
    (55) designator -> . designator . ID

    ID              shift and go to state 127
    ENUM            shift and go to state 134
    RECORD          shift and go to state 136
    ARRAY           shift and go to state 137
    !               shift and go to state 60
    +               shift and go to state 58
    -               shift and go to state 59
    INTCONST        shift and go to state 61
    ISUNDEFINED     shift and go to state 64
    (               shift and go to state 65
    FORALL          shift and go to state 66
    EXISTS          shift and go to state 67

    typeexpr                       shift and go to state 262
    typeid                         shift and go to state 129
    enumtype                       shift and go to state 130
    subrangetype                   shift and go to state 131
    recordtype                     shift and go to state 132
    arraytype                      shift and go to state 133
    expr                           shift and go to state 135
    designator                     shift and go to state 62

state 234

    (139) simplerule -> RULE optstring optcondition optdecls optstmts END .

    ;               reduce using rule 139 (simplerule -> RULE optstring optcondition optdecls optstmts END .)
    $end            reduce using rule 139 (simplerule -> RULE optstring optcondition optdecls optstmts END .)
    END             reduce using rule 139 (simplerule -> RULE optstring optcondition optdecls optstmts END .)


state 235

    (56) expr -> expr ? expr : . expr
    (56) expr -> . expr ? expr : expr
    (57) expr -> . expr IMPLIES expr
    (58) expr -> . expr | expr
    (59) expr -> . expr & expr
    (60) expr -> . expr < expr
    (61) expr -> . expr LEQ expr
    (62) expr -> . expr > expr
    (63) expr -> . expr GEQ expr
    (64) expr -> . expr = expr
    (65) expr -> . expr NEQ expr
    (66) expr -> . expr + expr
    (67) expr -> . expr - expr
    (68) expr -> . expr * expr
    (69) expr -> . expr / expr
    (70) expr -> . expr % expr
    (71) expr -> . ! expr
    (72) expr -> . + expr
    (73) expr -> . - expr
    (74) expr -> . INTCONST
    (75) expr -> . designator
    (76) expr -> . ID actuals
    (77) expr -> . ISUNDEFINED ( designator )
    (78) expr -> . ( expr )
    (79) expr -> . FORALL quantifiers DO expr END
    (80) expr -> . EXISTS quantifiers DO expr END
    (53) designator -> . ID
    (54) designator -> . designator [ expr ]
    (55) designator -> . designator . ID

    !               shift and go to state 60
    +               shift and go to state 58
    -               shift and go to state 59
    INTCONST        shift and go to state 61
    ID              shift and go to state 63
    ISUNDEFINED     shift and go to state 64
    (               shift and go to state 65
    FORALL          shift and go to state 66
    EXISTS          shift and go to state 67

    expr                           shift and go to state 263
    designator                     shift and go to state 62

state 236

    (54) designator -> designator [ expr ] .

    [               reduce using rule 54 (designator -> designator [ expr ] .)
    .               reduce using rule 54 (designator -> designator [ expr ] .)
    LONGARROW       reduce using rule 54 (designator -> designator [ expr ] .)
    ?               reduce using rule 54 (designator -> designator [ expr ] .)
    IMPLIES         reduce using rule 54 (designator -> designator [ expr ] .)
    |               reduce using rule 54 (designator -> designator [ expr ] .)
    &               reduce using rule 54 (designator -> designator [ expr ] .)
    <               reduce using rule 54 (designator -> designator [ expr ] .)
    LEQ             reduce using rule 54 (designator -> designator [ expr ] .)
    >               reduce using rule 54 (designator -> designator [ expr ] .)
    GEQ             reduce using rule 54 (designator -> designator [ expr ] .)
    =               reduce using rule 54 (designator -> designator [ expr ] .)
    NEQ             reduce using rule 54 (designator -> designator [ expr ] .)
    +               reduce using rule 54 (designator -> designator [ expr ] .)
    -               reduce using rule 54 (designator -> designator [ expr ] .)
    *               reduce using rule 54 (designator -> designator [ expr ] .)
    /               reduce using rule 54 (designator -> designator [ expr ] .)
    %               reduce using rule 54 (designator -> designator [ expr ] .)
    ;               reduce using rule 54 (designator -> designator [ expr ] .)
    $end            reduce using rule 54 (designator -> designator [ expr ] .)
    END             reduce using rule 54 (designator -> designator [ expr ] .)
    )               reduce using rule 54 (designator -> designator [ expr ] .)
    DO              reduce using rule 54 (designator -> designator [ expr ] .)
    DOTDOT          reduce using rule 54 (designator -> designator [ expr ] .)
    :               reduce using rule 54 (designator -> designator [ expr ] .)
    ]               reduce using rule 54 (designator -> designator [ expr ] .)
    ,               reduce using rule 54 (designator -> designator [ expr ] .)
    THEN            reduce using rule 54 (designator -> designator [ expr ] .)
    ELSE            reduce using rule 54 (designator -> designator [ expr ] .)
    CASE            reduce using rule 54 (designator -> designator [ expr ] .)
    STRING          reduce using rule 54 (designator -> designator [ expr ] .)
    ELSIF           reduce using rule 54 (designator -> designator [ expr ] .)
    ASSIGN          reduce using rule 54 (designator -> designator [ expr ] .)


state 237

    (81) actuals -> ( exprlist ) .

    LONGARROW       reduce using rule 81 (actuals -> ( exprlist ) .)
    ?               reduce using rule 81 (actuals -> ( exprlist ) .)
    IMPLIES         reduce using rule 81 (actuals -> ( exprlist ) .)
    |               reduce using rule 81 (actuals -> ( exprlist ) .)
    &               reduce using rule 81 (actuals -> ( exprlist ) .)
    <               reduce using rule 81 (actuals -> ( exprlist ) .)
    LEQ             reduce using rule 81 (actuals -> ( exprlist ) .)
    >               reduce using rule 81 (actuals -> ( exprlist ) .)
    GEQ             reduce using rule 81 (actuals -> ( exprlist ) .)
    =               reduce using rule 81 (actuals -> ( exprlist ) .)
    NEQ             reduce using rule 81 (actuals -> ( exprlist ) .)
    +               reduce using rule 81 (actuals -> ( exprlist ) .)
    -               reduce using rule 81 (actuals -> ( exprlist ) .)
    *               reduce using rule 81 (actuals -> ( exprlist ) .)
    /               reduce using rule 81 (actuals -> ( exprlist ) .)
    %               reduce using rule 81 (actuals -> ( exprlist ) .)
    ;               reduce using rule 81 (actuals -> ( exprlist ) .)
    $end            reduce using rule 81 (actuals -> ( exprlist ) .)
    END             reduce using rule 81 (actuals -> ( exprlist ) .)
    )               reduce using rule 81 (actuals -> ( exprlist ) .)
    DO              reduce using rule 81 (actuals -> ( exprlist ) .)
    DOTDOT          reduce using rule 81 (actuals -> ( exprlist ) .)
    :               reduce using rule 81 (actuals -> ( exprlist ) .)
    ]               reduce using rule 81 (actuals -> ( exprlist ) .)
    ,               reduce using rule 81 (actuals -> ( exprlist ) .)
    THEN            reduce using rule 81 (actuals -> ( exprlist ) .)
    ELSE            reduce using rule 81 (actuals -> ( exprlist ) .)
    CASE            reduce using rule 81 (actuals -> ( exprlist ) .)
    STRING          reduce using rule 81 (actuals -> ( exprlist ) .)
    ELSIF           reduce using rule 81 (actuals -> ( exprlist ) .)


state 238

    (83) exprlist -> exprlist , . expr
    (56) expr -> . expr ? expr : expr
    (57) expr -> . expr IMPLIES expr
    (58) expr -> . expr | expr
    (59) expr -> . expr & expr
    (60) expr -> . expr < expr
    (61) expr -> . expr LEQ expr
    (62) expr -> . expr > expr
    (63) expr -> . expr GEQ expr
    (64) expr -> . expr = expr
    (65) expr -> . expr NEQ expr
    (66) expr -> . expr + expr
    (67) expr -> . expr - expr
    (68) expr -> . expr * expr
    (69) expr -> . expr / expr
    (70) expr -> . expr % expr
    (71) expr -> . ! expr
    (72) expr -> . + expr
    (73) expr -> . - expr
    (74) expr -> . INTCONST
    (75) expr -> . designator
    (76) expr -> . ID actuals
    (77) expr -> . ISUNDEFINED ( designator )
    (78) expr -> . ( expr )
    (79) expr -> . FORALL quantifiers DO expr END
    (80) expr -> . EXISTS quantifiers DO expr END
    (53) designator -> . ID
    (54) designator -> . designator [ expr ]
    (55) designator -> . designator . ID

    !               shift and go to state 60
    +               shift and go to state 58
    -               shift and go to state 59
    INTCONST        shift and go to state 61
    ID              shift and go to state 63
    ISUNDEFINED     shift and go to state 64
    (               shift and go to state 65
    FORALL          shift and go to state 66
    EXISTS          shift and go to state 67

    expr                           shift and go to state 264
    designator                     shift and go to state 62

state 239

    (77) expr -> ISUNDEFINED ( designator ) .

    LONGARROW       reduce using rule 77 (expr -> ISUNDEFINED ( designator ) .)
    ?               reduce using rule 77 (expr -> ISUNDEFINED ( designator ) .)
    IMPLIES         reduce using rule 77 (expr -> ISUNDEFINED ( designator ) .)
    |               reduce using rule 77 (expr -> ISUNDEFINED ( designator ) .)
    &               reduce using rule 77 (expr -> ISUNDEFINED ( designator ) .)
    <               reduce using rule 77 (expr -> ISUNDEFINED ( designator ) .)
    LEQ             reduce using rule 77 (expr -> ISUNDEFINED ( designator ) .)
    >               reduce using rule 77 (expr -> ISUNDEFINED ( designator ) .)
    GEQ             reduce using rule 77 (expr -> ISUNDEFINED ( designator ) .)
    =               reduce using rule 77 (expr -> ISUNDEFINED ( designator ) .)
    NEQ             reduce using rule 77 (expr -> ISUNDEFINED ( designator ) .)
    +               reduce using rule 77 (expr -> ISUNDEFINED ( designator ) .)
    -               reduce using rule 77 (expr -> ISUNDEFINED ( designator ) .)
    *               reduce using rule 77 (expr -> ISUNDEFINED ( designator ) .)
    /               reduce using rule 77 (expr -> ISUNDEFINED ( designator ) .)
    %               reduce using rule 77 (expr -> ISUNDEFINED ( designator ) .)
    ;               reduce using rule 77 (expr -> ISUNDEFINED ( designator ) .)
    $end            reduce using rule 77 (expr -> ISUNDEFINED ( designator ) .)
    END             reduce using rule 77 (expr -> ISUNDEFINED ( designator ) .)
    )               reduce using rule 77 (expr -> ISUNDEFINED ( designator ) .)
    DO              reduce using rule 77 (expr -> ISUNDEFINED ( designator ) .)
    DOTDOT          reduce using rule 77 (expr -> ISUNDEFINED ( designator ) .)
    :               reduce using rule 77 (expr -> ISUNDEFINED ( designator ) .)
    ]               reduce using rule 77 (expr -> ISUNDEFINED ( designator ) .)
    ,               reduce using rule 77 (expr -> ISUNDEFINED ( designator ) .)
    THEN            reduce using rule 77 (expr -> ISUNDEFINED ( designator ) .)
    ELSE            reduce using rule 77 (expr -> ISUNDEFINED ( designator ) .)
    CASE            reduce using rule 77 (expr -> ISUNDEFINED ( designator ) .)
    STRING          reduce using rule 77 (expr -> ISUNDEFINED ( designator ) .)
    ELSIF           reduce using rule 77 (expr -> ISUNDEFINED ( designator ) .)


state 240

    (79) expr -> FORALL quantifiers DO expr . END
    (56) expr -> expr . ? expr : expr
    (57) expr -> expr . IMPLIES expr
    (58) expr -> expr . | expr
    (59) expr -> expr . & expr
    (60) expr -> expr . < expr
    (61) expr -> expr . LEQ expr
    (62) expr -> expr . > expr
    (63) expr -> expr . GEQ expr
    (64) expr -> expr . = expr
    (65) expr -> expr . NEQ expr
    (66) expr -> expr . + expr
    (67) expr -> expr . - expr
    (68) expr -> expr . * expr
    (69) expr -> expr . / expr
    (70) expr -> expr . % expr

    END             shift and go to state 265
    ?               shift and go to state 96
    IMPLIES         shift and go to state 97
    |               shift and go to state 98
    &               shift and go to state 99
    <               shift and go to state 100
    LEQ             shift and go to state 101
    >               shift and go to state 102
    GEQ             shift and go to state 103
    =               shift and go to state 104
    NEQ             shift and go to state 105
    +               shift and go to state 106
    -               shift and go to state 107
    *               shift and go to state 108
    /               shift and go to state 109
    %               shift and go to state 110


state 241

    (80) expr -> EXISTS quantifiers DO expr . END
    (56) expr -> expr . ? expr : expr
    (57) expr -> expr . IMPLIES expr
    (58) expr -> expr . | expr
    (59) expr -> expr . & expr
    (60) expr -> expr . < expr
    (61) expr -> expr . LEQ expr
    (62) expr -> expr . > expr
    (63) expr -> expr . GEQ expr
    (64) expr -> expr . = expr
    (65) expr -> expr . NEQ expr
    (66) expr -> expr . + expr
    (67) expr -> expr . - expr
    (68) expr -> expr . * expr
    (69) expr -> expr . / expr
    (70) expr -> expr . % expr

    END             shift and go to state 266
    ?               shift and go to state 96
    IMPLIES         shift and go to state 97
    |               shift and go to state 98
    &               shift and go to state 99
    <               shift and go to state 100
    LEQ             shift and go to state 101
    >               shift and go to state 102
    GEQ             shift and go to state 103
    =               shift and go to state 104
    NEQ             shift and go to state 105
    +               shift and go to state 106
    -               shift and go to state 107
    *               shift and go to state 108
    /               shift and go to state 109
    %               shift and go to state 110


state 242

    (19) enumtype -> ENUM { enums . }
    (20) enums -> enums . , ID

    }               shift and go to state 267
    ,               shift and go to state 268


state 243

    (21) enums -> ID .

    }               reduce using rule 21 (enums -> ID .)
    ,               reduce using rule 21 (enums -> ID .)


state 244

    (22) subrangetype -> expr DOTDOT expr .
    (56) expr -> expr . ? expr : expr
    (57) expr -> expr . IMPLIES expr
    (58) expr -> expr . | expr
    (59) expr -> expr . & expr
    (60) expr -> expr . < expr
    (61) expr -> expr . LEQ expr
    (62) expr -> expr . > expr
    (63) expr -> expr . GEQ expr
    (64) expr -> expr . = expr
    (65) expr -> expr . NEQ expr
    (66) expr -> expr . + expr
    (67) expr -> expr . - expr
    (68) expr -> expr . * expr
    (69) expr -> expr . / expr
    (70) expr -> expr . % expr

    ;               reduce using rule 22 (subrangetype -> expr DOTDOT expr .)
    DO              reduce using rule 22 (subrangetype -> expr DOTDOT expr .)
    )               reduce using rule 22 (subrangetype -> expr DOTDOT expr .)
    ]               reduce using rule 22 (subrangetype -> expr DOTDOT expr .)
    END             reduce using rule 22 (subrangetype -> expr DOTDOT expr .)
    ?               shift and go to state 96
    IMPLIES         shift and go to state 97
    |               shift and go to state 98
    &               shift and go to state 99
    <               shift and go to state 100
    LEQ             shift and go to state 101
    >               shift and go to state 102
    GEQ             shift and go to state 103
    =               shift and go to state 104
    NEQ             shift and go to state 105
    +               shift and go to state 106
    -               shift and go to state 107
    *               shift and go to state 108
    /               shift and go to state 109
    %               shift and go to state 110


state 245

    (23) recordtype -> RECORD fields END .

    ;               reduce using rule 23 (recordtype -> RECORD fields END .)
    DO              reduce using rule 23 (recordtype -> RECORD fields END .)
    )               reduce using rule 23 (recordtype -> RECORD fields END .)
    ]               reduce using rule 23 (recordtype -> RECORD fields END .)
    END             reduce using rule 23 (recordtype -> RECORD fields END .)


state 246

    (24) fields -> fields ; . field
    (25) fields -> fields ; .
    (27) field -> . ID fieldtail

    END             reduce using rule 25 (fields -> fields ; .)
    ;               reduce using rule 25 (fields -> fields ; .)
    ID              shift and go to state 210

    field                          shift and go to state 269

state 247

    (27) field -> ID fieldtail .

    END             reduce using rule 27 (field -> ID fieldtail .)
    ;               reduce using rule 27 (field -> ID fieldtail .)


state 248

    (28) fieldtail -> , . ID fieldtail

    ID              shift and go to state 270


state 249

    (29) fieldtail -> : . typeexpr
    (13) typeexpr -> . typeid
    (14) typeexpr -> . enumtype
    (15) typeexpr -> . subrangetype
    (16) typeexpr -> . recordtype
    (17) typeexpr -> . arraytype
    (18) typeid -> . ID
    (19) enumtype -> . ENUM { enums }
    (22) subrangetype -> . expr DOTDOT expr
    (23) recordtype -> . RECORD fields END
    (30) arraytype -> . ARRAY [ typeexpr ] OF typeexpr
    (56) expr -> . expr ? expr : expr
    (57) expr -> . expr IMPLIES expr
    (58) expr -> . expr | expr
    (59) expr -> . expr & expr
    (60) expr -> . expr < expr
    (61) expr -> . expr LEQ expr
    (62) expr -> . expr > expr
    (63) expr -> . expr GEQ expr
    (64) expr -> . expr = expr
    (65) expr -> . expr NEQ expr
    (66) expr -> . expr + expr
    (67) expr -> . expr - expr
    (68) expr -> . expr * expr
    (69) expr -> . expr / expr
    (70) expr -> . expr % expr
    (71) expr -> . ! expr
    (72) expr -> . + expr
    (73) expr -> . - expr
    (74) expr -> . INTCONST
    (75) expr -> . designator
    (76) expr -> . ID actuals
    (77) expr -> . ISUNDEFINED ( designator )
    (78) expr -> . ( expr )
    (79) expr -> . FORALL quantifiers DO expr END
    (80) expr -> . EXISTS quantifiers DO expr END
    (53) designator -> . ID
    (54) designator -> . designator [ expr ]
    (55) designator -> . designator . ID

    ID              shift and go to state 127
    ENUM            shift and go to state 134
    RECORD          shift and go to state 136
    ARRAY           shift and go to state 137
    !               shift and go to state 60
    +               shift and go to state 58
    -               shift and go to state 59
    INTCONST        shift and go to state 61
    ISUNDEFINED     shift and go to state 64
    (               shift and go to state 65
    FORALL          shift and go to state 66
    EXISTS          shift and go to state 67

    typeexpr                       shift and go to state 271
    typeid                         shift and go to state 129
    enumtype                       shift and go to state 130
    subrangetype                   shift and go to state 131
    recordtype                     shift and go to state 132
    arraytype                      shift and go to state 133
    expr                           shift and go to state 135
    designator                     shift and go to state 62

state 250

    (30) arraytype -> ARRAY [ typeexpr . ] OF typeexpr

    ]               shift and go to state 272


state 251

    (90) stmts -> stmts ; stmt .

    ;               reduce using rule 90 (stmts -> stmts ; stmt .)
    END             reduce using rule 90 (stmts -> stmts ; stmt .)
    ELSIF           reduce using rule 90 (stmts -> stmts ; stmt .)
    ELSE            reduce using rule 90 (stmts -> stmts ; stmt .)
    CASE            reduce using rule 90 (stmts -> stmts ; stmt .)


state 252

    (105) assignment -> designator ASSIGN expr .
    (56) expr -> expr . ? expr : expr
    (57) expr -> expr . IMPLIES expr
    (58) expr -> expr . | expr
    (59) expr -> expr . & expr
    (60) expr -> expr . < expr
    (61) expr -> expr . LEQ expr
    (62) expr -> expr . > expr
    (63) expr -> expr . GEQ expr
    (64) expr -> expr . = expr
    (65) expr -> expr . NEQ expr
    (66) expr -> expr . + expr
    (67) expr -> expr . - expr
    (68) expr -> expr . * expr
    (69) expr -> expr . / expr
    (70) expr -> expr . % expr

    ;               reduce using rule 105 (assignment -> designator ASSIGN expr .)
    END             reduce using rule 105 (assignment -> designator ASSIGN expr .)
    ELSIF           reduce using rule 105 (assignment -> designator ASSIGN expr .)
    ELSE            reduce using rule 105 (assignment -> designator ASSIGN expr .)
    CASE            reduce using rule 105 (assignment -> designator ASSIGN expr .)
    ?               shift and go to state 96
    IMPLIES         shift and go to state 97
    |               shift and go to state 98
    &               shift and go to state 99
    <               shift and go to state 100
    LEQ             shift and go to state 101
    >               shift and go to state 102
    GEQ             shift and go to state 103
    =               shift and go to state 104
    NEQ             shift and go to state 105
    +               shift and go to state 106
    -               shift and go to state 107
    *               shift and go to state 108
    /               shift and go to state 109
    %               shift and go to state 110


state 253

    (106) ifstmt -> IF expr THEN . optstmts optelses END
    (88) optstmts -> . stmts
    (89) optstmts -> . empty
    (90) stmts -> . stmts ; stmt
    (91) stmts -> . stmts ;
    (92) stmts -> . stmt
    (148) empty -> .
    (93) stmt -> . assignment
    (94) stmt -> . ifstmt
    (95) stmt -> . whilestmt
    (96) stmt -> . switchstmt
    (97) stmt -> . forstmt
    (98) stmt -> . proccall
    (99) stmt -> . clearstmt
    (100) stmt -> . errorstmt
    (101) stmt -> . assertstmt
    (102) stmt -> . aliasstmt
    (103) stmt -> . returnstmt
    (104) stmt -> . undefinestmt
    (105) assignment -> . designator ASSIGN expr
    (106) ifstmt -> . IF expr THEN optstmts optelses END
    (112) whilestmt -> . WHILE expr DO optstmts END
    (113) switchstmt -> . SWITCH expr optcases optelse END
    (117) forstmt -> . FOR quantifiers DO optstmts END
    (118) proccall -> . ID actuals
    (119) clearstmt -> . CLEAR designator
    (121) errorstmt -> . ERROR STRING
    (122) assertstmt -> . ASSERT expr optstring
    (123) aliasstmt -> . ALIAS aliases DO optstmts END
    (128) returnstmt -> . RETURN optretexpr
    (120) undefinestmt -> . UNDEFINE designator
    (53) designator -> . ID
    (54) designator -> . designator [ expr ]
    (55) designator -> . designator . ID

    ELSIF           reduce using rule 148 (empty -> .)
    ELSE            reduce using rule 148 (empty -> .)
    END             reduce using rule 148 (empty -> .)
    IF              shift and go to state 155
    WHILE           shift and go to state 156
    SWITCH          shift and go to state 157
    FOR             shift and go to state 158
    ID              shift and go to state 159
    CLEAR           shift and go to state 160
    ERROR           shift and go to state 161
    ASSERT          shift and go to state 162
    ALIAS           shift and go to state 163
    RETURN          shift and go to state 164
    UNDEFINE        shift and go to state 165

    optstmts                       shift and go to state 273
    stmts                          shift and go to state 139
    empty                          shift and go to state 140
    stmt                           shift and go to state 141
    assignment                     shift and go to state 142
    ifstmt                         shift and go to state 143
    whilestmt                      shift and go to state 144
    switchstmt                     shift and go to state 145
    forstmt                        shift and go to state 146
    proccall                       shift and go to state 147
    clearstmt                      shift and go to state 148
    errorstmt                      shift and go to state 149
    assertstmt                     shift and go to state 150
    aliasstmt                      shift and go to state 151
    returnstmt                     shift and go to state 152
    undefinestmt                   shift and go to state 153
    designator                     shift and go to state 154

state 254

    (112) whilestmt -> WHILE expr DO . optstmts END
    (88) optstmts -> . stmts
    (89) optstmts -> . empty
    (90) stmts -> . stmts ; stmt
    (91) stmts -> . stmts ;
    (92) stmts -> . stmt
    (148) empty -> .
    (93) stmt -> . assignment
    (94) stmt -> . ifstmt
    (95) stmt -> . whilestmt
    (96) stmt -> . switchstmt
    (97) stmt -> . forstmt
    (98) stmt -> . proccall
    (99) stmt -> . clearstmt
    (100) stmt -> . errorstmt
    (101) stmt -> . assertstmt
    (102) stmt -> . aliasstmt
    (103) stmt -> . returnstmt
    (104) stmt -> . undefinestmt
    (105) assignment -> . designator ASSIGN expr
    (106) ifstmt -> . IF expr THEN optstmts optelses END
    (112) whilestmt -> . WHILE expr DO optstmts END
    (113) switchstmt -> . SWITCH expr optcases optelse END
    (117) forstmt -> . FOR quantifiers DO optstmts END
    (118) proccall -> . ID actuals
    (119) clearstmt -> . CLEAR designator
    (121) errorstmt -> . ERROR STRING
    (122) assertstmt -> . ASSERT expr optstring
    (123) aliasstmt -> . ALIAS aliases DO optstmts END
    (128) returnstmt -> . RETURN optretexpr
    (120) undefinestmt -> . UNDEFINE designator
    (53) designator -> . ID
    (54) designator -> . designator [ expr ]
    (55) designator -> . designator . ID

    END             reduce using rule 148 (empty -> .)
    IF              shift and go to state 155
    WHILE           shift and go to state 156
    SWITCH          shift and go to state 157
    FOR             shift and go to state 158
    ID              shift and go to state 159
    CLEAR           shift and go to state 160
    ERROR           shift and go to state 161
    ASSERT          shift and go to state 162
    ALIAS           shift and go to state 163
    RETURN          shift and go to state 164
    UNDEFINE        shift and go to state 165

    optstmts                       shift and go to state 274
    stmts                          shift and go to state 139
    empty                          shift and go to state 140
    stmt                           shift and go to state 141
    assignment                     shift and go to state 142
    ifstmt                         shift and go to state 143
    whilestmt                      shift and go to state 144
    switchstmt                     shift and go to state 145
    forstmt                        shift and go to state 146
    proccall                       shift and go to state 147
    clearstmt                      shift and go to state 148
    errorstmt                      shift and go to state 149
    assertstmt                     shift and go to state 150
    aliasstmt                      shift and go to state 151
    returnstmt                     shift and go to state 152
    undefinestmt                   shift and go to state 153
    designator                     shift and go to state 154

state 255

    (113) switchstmt -> SWITCH expr optcases . optelse END
    (114) optcases -> optcases . case
    (110) optelse -> . ELSE optstmts
    (111) optelse -> . empty
    (116) case -> . CASE exprlist : optstmts
    (148) empty -> .

    ELSE            shift and go to state 277
    CASE            shift and go to state 279
    END             reduce using rule 148 (empty -> .)

    optelse                        shift and go to state 275
    case                           shift and go to state 276
    empty                          shift and go to state 278

state 256

    (115) optcases -> empty .

    ELSE            reduce using rule 115 (optcases -> empty .)
    CASE            reduce using rule 115 (optcases -> empty .)
    END             reduce using rule 115 (optcases -> empty .)


state 257

    (117) forstmt -> FOR quantifiers DO . optstmts END
    (88) optstmts -> . stmts
    (89) optstmts -> . empty
    (90) stmts -> . stmts ; stmt
    (91) stmts -> . stmts ;
    (92) stmts -> . stmt
    (148) empty -> .
    (93) stmt -> . assignment
    (94) stmt -> . ifstmt
    (95) stmt -> . whilestmt
    (96) stmt -> . switchstmt
    (97) stmt -> . forstmt
    (98) stmt -> . proccall
    (99) stmt -> . clearstmt
    (100) stmt -> . errorstmt
    (101) stmt -> . assertstmt
    (102) stmt -> . aliasstmt
    (103) stmt -> . returnstmt
    (104) stmt -> . undefinestmt
    (105) assignment -> . designator ASSIGN expr
    (106) ifstmt -> . IF expr THEN optstmts optelses END
    (112) whilestmt -> . WHILE expr DO optstmts END
    (113) switchstmt -> . SWITCH expr optcases optelse END
    (117) forstmt -> . FOR quantifiers DO optstmts END
    (118) proccall -> . ID actuals
    (119) clearstmt -> . CLEAR designator
    (121) errorstmt -> . ERROR STRING
    (122) assertstmt -> . ASSERT expr optstring
    (123) aliasstmt -> . ALIAS aliases DO optstmts END
    (128) returnstmt -> . RETURN optretexpr
    (120) undefinestmt -> . UNDEFINE designator
    (53) designator -> . ID
    (54) designator -> . designator [ expr ]
    (55) designator -> . designator . ID

    END             reduce using rule 148 (empty -> .)
    IF              shift and go to state 155
    WHILE           shift and go to state 156
    SWITCH          shift and go to state 157
    FOR             shift and go to state 158
    ID              shift and go to state 159
    CLEAR           shift and go to state 160
    ERROR           shift and go to state 161
    ASSERT          shift and go to state 162
    ALIAS           shift and go to state 163
    RETURN          shift and go to state 164
    UNDEFINE        shift and go to state 165

    optstmts                       shift and go to state 280
    stmts                          shift and go to state 139
    empty                          shift and go to state 140
    stmt                           shift and go to state 141
    assignment                     shift and go to state 142
    ifstmt                         shift and go to state 143
    whilestmt                      shift and go to state 144
    switchstmt                     shift and go to state 145
    forstmt                        shift and go to state 146
    proccall                       shift and go to state 147
    clearstmt                      shift and go to state 148
    errorstmt                      shift and go to state 149
    assertstmt                     shift and go to state 150
    aliasstmt                      shift and go to state 151
    returnstmt                     shift and go to state 152
    undefinestmt                   shift and go to state 153
    designator                     shift and go to state 154

state 258

    (122) assertstmt -> ASSERT expr optstring .

    ;               reduce using rule 122 (assertstmt -> ASSERT expr optstring .)
    END             reduce using rule 122 (assertstmt -> ASSERT expr optstring .)
    ELSIF           reduce using rule 122 (assertstmt -> ASSERT expr optstring .)
    ELSE            reduce using rule 122 (assertstmt -> ASSERT expr optstring .)
    CASE            reduce using rule 122 (assertstmt -> ASSERT expr optstring .)


state 259

    (123) aliasstmt -> ALIAS aliases DO . optstmts END
    (88) optstmts -> . stmts
    (89) optstmts -> . empty
    (90) stmts -> . stmts ; stmt
    (91) stmts -> . stmts ;
    (92) stmts -> . stmt
    (148) empty -> .
    (93) stmt -> . assignment
    (94) stmt -> . ifstmt
    (95) stmt -> . whilestmt
    (96) stmt -> . switchstmt
    (97) stmt -> . forstmt
    (98) stmt -> . proccall
    (99) stmt -> . clearstmt
    (100) stmt -> . errorstmt
    (101) stmt -> . assertstmt
    (102) stmt -> . aliasstmt
    (103) stmt -> . returnstmt
    (104) stmt -> . undefinestmt
    (105) assignment -> . designator ASSIGN expr
    (106) ifstmt -> . IF expr THEN optstmts optelses END
    (112) whilestmt -> . WHILE expr DO optstmts END
    (113) switchstmt -> . SWITCH expr optcases optelse END
    (117) forstmt -> . FOR quantifiers DO optstmts END
    (118) proccall -> . ID actuals
    (119) clearstmt -> . CLEAR designator
    (121) errorstmt -> . ERROR STRING
    (122) assertstmt -> . ASSERT expr optstring
    (123) aliasstmt -> . ALIAS aliases DO optstmts END
    (128) returnstmt -> . RETURN optretexpr
    (120) undefinestmt -> . UNDEFINE designator
    (53) designator -> . ID
    (54) designator -> . designator [ expr ]
    (55) designator -> . designator . ID

    END             reduce using rule 148 (empty -> .)
    IF              shift and go to state 155
    WHILE           shift and go to state 156
    SWITCH          shift and go to state 157
    FOR             shift and go to state 158
    ID              shift and go to state 159
    CLEAR           shift and go to state 160
    ERROR           shift and go to state 161
    ASSERT          shift and go to state 162
    ALIAS           shift and go to state 163
    RETURN          shift and go to state 164
    UNDEFINE        shift and go to state 165

    optstmts                       shift and go to state 281
    stmts                          shift and go to state 139
    empty                          shift and go to state 140
    stmt                           shift and go to state 141
    assignment                     shift and go to state 142
    ifstmt                         shift and go to state 143
    whilestmt                      shift and go to state 144
    switchstmt                     shift and go to state 145
    forstmt                        shift and go to state 146
    proccall                       shift and go to state 147
    clearstmt                      shift and go to state 148
    errorstmt                      shift and go to state 149
    assertstmt                     shift and go to state 150
    aliasstmt                      shift and go to state 151
    returnstmt                     shift and go to state 152
    undefinestmt                   shift and go to state 153
    designator                     shift and go to state 154

state 260

    (49) formaltail -> , ID formaltail .

    ;               reduce using rule 49 (formaltail -> , ID formaltail .)
    )               reduce using rule 49 (formaltail -> , ID formaltail .)


state 261

    (39) procdecl -> PROCEDURE ID ( optformals ) ; optdecls . optstmts END ;
    (88) optstmts -> . stmts
    (89) optstmts -> . empty
    (90) stmts -> . stmts ; stmt
    (91) stmts -> . stmts ;
    (92) stmts -> . stmt
    (148) empty -> .
    (93) stmt -> . assignment
    (94) stmt -> . ifstmt
    (95) stmt -> . whilestmt
    (96) stmt -> . switchstmt
    (97) stmt -> . forstmt
    (98) stmt -> . proccall
    (99) stmt -> . clearstmt
    (100) stmt -> . errorstmt
    (101) stmt -> . assertstmt
    (102) stmt -> . aliasstmt
    (103) stmt -> . returnstmt
    (104) stmt -> . undefinestmt
    (105) assignment -> . designator ASSIGN expr
    (106) ifstmt -> . IF expr THEN optstmts optelses END
    (112) whilestmt -> . WHILE expr DO optstmts END
    (113) switchstmt -> . SWITCH expr optcases optelse END
    (117) forstmt -> . FOR quantifiers DO optstmts END
    (118) proccall -> . ID actuals
    (119) clearstmt -> . CLEAR designator
    (121) errorstmt -> . ERROR STRING
    (122) assertstmt -> . ASSERT expr optstring
    (123) aliasstmt -> . ALIAS aliases DO optstmts END
    (128) returnstmt -> . RETURN optretexpr
    (120) undefinestmt -> . UNDEFINE designator
    (53) designator -> . ID
    (54) designator -> . designator [ expr ]
    (55) designator -> . designator . ID

    END             reduce using rule 148 (empty -> .)
    IF              shift and go to state 155
    WHILE           shift and go to state 156
    SWITCH          shift and go to state 157
    FOR             shift and go to state 158
    ID              shift and go to state 159
    CLEAR           shift and go to state 160
    ERROR           shift and go to state 161
    ASSERT          shift and go to state 162
    ALIAS           shift and go to state 163
    RETURN          shift and go to state 164
    UNDEFINE        shift and go to state 165

    optstmts                       shift and go to state 282
    stmts                          shift and go to state 139
    empty                          shift and go to state 140
    stmt                           shift and go to state 141
    assignment                     shift and go to state 142
    ifstmt                         shift and go to state 143
    whilestmt                      shift and go to state 144
    switchstmt                     shift and go to state 145
    forstmt                        shift and go to state 146
    proccall                       shift and go to state 147
    clearstmt                      shift and go to state 148
    errorstmt                      shift and go to state 149
    assertstmt                     shift and go to state 150
    aliasstmt                      shift and go to state 151
    returnstmt                     shift and go to state 152
    undefinestmt                   shift and go to state 153
    designator                     shift and go to state 154

state 262

    (40) funcdecl -> FUNCTION ID ( optformals ) : typeexpr . ; optdecls optstmts END ;

    ;               shift and go to state 283


state 263

    (56) expr -> expr ? expr : expr .
    (56) expr -> expr . ? expr : expr
    (57) expr -> expr . IMPLIES expr
    (58) expr -> expr . | expr
    (59) expr -> expr . & expr
    (60) expr -> expr . < expr
    (61) expr -> expr . LEQ expr
    (62) expr -> expr . > expr
    (63) expr -> expr . GEQ expr
    (64) expr -> expr . = expr
    (65) expr -> expr . NEQ expr
    (66) expr -> expr . + expr
    (67) expr -> expr . - expr
    (68) expr -> expr . * expr
    (69) expr -> expr . / expr
    (70) expr -> expr . % expr

    LONGARROW       reduce using rule 56 (expr -> expr ? expr : expr .)
    ?               reduce using rule 56 (expr -> expr ? expr : expr .)
    ;               reduce using rule 56 (expr -> expr ? expr : expr .)
    $end            reduce using rule 56 (expr -> expr ? expr : expr .)
    END             reduce using rule 56 (expr -> expr ? expr : expr .)
    )               reduce using rule 56 (expr -> expr ? expr : expr .)
    DO              reduce using rule 56 (expr -> expr ? expr : expr .)
    DOTDOT          reduce using rule 56 (expr -> expr ? expr : expr .)
    :               reduce using rule 56 (expr -> expr ? expr : expr .)
    ]               reduce using rule 56 (expr -> expr ? expr : expr .)
    ,               reduce using rule 56 (expr -> expr ? expr : expr .)
    THEN            reduce using rule 56 (expr -> expr ? expr : expr .)
    ELSE            reduce using rule 56 (expr -> expr ? expr : expr .)
    CASE            reduce using rule 56 (expr -> expr ? expr : expr .)
    STRING          reduce using rule 56 (expr -> expr ? expr : expr .)
    ELSIF           reduce using rule 56 (expr -> expr ? expr : expr .)
    IMPLIES         shift and go to state 97
    |               shift and go to state 98
    &               shift and go to state 99
    <               shift and go to state 100
    LEQ             shift and go to state 101
    >               shift and go to state 102
    GEQ             shift and go to state 103
    =               shift and go to state 104
    NEQ             shift and go to state 105
    +               shift and go to state 106
    -               shift and go to state 107
    *               shift and go to state 108
    /               shift and go to state 109
    %               shift and go to state 110

  ! IMPLIES         [ reduce using rule 56 (expr -> expr ? expr : expr .) ]
  ! |               [ reduce using rule 56 (expr -> expr ? expr : expr .) ]
  ! &               [ reduce using rule 56 (expr -> expr ? expr : expr .) ]
  ! <               [ reduce using rule 56 (expr -> expr ? expr : expr .) ]
  ! LEQ             [ reduce using rule 56 (expr -> expr ? expr : expr .) ]
  ! >               [ reduce using rule 56 (expr -> expr ? expr : expr .) ]
  ! GEQ             [ reduce using rule 56 (expr -> expr ? expr : expr .) ]
  ! =               [ reduce using rule 56 (expr -> expr ? expr : expr .) ]
  ! NEQ             [ reduce using rule 56 (expr -> expr ? expr : expr .) ]
  ! +               [ reduce using rule 56 (expr -> expr ? expr : expr .) ]
  ! -               [ reduce using rule 56 (expr -> expr ? expr : expr .) ]
  ! *               [ reduce using rule 56 (expr -> expr ? expr : expr .) ]
  ! /               [ reduce using rule 56 (expr -> expr ? expr : expr .) ]
  ! %               [ reduce using rule 56 (expr -> expr ? expr : expr .) ]
  ! ?               [ shift and go to state 96 ]


state 264

    (83) exprlist -> exprlist , expr .
    (56) expr -> expr . ? expr : expr
    (57) expr -> expr . IMPLIES expr
    (58) expr -> expr . | expr
    (59) expr -> expr . & expr
    (60) expr -> expr . < expr
    (61) expr -> expr . LEQ expr
    (62) expr -> expr . > expr
    (63) expr -> expr . GEQ expr
    (64) expr -> expr . = expr
    (65) expr -> expr . NEQ expr
    (66) expr -> expr . + expr
    (67) expr -> expr . - expr
    (68) expr -> expr . * expr
    (69) expr -> expr . / expr
    (70) expr -> expr . % expr

    )               reduce using rule 83 (exprlist -> exprlist , expr .)
    ,               reduce using rule 83 (exprlist -> exprlist , expr .)
    :               reduce using rule 83 (exprlist -> exprlist , expr .)
    ?               shift and go to state 96
    IMPLIES         shift and go to state 97
    |               shift and go to state 98
    &               shift and go to state 99
    <               shift and go to state 100
    LEQ             shift and go to state 101
    >               shift and go to state 102
    GEQ             shift and go to state 103
    =               shift and go to state 104
    NEQ             shift and go to state 105
    +               shift and go to state 106
    -               shift and go to state 107
    *               shift and go to state 108
    /               shift and go to state 109
    %               shift and go to state 110


state 265

    (79) expr -> FORALL quantifiers DO expr END .

    LONGARROW       reduce using rule 79 (expr -> FORALL quantifiers DO expr END .)
    ?               reduce using rule 79 (expr -> FORALL quantifiers DO expr END .)
    IMPLIES         reduce using rule 79 (expr -> FORALL quantifiers DO expr END .)
    |               reduce using rule 79 (expr -> FORALL quantifiers DO expr END .)
    &               reduce using rule 79 (expr -> FORALL quantifiers DO expr END .)
    <               reduce using rule 79 (expr -> FORALL quantifiers DO expr END .)
    LEQ             reduce using rule 79 (expr -> FORALL quantifiers DO expr END .)
    >               reduce using rule 79 (expr -> FORALL quantifiers DO expr END .)
    GEQ             reduce using rule 79 (expr -> FORALL quantifiers DO expr END .)
    =               reduce using rule 79 (expr -> FORALL quantifiers DO expr END .)
    NEQ             reduce using rule 79 (expr -> FORALL quantifiers DO expr END .)
    +               reduce using rule 79 (expr -> FORALL quantifiers DO expr END .)
    -               reduce using rule 79 (expr -> FORALL quantifiers DO expr END .)
    *               reduce using rule 79 (expr -> FORALL quantifiers DO expr END .)
    /               reduce using rule 79 (expr -> FORALL quantifiers DO expr END .)
    %               reduce using rule 79 (expr -> FORALL quantifiers DO expr END .)
    ;               reduce using rule 79 (expr -> FORALL quantifiers DO expr END .)
    $end            reduce using rule 79 (expr -> FORALL quantifiers DO expr END .)
    END             reduce using rule 79 (expr -> FORALL quantifiers DO expr END .)
    )               reduce using rule 79 (expr -> FORALL quantifiers DO expr END .)
    DO              reduce using rule 79 (expr -> FORALL quantifiers DO expr END .)
    DOTDOT          reduce using rule 79 (expr -> FORALL quantifiers DO expr END .)
    :               reduce using rule 79 (expr -> FORALL quantifiers DO expr END .)
    ]               reduce using rule 79 (expr -> FORALL quantifiers DO expr END .)
    ,               reduce using rule 79 (expr -> FORALL quantifiers DO expr END .)
    THEN            reduce using rule 79 (expr -> FORALL quantifiers DO expr END .)
    ELSE            reduce using rule 79 (expr -> FORALL quantifiers DO expr END .)
    CASE            reduce using rule 79 (expr -> FORALL quantifiers DO expr END .)
    STRING          reduce using rule 79 (expr -> FORALL quantifiers DO expr END .)
    ELSIF           reduce using rule 79 (expr -> FORALL quantifiers DO expr END .)


state 266

    (80) expr -> EXISTS quantifiers DO expr END .

    LONGARROW       reduce using rule 80 (expr -> EXISTS quantifiers DO expr END .)
    ?               reduce using rule 80 (expr -> EXISTS quantifiers DO expr END .)
    IMPLIES         reduce using rule 80 (expr -> EXISTS quantifiers DO expr END .)
    |               reduce using rule 80 (expr -> EXISTS quantifiers DO expr END .)
    &               reduce using rule 80 (expr -> EXISTS quantifiers DO expr END .)
    <               reduce using rule 80 (expr -> EXISTS quantifiers DO expr END .)
    LEQ             reduce using rule 80 (expr -> EXISTS quantifiers DO expr END .)
    >               reduce using rule 80 (expr -> EXISTS quantifiers DO expr END .)
    GEQ             reduce using rule 80 (expr -> EXISTS quantifiers DO expr END .)
    =               reduce using rule 80 (expr -> EXISTS quantifiers DO expr END .)
    NEQ             reduce using rule 80 (expr -> EXISTS quantifiers DO expr END .)
    +               reduce using rule 80 (expr -> EXISTS quantifiers DO expr END .)
    -               reduce using rule 80 (expr -> EXISTS quantifiers DO expr END .)
    *               reduce using rule 80 (expr -> EXISTS quantifiers DO expr END .)
    /               reduce using rule 80 (expr -> EXISTS quantifiers DO expr END .)
    %               reduce using rule 80 (expr -> EXISTS quantifiers DO expr END .)
    ;               reduce using rule 80 (expr -> EXISTS quantifiers DO expr END .)
    $end            reduce using rule 80 (expr -> EXISTS quantifiers DO expr END .)
    END             reduce using rule 80 (expr -> EXISTS quantifiers DO expr END .)
    )               reduce using rule 80 (expr -> EXISTS quantifiers DO expr END .)
    DO              reduce using rule 80 (expr -> EXISTS quantifiers DO expr END .)
    DOTDOT          reduce using rule 80 (expr -> EXISTS quantifiers DO expr END .)
    :               reduce using rule 80 (expr -> EXISTS quantifiers DO expr END .)
    ]               reduce using rule 80 (expr -> EXISTS quantifiers DO expr END .)
    ,               reduce using rule 80 (expr -> EXISTS quantifiers DO expr END .)
    THEN            reduce using rule 80 (expr -> EXISTS quantifiers DO expr END .)
    ELSE            reduce using rule 80 (expr -> EXISTS quantifiers DO expr END .)
    CASE            reduce using rule 80 (expr -> EXISTS quantifiers DO expr END .)
    STRING          reduce using rule 80 (expr -> EXISTS quantifiers DO expr END .)
    ELSIF           reduce using rule 80 (expr -> EXISTS quantifiers DO expr END .)


state 267

    (19) enumtype -> ENUM { enums } .

    ;               reduce using rule 19 (enumtype -> ENUM { enums } .)
    DO              reduce using rule 19 (enumtype -> ENUM { enums } .)
    )               reduce using rule 19 (enumtype -> ENUM { enums } .)
    ]               reduce using rule 19 (enumtype -> ENUM { enums } .)
    END             reduce using rule 19 (enumtype -> ENUM { enums } .)


state 268

    (20) enums -> enums , . ID

    ID              shift and go to state 284


state 269

    (24) fields -> fields ; field .

    END             reduce using rule 24 (fields -> fields ; field .)
    ;               reduce using rule 24 (fields -> fields ; field .)


state 270

    (28) fieldtail -> , ID . fieldtail
    (28) fieldtail -> . , ID fieldtail
    (29) fieldtail -> . : typeexpr

    ,               shift and go to state 248
    :               shift and go to state 249

    fieldtail                      shift and go to state 285

state 271

    (29) fieldtail -> : typeexpr .

    END             reduce using rule 29 (fieldtail -> : typeexpr .)
    ;               reduce using rule 29 (fieldtail -> : typeexpr .)


state 272

    (30) arraytype -> ARRAY [ typeexpr ] . OF typeexpr

    OF              shift and go to state 286


state 273

    (106) ifstmt -> IF expr THEN optstmts . optelses END
    (107) optelses -> . elsif optelses
    (108) optelses -> . optelse
    (109) elsif -> . ELSIF expr THEN optstmts
    (110) optelse -> . ELSE optstmts
    (111) optelse -> . empty
    (148) empty -> .

    ELSIF           shift and go to state 290
    ELSE            shift and go to state 277
    END             reduce using rule 148 (empty -> .)

    optelses                       shift and go to state 287
    elsif                          shift and go to state 288
    optelse                        shift and go to state 289
    empty                          shift and go to state 278

state 274

    (112) whilestmt -> WHILE expr DO optstmts . END

    END             shift and go to state 291


state 275

    (113) switchstmt -> SWITCH expr optcases optelse . END

    END             shift and go to state 292


state 276

    (114) optcases -> optcases case .

    ELSE            reduce using rule 114 (optcases -> optcases case .)
    CASE            reduce using rule 114 (optcases -> optcases case .)
    END             reduce using rule 114 (optcases -> optcases case .)


state 277

    (110) optelse -> ELSE . optstmts
    (88) optstmts -> . stmts
    (89) optstmts -> . empty
    (90) stmts -> . stmts ; stmt
    (91) stmts -> . stmts ;
    (92) stmts -> . stmt
    (148) empty -> .
    (93) stmt -> . assignment
    (94) stmt -> . ifstmt
    (95) stmt -> . whilestmt
    (96) stmt -> . switchstmt
    (97) stmt -> . forstmt
    (98) stmt -> . proccall
    (99) stmt -> . clearstmt
    (100) stmt -> . errorstmt
    (101) stmt -> . assertstmt
    (102) stmt -> . aliasstmt
    (103) stmt -> . returnstmt
    (104) stmt -> . undefinestmt
    (105) assignment -> . designator ASSIGN expr
    (106) ifstmt -> . IF expr THEN optstmts optelses END
    (112) whilestmt -> . WHILE expr DO optstmts END
    (113) switchstmt -> . SWITCH expr optcases optelse END
    (117) forstmt -> . FOR quantifiers DO optstmts END
    (118) proccall -> . ID actuals
    (119) clearstmt -> . CLEAR designator
    (121) errorstmt -> . ERROR STRING
    (122) assertstmt -> . ASSERT expr optstring
    (123) aliasstmt -> . ALIAS aliases DO optstmts END
    (128) returnstmt -> . RETURN optretexpr
    (120) undefinestmt -> . UNDEFINE designator
    (53) designator -> . ID
    (54) designator -> . designator [ expr ]
    (55) designator -> . designator . ID

    END             reduce using rule 148 (empty -> .)
    IF              shift and go to state 155
    WHILE           shift and go to state 156
    SWITCH          shift and go to state 157
    FOR             shift and go to state 158
    ID              shift and go to state 159
    CLEAR           shift and go to state 160
    ERROR           shift and go to state 161
    ASSERT          shift and go to state 162
    ALIAS           shift and go to state 163
    RETURN          shift and go to state 164
    UNDEFINE        shift and go to state 165

    optstmts                       shift and go to state 293
    stmts                          shift and go to state 139
    empty                          shift and go to state 140
    stmt                           shift and go to state 141
    assignment                     shift and go to state 142
    ifstmt                         shift and go to state 143
    whilestmt                      shift and go to state 144
    switchstmt                     shift and go to state 145
    forstmt                        shift and go to state 146
    proccall                       shift and go to state 147
    clearstmt                      shift and go to state 148
    errorstmt                      shift and go to state 149
    assertstmt                     shift and go to state 150
    aliasstmt                      shift and go to state 151
    returnstmt                     shift and go to state 152
    undefinestmt                   shift and go to state 153
    designator                     shift and go to state 154

state 278

    (111) optelse -> empty .

    END             reduce using rule 111 (optelse -> empty .)


state 279

    (116) case -> CASE . exprlist : optstmts
    (83) exprlist -> . exprlist , expr
    (84) exprlist -> . expr
    (56) expr -> . expr ? expr : expr
    (57) expr -> . expr IMPLIES expr
    (58) expr -> . expr | expr
    (59) expr -> . expr & expr
    (60) expr -> . expr < expr
    (61) expr -> . expr LEQ expr
    (62) expr -> . expr > expr
    (63) expr -> . expr GEQ expr
    (64) expr -> . expr = expr
    (65) expr -> . expr NEQ expr
    (66) expr -> . expr + expr
    (67) expr -> . expr - expr
    (68) expr -> . expr * expr
    (69) expr -> . expr / expr
    (70) expr -> . expr % expr
    (71) expr -> . ! expr
    (72) expr -> . + expr
    (73) expr -> . - expr
    (74) expr -> . INTCONST
    (75) expr -> . designator
    (76) expr -> . ID actuals
    (77) expr -> . ISUNDEFINED ( designator )
    (78) expr -> . ( expr )
    (79) expr -> . FORALL quantifiers DO expr END
    (80) expr -> . EXISTS quantifiers DO expr END
    (53) designator -> . ID
    (54) designator -> . designator [ expr ]
    (55) designator -> . designator . ID

    !               shift and go to state 60
    +               shift and go to state 58
    -               shift and go to state 59
    INTCONST        shift and go to state 61
    ID              shift and go to state 63
    ISUNDEFINED     shift and go to state 64
    (               shift and go to state 65
    FORALL          shift and go to state 66
    EXISTS          shift and go to state 67

    exprlist                       shift and go to state 294
    expr                           shift and go to state 198
    designator                     shift and go to state 62

state 280

    (117) forstmt -> FOR quantifiers DO optstmts . END

    END             shift and go to state 295


state 281

    (123) aliasstmt -> ALIAS aliases DO optstmts . END

    END             shift and go to state 296


state 282

    (39) procdecl -> PROCEDURE ID ( optformals ) ; optdecls optstmts . END ;

    END             shift and go to state 297


state 283

    (40) funcdecl -> FUNCTION ID ( optformals ) : typeexpr ; . optdecls optstmts END ;
    (51) optdecls -> . decls BEGIN
    (52) optdecls -> . empty
    (2) decls -> . decls decl
    (3) decls -> . empty
    (148) empty -> .

    IF              reduce using rule 148 (empty -> .)
    WHILE           reduce using rule 148 (empty -> .)
    SWITCH          reduce using rule 148 (empty -> .)
    FOR             reduce using rule 148 (empty -> .)
    ID              reduce using rule 148 (empty -> .)
    CLEAR           reduce using rule 148 (empty -> .)
    ERROR           reduce using rule 148 (empty -> .)
    ASSERT          reduce using rule 148 (empty -> .)
    ALIAS           reduce using rule 148 (empty -> .)
    RETURN          reduce using rule 148 (empty -> .)
    UNDEFINE        reduce using rule 148 (empty -> .)
    END             reduce using rule 148 (empty -> .)
    BEGIN           reduce using rule 148 (empty -> .)
    CONST           reduce using rule 148 (empty -> .)
    TYPE            reduce using rule 148 (empty -> .)
    VAR             reduce using rule 148 (empty -> .)

    optdecls                       shift and go to state 298
    decls                          shift and go to state 75
    empty                          shift and go to state 76

state 284

    (20) enums -> enums , ID .

    }               reduce using rule 20 (enums -> enums , ID .)
    ,               reduce using rule 20 (enums -> enums , ID .)


state 285

    (28) fieldtail -> , ID fieldtail .

    END             reduce using rule 28 (fieldtail -> , ID fieldtail .)
    ;               reduce using rule 28 (fieldtail -> , ID fieldtail .)


state 286

    (30) arraytype -> ARRAY [ typeexpr ] OF . typeexpr
    (13) typeexpr -> . typeid
    (14) typeexpr -> . enumtype
    (15) typeexpr -> . subrangetype
    (16) typeexpr -> . recordtype
    (17) typeexpr -> . arraytype
    (18) typeid -> . ID
    (19) enumtype -> . ENUM { enums }
    (22) subrangetype -> . expr DOTDOT expr
    (23) recordtype -> . RECORD fields END
    (30) arraytype -> . ARRAY [ typeexpr ] OF typeexpr
    (56) expr -> . expr ? expr : expr
    (57) expr -> . expr IMPLIES expr
    (58) expr -> . expr | expr
    (59) expr -> . expr & expr
    (60) expr -> . expr < expr
    (61) expr -> . expr LEQ expr
    (62) expr -> . expr > expr
    (63) expr -> . expr GEQ expr
    (64) expr -> . expr = expr
    (65) expr -> . expr NEQ expr
    (66) expr -> . expr + expr
    (67) expr -> . expr - expr
    (68) expr -> . expr * expr
    (69) expr -> . expr / expr
    (70) expr -> . expr % expr
    (71) expr -> . ! expr
    (72) expr -> . + expr
    (73) expr -> . - expr
    (74) expr -> . INTCONST
    (75) expr -> . designator
    (76) expr -> . ID actuals
    (77) expr -> . ISUNDEFINED ( designator )
    (78) expr -> . ( expr )
    (79) expr -> . FORALL quantifiers DO expr END
    (80) expr -> . EXISTS quantifiers DO expr END
    (53) designator -> . ID
    (54) designator -> . designator [ expr ]
    (55) designator -> . designator . ID

    ID              shift and go to state 127
    ENUM            shift and go to state 134
    RECORD          shift and go to state 136
    ARRAY           shift and go to state 137
    !               shift and go to state 60
    +               shift and go to state 58
    -               shift and go to state 59
    INTCONST        shift and go to state 61
    ISUNDEFINED     shift and go to state 64
    (               shift and go to state 65
    FORALL          shift and go to state 66
    EXISTS          shift and go to state 67

    typeexpr                       shift and go to state 299
    typeid                         shift and go to state 129
    enumtype                       shift and go to state 130
    subrangetype                   shift and go to state 131
    recordtype                     shift and go to state 132
    arraytype                      shift and go to state 133
    expr                           shift and go to state 135
    designator                     shift and go to state 62

state 287

    (106) ifstmt -> IF expr THEN optstmts optelses . END

    END             shift and go to state 300


state 288

    (107) optelses -> elsif . optelses
    (107) optelses -> . elsif optelses
    (108) optelses -> . optelse
    (109) elsif -> . ELSIF expr THEN optstmts
    (110) optelse -> . ELSE optstmts
    (111) optelse -> . empty
    (148) empty -> .

    ELSIF           shift and go to state 290
    ELSE            shift and go to state 277
    END             reduce using rule 148 (empty -> .)

    elsif                          shift and go to state 288
    optelses                       shift and go to state 301
    optelse                        shift and go to state 289
    empty                          shift and go to state 278

state 289

    (108) optelses -> optelse .

    END             reduce using rule 108 (optelses -> optelse .)


state 290

    (109) elsif -> ELSIF . expr THEN optstmts
    (56) expr -> . expr ? expr : expr
    (57) expr -> . expr IMPLIES expr
    (58) expr -> . expr | expr
    (59) expr -> . expr & expr
    (60) expr -> . expr < expr
    (61) expr -> . expr LEQ expr
    (62) expr -> . expr > expr
    (63) expr -> . expr GEQ expr
    (64) expr -> . expr = expr
    (65) expr -> . expr NEQ expr
    (66) expr -> . expr + expr
    (67) expr -> . expr - expr
    (68) expr -> . expr * expr
    (69) expr -> . expr / expr
    (70) expr -> . expr % expr
    (71) expr -> . ! expr
    (72) expr -> . + expr
    (73) expr -> . - expr
    (74) expr -> . INTCONST
    (75) expr -> . designator
    (76) expr -> . ID actuals
    (77) expr -> . ISUNDEFINED ( designator )
    (78) expr -> . ( expr )
    (79) expr -> . FORALL quantifiers DO expr END
    (80) expr -> . EXISTS quantifiers DO expr END
    (53) designator -> . ID
    (54) designator -> . designator [ expr ]
    (55) designator -> . designator . ID

    !               shift and go to state 60
    +               shift and go to state 58
    -               shift and go to state 59
    INTCONST        shift and go to state 61
    ID              shift and go to state 63
    ISUNDEFINED     shift and go to state 64
    (               shift and go to state 65
    FORALL          shift and go to state 66
    EXISTS          shift and go to state 67

    expr                           shift and go to state 302
    designator                     shift and go to state 62

state 291

    (112) whilestmt -> WHILE expr DO optstmts END .

    ;               reduce using rule 112 (whilestmt -> WHILE expr DO optstmts END .)
    END             reduce using rule 112 (whilestmt -> WHILE expr DO optstmts END .)
    ELSIF           reduce using rule 112 (whilestmt -> WHILE expr DO optstmts END .)
    ELSE            reduce using rule 112 (whilestmt -> WHILE expr DO optstmts END .)
    CASE            reduce using rule 112 (whilestmt -> WHILE expr DO optstmts END .)


state 292

    (113) switchstmt -> SWITCH expr optcases optelse END .

    ;               reduce using rule 113 (switchstmt -> SWITCH expr optcases optelse END .)
    END             reduce using rule 113 (switchstmt -> SWITCH expr optcases optelse END .)
    ELSIF           reduce using rule 113 (switchstmt -> SWITCH expr optcases optelse END .)
    ELSE            reduce using rule 113 (switchstmt -> SWITCH expr optcases optelse END .)
    CASE            reduce using rule 113 (switchstmt -> SWITCH expr optcases optelse END .)


state 293

    (110) optelse -> ELSE optstmts .

    END             reduce using rule 110 (optelse -> ELSE optstmts .)


state 294

    (116) case -> CASE exprlist . : optstmts
    (83) exprlist -> exprlist . , expr

    :               shift and go to state 303
    ,               shift and go to state 238


state 295

    (117) forstmt -> FOR quantifiers DO optstmts END .

    ;               reduce using rule 117 (forstmt -> FOR quantifiers DO optstmts END .)
    END             reduce using rule 117 (forstmt -> FOR quantifiers DO optstmts END .)
    ELSIF           reduce using rule 117 (forstmt -> FOR quantifiers DO optstmts END .)
    ELSE            reduce using rule 117 (forstmt -> FOR quantifiers DO optstmts END .)
    CASE            reduce using rule 117 (forstmt -> FOR quantifiers DO optstmts END .)


state 296

    (123) aliasstmt -> ALIAS aliases DO optstmts END .

    ;               reduce using rule 123 (aliasstmt -> ALIAS aliases DO optstmts END .)
    END             reduce using rule 123 (aliasstmt -> ALIAS aliases DO optstmts END .)
    ELSIF           reduce using rule 123 (aliasstmt -> ALIAS aliases DO optstmts END .)
    ELSE            reduce using rule 123 (aliasstmt -> ALIAS aliases DO optstmts END .)
    CASE            reduce using rule 123 (aliasstmt -> ALIAS aliases DO optstmts END .)


state 297

    (39) procdecl -> PROCEDURE ID ( optformals ) ; optdecls optstmts END . ;

    ;               shift and go to state 304


state 298

    (40) funcdecl -> FUNCTION ID ( optformals ) : typeexpr ; optdecls . optstmts END ;
    (88) optstmts -> . stmts
    (89) optstmts -> . empty
    (90) stmts -> . stmts ; stmt
    (91) stmts -> . stmts ;
    (92) stmts -> . stmt
    (148) empty -> .
    (93) stmt -> . assignment
    (94) stmt -> . ifstmt
    (95) stmt -> . whilestmt
    (96) stmt -> . switchstmt
    (97) stmt -> . forstmt
    (98) stmt -> . proccall
    (99) stmt -> . clearstmt
    (100) stmt -> . errorstmt
    (101) stmt -> . assertstmt
    (102) stmt -> . aliasstmt
    (103) stmt -> . returnstmt
    (104) stmt -> . undefinestmt
    (105) assignment -> . designator ASSIGN expr
    (106) ifstmt -> . IF expr THEN optstmts optelses END
    (112) whilestmt -> . WHILE expr DO optstmts END
    (113) switchstmt -> . SWITCH expr optcases optelse END
    (117) forstmt -> . FOR quantifiers DO optstmts END
    (118) proccall -> . ID actuals
    (119) clearstmt -> . CLEAR designator
    (121) errorstmt -> . ERROR STRING
    (122) assertstmt -> . ASSERT expr optstring
    (123) aliasstmt -> . ALIAS aliases DO optstmts END
    (128) returnstmt -> . RETURN optretexpr
    (120) undefinestmt -> . UNDEFINE designator
    (53) designator -> . ID
    (54) designator -> . designator [ expr ]
    (55) designator -> . designator . ID

    END             reduce using rule 148 (empty -> .)
    IF              shift and go to state 155
    WHILE           shift and go to state 156
    SWITCH          shift and go to state 157
    FOR             shift and go to state 158
    ID              shift and go to state 159
    CLEAR           shift and go to state 160
    ERROR           shift and go to state 161
    ASSERT          shift and go to state 162
    ALIAS           shift and go to state 163
    RETURN          shift and go to state 164
    UNDEFINE        shift and go to state 165

    optstmts                       shift and go to state 305
    stmts                          shift and go to state 139
    empty                          shift and go to state 140
    stmt                           shift and go to state 141
    assignment                     shift and go to state 142
    ifstmt                         shift and go to state 143
    whilestmt                      shift and go to state 144
    switchstmt                     shift and go to state 145
    forstmt                        shift and go to state 146
    proccall                       shift and go to state 147
    clearstmt                      shift and go to state 148
    errorstmt                      shift and go to state 149
    assertstmt                     shift and go to state 150
    aliasstmt                      shift and go to state 151
    returnstmt                     shift and go to state 152
    undefinestmt                   shift and go to state 153
    designator                     shift and go to state 154

state 299

    (30) arraytype -> ARRAY [ typeexpr ] OF typeexpr .

    ;               reduce using rule 30 (arraytype -> ARRAY [ typeexpr ] OF typeexpr .)
    DO              reduce using rule 30 (arraytype -> ARRAY [ typeexpr ] OF typeexpr .)
    )               reduce using rule 30 (arraytype -> ARRAY [ typeexpr ] OF typeexpr .)
    ]               reduce using rule 30 (arraytype -> ARRAY [ typeexpr ] OF typeexpr .)
    END             reduce using rule 30 (arraytype -> ARRAY [ typeexpr ] OF typeexpr .)


state 300

    (106) ifstmt -> IF expr THEN optstmts optelses END .

    ;               reduce using rule 106 (ifstmt -> IF expr THEN optstmts optelses END .)
    END             reduce using rule 106 (ifstmt -> IF expr THEN optstmts optelses END .)
    ELSIF           reduce using rule 106 (ifstmt -> IF expr THEN optstmts optelses END .)
    ELSE            reduce using rule 106 (ifstmt -> IF expr THEN optstmts optelses END .)
    CASE            reduce using rule 106 (ifstmt -> IF expr THEN optstmts optelses END .)


state 301

    (107) optelses -> elsif optelses .

    END             reduce using rule 107 (optelses -> elsif optelses .)


state 302

    (109) elsif -> ELSIF expr . THEN optstmts
    (56) expr -> expr . ? expr : expr
    (57) expr -> expr . IMPLIES expr
    (58) expr -> expr . | expr
    (59) expr -> expr . & expr
    (60) expr -> expr . < expr
    (61) expr -> expr . LEQ expr
    (62) expr -> expr . > expr
    (63) expr -> expr . GEQ expr
    (64) expr -> expr . = expr
    (65) expr -> expr . NEQ expr
    (66) expr -> expr . + expr
    (67) expr -> expr . - expr
    (68) expr -> expr . * expr
    (69) expr -> expr . / expr
    (70) expr -> expr . % expr

    THEN            shift and go to state 306
    ?               shift and go to state 96
    IMPLIES         shift and go to state 97
    |               shift and go to state 98
    &               shift and go to state 99
    <               shift and go to state 100
    LEQ             shift and go to state 101
    >               shift and go to state 102
    GEQ             shift and go to state 103
    =               shift and go to state 104
    NEQ             shift and go to state 105
    +               shift and go to state 106
    -               shift and go to state 107
    *               shift and go to state 108
    /               shift and go to state 109
    %               shift and go to state 110


state 303

    (116) case -> CASE exprlist : . optstmts
    (88) optstmts -> . stmts
    (89) optstmts -> . empty
    (90) stmts -> . stmts ; stmt
    (91) stmts -> . stmts ;
    (92) stmts -> . stmt
    (148) empty -> .
    (93) stmt -> . assignment
    (94) stmt -> . ifstmt
    (95) stmt -> . whilestmt
    (96) stmt -> . switchstmt
    (97) stmt -> . forstmt
    (98) stmt -> . proccall
    (99) stmt -> . clearstmt
    (100) stmt -> . errorstmt
    (101) stmt -> . assertstmt
    (102) stmt -> . aliasstmt
    (103) stmt -> . returnstmt
    (104) stmt -> . undefinestmt
    (105) assignment -> . designator ASSIGN expr
    (106) ifstmt -> . IF expr THEN optstmts optelses END
    (112) whilestmt -> . WHILE expr DO optstmts END
    (113) switchstmt -> . SWITCH expr optcases optelse END
    (117) forstmt -> . FOR quantifiers DO optstmts END
    (118) proccall -> . ID actuals
    (119) clearstmt -> . CLEAR designator
    (121) errorstmt -> . ERROR STRING
    (122) assertstmt -> . ASSERT expr optstring
    (123) aliasstmt -> . ALIAS aliases DO optstmts END
    (128) returnstmt -> . RETURN optretexpr
    (120) undefinestmt -> . UNDEFINE designator
    (53) designator -> . ID
    (54) designator -> . designator [ expr ]
    (55) designator -> . designator . ID

    ELSE            reduce using rule 148 (empty -> .)
    CASE            reduce using rule 148 (empty -> .)
    END             reduce using rule 148 (empty -> .)
    IF              shift and go to state 155
    WHILE           shift and go to state 156
    SWITCH          shift and go to state 157
    FOR             shift and go to state 158
    ID              shift and go to state 159
    CLEAR           shift and go to state 160
    ERROR           shift and go to state 161
    ASSERT          shift and go to state 162
    ALIAS           shift and go to state 163
    RETURN          shift and go to state 164
    UNDEFINE        shift and go to state 165

    optstmts                       shift and go to state 307
    stmts                          shift and go to state 139
    empty                          shift and go to state 140
    stmt                           shift and go to state 141
    assignment                     shift and go to state 142
    ifstmt                         shift and go to state 143
    whilestmt                      shift and go to state 144
    switchstmt                     shift and go to state 145
    forstmt                        shift and go to state 146
    proccall                       shift and go to state 147
    clearstmt                      shift and go to state 148
    errorstmt                      shift and go to state 149
    assertstmt                     shift and go to state 150
    aliasstmt                      shift and go to state 151
    returnstmt                     shift and go to state 152
    undefinestmt                   shift and go to state 153
    designator                     shift and go to state 154

state 304

    (39) procdecl -> PROCEDURE ID ( optformals ) ; optdecls optstmts END ; .

    PROCEDURE       reduce using rule 39 (procdecl -> PROCEDURE ID ( optformals ) ; optdecls optstmts END ; .)
    FUNCTION        reduce using rule 39 (procdecl -> PROCEDURE ID ( optformals ) ; optdecls optstmts END ; .)
    RULE            reduce using rule 39 (procdecl -> PROCEDURE ID ( optformals ) ; optdecls optstmts END ; .)
    ALIAS           reduce using rule 39 (procdecl -> PROCEDURE ID ( optformals ) ; optdecls optstmts END ; .)
    RULESET         reduce using rule 39 (procdecl -> PROCEDURE ID ( optformals ) ; optdecls optstmts END ; .)
    STARTSTATE      reduce using rule 39 (procdecl -> PROCEDURE ID ( optformals ) ; optdecls optstmts END ; .)
    INVARIANT       reduce using rule 39 (procdecl -> PROCEDURE ID ( optformals ) ; optdecls optstmts END ; .)


state 305

    (40) funcdecl -> FUNCTION ID ( optformals ) : typeexpr ; optdecls optstmts . END ;

    END             shift and go to state 308


state 306

    (109) elsif -> ELSIF expr THEN . optstmts
    (88) optstmts -> . stmts
    (89) optstmts -> . empty
    (90) stmts -> . stmts ; stmt
    (91) stmts -> . stmts ;
    (92) stmts -> . stmt
    (148) empty -> .
    (93) stmt -> . assignment
    (94) stmt -> . ifstmt
    (95) stmt -> . whilestmt
    (96) stmt -> . switchstmt
    (97) stmt -> . forstmt
    (98) stmt -> . proccall
    (99) stmt -> . clearstmt
    (100) stmt -> . errorstmt
    (101) stmt -> . assertstmt
    (102) stmt -> . aliasstmt
    (103) stmt -> . returnstmt
    (104) stmt -> . undefinestmt
    (105) assignment -> . designator ASSIGN expr
    (106) ifstmt -> . IF expr THEN optstmts optelses END
    (112) whilestmt -> . WHILE expr DO optstmts END
    (113) switchstmt -> . SWITCH expr optcases optelse END
    (117) forstmt -> . FOR quantifiers DO optstmts END
    (118) proccall -> . ID actuals
    (119) clearstmt -> . CLEAR designator
    (121) errorstmt -> . ERROR STRING
    (122) assertstmt -> . ASSERT expr optstring
    (123) aliasstmt -> . ALIAS aliases DO optstmts END
    (128) returnstmt -> . RETURN optretexpr
    (120) undefinestmt -> . UNDEFINE designator
    (53) designator -> . ID
    (54) designator -> . designator [ expr ]
    (55) designator -> . designator . ID

    ELSIF           reduce using rule 148 (empty -> .)
    ELSE            reduce using rule 148 (empty -> .)
    END             reduce using rule 148 (empty -> .)
    IF              shift and go to state 155
    WHILE           shift and go to state 156
    SWITCH          shift and go to state 157
    FOR             shift and go to state 158
    ID              shift and go to state 159
    CLEAR           shift and go to state 160
    ERROR           shift and go to state 161
    ASSERT          shift and go to state 162
    ALIAS           shift and go to state 163
    RETURN          shift and go to state 164
    UNDEFINE        shift and go to state 165

    optstmts                       shift and go to state 309
    stmts                          shift and go to state 139
    empty                          shift and go to state 140
    stmt                           shift and go to state 141
    assignment                     shift and go to state 142
    ifstmt                         shift and go to state 143
    whilestmt                      shift and go to state 144
    switchstmt                     shift and go to state 145
    forstmt                        shift and go to state 146
    proccall                       shift and go to state 147
    clearstmt                      shift and go to state 148
    errorstmt                      shift and go to state 149
    assertstmt                     shift and go to state 150
    aliasstmt                      shift and go to state 151
    returnstmt                     shift and go to state 152
    undefinestmt                   shift and go to state 153
    designator                     shift and go to state 154

state 307

    (116) case -> CASE exprlist : optstmts .

    ELSE            reduce using rule 116 (case -> CASE exprlist : optstmts .)
    CASE            reduce using rule 116 (case -> CASE exprlist : optstmts .)
    END             reduce using rule 116 (case -> CASE exprlist : optstmts .)


state 308

    (40) funcdecl -> FUNCTION ID ( optformals ) : typeexpr ; optdecls optstmts END . ;

    ;               shift and go to state 310


state 309

    (109) elsif -> ELSIF expr THEN optstmts .

    ELSIF           reduce using rule 109 (elsif -> ELSIF expr THEN optstmts .)
    ELSE            reduce using rule 109 (elsif -> ELSIF expr THEN optstmts .)
    END             reduce using rule 109 (elsif -> ELSIF expr THEN optstmts .)


state 310

    (40) funcdecl -> FUNCTION ID ( optformals ) : typeexpr ; optdecls optstmts END ; .

    PROCEDURE       reduce using rule 40 (funcdecl -> FUNCTION ID ( optformals ) : typeexpr ; optdecls optstmts END ; .)
    FUNCTION        reduce using rule 40 (funcdecl -> FUNCTION ID ( optformals ) : typeexpr ; optdecls optstmts END ; .)
    RULE            reduce using rule 40 (funcdecl -> FUNCTION ID ( optformals ) : typeexpr ; optdecls optstmts END ; .)
    ALIAS           reduce using rule 40 (funcdecl -> FUNCTION ID ( optformals ) : typeexpr ; optdecls optstmts END ; .)
    RULESET         reduce using rule 40 (funcdecl -> FUNCTION ID ( optformals ) : typeexpr ; optdecls optstmts END ; .)
    STARTSTATE      reduce using rule 40 (funcdecl -> FUNCTION ID ( optformals ) : typeexpr ; optdecls optstmts END ; .)
    INVARIANT       reduce using rule 40 (funcdecl -> FUNCTION ID ( optformals ) : typeexpr ; optdecls optstmts END ; .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for ID in state 35 resolved as shift
